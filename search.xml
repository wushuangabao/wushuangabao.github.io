<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[我的哲学沉思集]]></title>
    <url>%2F2020%2F03%2F13%2F%E6%88%91%E7%9A%84%E5%93%B2%E5%AD%A6%E6%B2%89%E6%80%9D%E9%9B%86%2F</url>
    <content type="text"><![CDATA[阅前提醒：请不要把下文表述的观点看做绝对正确的，尤其不要在考试时参考文中提及的哲学观点，因为这样可能会让你的分数变低。 语言《语言、认知背后的信息论》揭示出如下的事实： 人类个体之间的信息传输效率很低（这是生物层面的构造决定的）。 人类语言非常模糊（也就是信息量少、不确定性高，特别是古汉语。口语的模糊性也比书面语高）。 人类大脑常常给接收的信息增加预设条件（“内建”假设，常识、脑补……），帮助人类节省沟通和协作的成本。 形而上学与哲学 Materialism 唯物主义 物质主义 Idealism 理念论 观念说 理性主义 唯心主义 理想主义 Realism 现实主义 唯实论对于英语中的以上哲学词汇，我们的理解很大程度上取决于我们已知的知识和经验，以及上下文的语境。语言上的歧义会导致各种各样的矛盾，所以西方人其实比我们更难不清西方哲学的概念。 很多哲学归根到底都是语法问题，从语法上解决不掉的哲学问题才是真正的哲学问题。——熊逸 传统的哲学（形而上学），到维特根斯坦这里就已经被终结了（推荐公众号内搜索“维特根斯坦”）。剩下来的，可以用数理工具来描述的哲学，我称之为真正的哲学。 唯物主义的论证 物理指物质的性质、结构、相互作用和运动规律。 科学家对“麦克斯韦妖”悖论的解释：抽象的思考必定消耗物理资源。信息是物理的。 意识的本质是对信息（感官信息、记忆信息等）的处理，且负责处理信息的实体是物质（对于人类，是大量神经元细胞）。 3中的意识是包括人类意识在内的所有意识。 如果1、2、3、4都为真，就可以合理地推断：意识必须依赖物质而存在，也就是说，唯物主义是成立的。反过来说，只要1、2、3、4中任意一条被证伪，唯物主义就不成立。 物理学家是怎么看待意识的？至少，彭罗斯和泰格马克都认为：意识是一种物质状态，本质上是一种信息现象。彭罗斯还认为人脑是一个量子系统，人脑中存在着与宇宙有纠缠的量子，意识存在于宇宙中的某处。 物质，能量，信息信息和物质等价，可以通过信息论和热力学来证明：计算机通过高低电位进行逻辑运算，理论上，计算本身是会消耗能量的（不考虑计算机电子元件的热效应等耗散，仅仅是纯计算。这里我参考的是《新概念物理教程·热学》）。计算的结果使信息增加（不确定性减少），这说明能量转换成了信息，而能量只能从一种形式转换为另一种形式，不会凭空消失（根据能量守恒定律）。结论是：信息是能量的一种形式。而爱因斯坦著名的质能方程已经说明，能量和物质是等价的。结果就很显然了…… 写到这里，我去百度“信息是能量的一种形式”，果然发现知乎上有人已经在说“物质，能量，信息是同一个东西的三种描述方式”了——相对论联系了物质和能量；量子力学联系了能量和信息，因为“能量=普朗克常数×振动频率”，而答主认为“频率就是空间和时间量化后的信息表征”（这里我还不能理解）。（更进一步，答主认为时间和空间都可以省略掉，宇宙中只有物质、能量、信息这个“三位一体”的要素，可以用bit来描述——欢迎来到Matrix的世界。） 人，宇宙霍金：“我们看到的宇宙之所以是现在这个样子，是因为我们的存在。”注意霍金说的是“我们看到的”宇宙，也就是说，这个宇宙是“现象”的集合体，而非真实的、客观的存在（推荐公众号内搜索“物自体”）。“现象”本身就是客观事物经过感官、大脑处理，显现到意识层面的印象，形式是主观的（内容是客观的）。对于同样的客观存在，不同的观察和认知角度，会导致观测到的现象不同。只不过，这些不同的现象反映的是相同的客观实在。 霍金打了个比方：金鱼透过弯曲的鱼缸所看到的世界和人类看到的是不同的，但是如果金鱼足够聪明，它们同样可以总结出一套金鱼世界的科学定律，也能像人类一样正确地描述客观现象。这里，霍金想说明的哲学观点是依赖模型的实在论：所有的“客观实在”，都是建立在理论模型的基础上的；脱离模型谈“实在”，没有意义。在不同的模型中，事物展现出的性质也不同，我们认为基于这些模型得到的“现实”都是真实的。追问一个模型是否真实是没有意义的，只要这个模型跟我们的观测相符就行了。 人择原理人择原理可以用于解释“为什么”问题：为什么光速是299792.458km/s？为什么普朗克常数的大小是6.62607015e-34？（A：自然规律是这样）霍金会回答：“因为人类的存在。”人类具有特定的观察角度和认知方式。（B：人的视角是这样）我们一开始会难以理解——为什么不是“我们的认知能力”要如实地反映“认知对象”，而是“认知对象”要符合“我们的认知能力”？ 对此我的解释是：以上所有问题，一开始就没有意义。我既可以说是因为A所以B，也可以说是因为B所以A。实际上，就像量子纠缠中的量子是同一个波函数（不存在自己对自己的超距作用），A和B也是一个不可拆分的整体。很多事情是没有“为什么”可言的，因为“因果关系”只是人类的想象，用于描述某种相关性（概率）。物质世界中：只有相关性，没有因果性；只有“是什么”，没有“为什么”。 因果“第一推动力” 当环境中的不确定性越强，利害关系越大，人对心理依托的需求就越强。所以古代的海员，现代的官员和明星，迷信心态会远超平均值。因果关系就是一种提供确定性的工具，是我们认识客观世界的模型。对因果的不断探寻，促成了人类文明的不断发展。 思考以下问题： 对于商品，是成本影响了价格，还是价格影响了成本？商品的价值是由生产该商品的社会必要劳动时间决定的？ 光的折射现象中有两个事实。A：光总是走最短的路（只是花的时间最短，并非一定是直线）。B：空气的折射率为1、水的折射率约为1.33。A和B之间有因果关系吗？ 两个刺客在一次公共集会上合伙刺杀同一个人。他们约好：先瞄准的先射击，后瞄准的不射击。如果1号刺客一枪击毙了目标，那么就是1号刺客的行为导致目标死亡。但是假如1号刺客没开枪，那么2号刺客就会击毙目标。那么到底，谁导致了独裁者的死亡？ 时间我曾以为这就是故事的起点，记忆这东西作风诡异，总是让我琢磨不透，我们完全受制于时间，要跟随它的节拍。——《降临》 霍金与“大问题”2018年3月14日，著名物理学家斯蒂芬·霍金停止了他脑海中的宇宙漫游。那一天，他在英国剑桥的家中去世，享年76岁。他被葬在英国的威斯敏斯特大教堂，他的骨灰被安放在另外两位科学巨人的身旁：一位是牛顿，另一位是达尔文。 正是因为经历过了绝望之后重新看到了一丝希望，霍金开始把每一天都当成是一种奖赏，开始珍惜所有的一切，全身心投入到科学研究中。 可以说，霍金真的是凭借这执着和勇气把有限的生命全部投入了对“大问题”的思考中。但是，并不是所有的科学家都愿意面对真正的大问题，因为思考大问题不但脱离实际，而且会显得很“傻”。可是，霍金从来不担心自己显得“傻”。 霍金的生前好友、因为“引力波”而获得了2017 年诺贝尔物理学奖的基普·索恩是这样评价霍金的，他说：“牛顿带给我们的是答案，而霍金留给我们的是问题。霍金提出的问题，在随后的几十年里一直推动着科学的不断突破。” 英国的一位学者曾经指出：现代社会知识分子的生活其实分裂成了两种文化，分别是“科学”和“人文”。我们也常常看到，许多科学家的人文素养和社会科学方面的知识非常欠缺，而与此同时，一些文科的教授对科学的了解很可能是零。这其实是非常危险的。霍金也常常提示这种危险：如果科学的发展没有人文精神的约束，那么人类的文明可能在一千年就完全消失。而对我们每一个普通人而言，思考大问题，可以锻炼我们自己的思维能力，科学和人文，也能在你的身上完美融合。总结一下第一部分的讨论，尽管疾病给霍金的生活带来了许多不便，但它没有阻止霍金对科学的追求和对大问题的好奇。霍金的经历告诉我们，不要担心思考大问题会让我们显得很“傻”，这些思考有可能一直推动科学的发展和人类的进步。思考大问题，让我们可以从全人类的角度来重新审视我们自己的责任，也让我们可以更好地协调“科学”和“人文”。 他找到了一种方式超越知识的界限，亦同时超越忍受苦难的极限。——露西·霍金 史蒂芬·霍金著作《时间简史》《霍金讲演录》《时间简史（插图版）》《果壳中的宇宙》《我的简史》《十问：霍金沉思录》 和列纳德·蒙洛迪诺合作《时间简史（普及版）》《大设计》 和露西·霍金合作《乔治的宇宙：秘密钥匙》《乔治的宇宙：寻宝记》《乔治的宇宙：大爆炸》《乔治的宇宙：不可破解的密码》《乔治的宇宙：蓝月》]]></content>
      <categories>
        <category>扯淡杂文</category>
        <category>跬步之积</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>哲学</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[科学的尽头是什么？]]></title>
    <url>%2F2020%2F03%2F10%2F%E7%A7%91%E5%AD%A6%E7%9A%84%E5%B0%BD%E5%A4%B4%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F-1%2F</url>
    <content type="text"><![CDATA[接触上世纪90年代，人类突然收到一个从宇宙发来的信号。人们破解信号后发现，它传递的消息是一座巨大（占地几平方公里）的机器建造说明书，但是没有说明机器的用途。 建造这个座机器需要耗费巨额的资金，大约相当于1984年美国全年的GDP。于是人类为了两派。 多数科学家、政治家，以及大量好奇的群众主张：“我们必须把这个机器造出来，这是我们这一代人的使命。” 另外一派主要是宗教领袖和忠实信徒，他们认为这是来自异教徒的东西，是邪恶的、不忠于信仰的。有这个钱还不如造福人类呢。 几年之后，虽然中途遇到了各种宗教团体的破坏，机器还是建造完成了。在机器的正中间，有一个可以坐5个人的宇航员座舱。这可能是一台传输设备。 人类选了5个科学家进入座舱，并发动了机器。 回忆当我醒过来的时候，发现自己正独自坐在沙滩上。沙滩的另一头走过来一个人，我看清他的长相后，难以置信地喊道：“爸爸？”可我清楚地知道，我父亲已去世多年。 来人解释道：“不，我借用你父亲的躯体，只是为了让你不感到陌生。”他继续说着，大致讲了如下内容： 你们很聪明，机器造得不错，我们就是想让你们来找我们的。 我们是一个超级智能文明，住在6亿光年之外的一个星系。这次联络你们没有什么特别的事，只是告诉你们一声，你们人类已经进入了宇宙文明的序列。 宇宙是一个有爱的大家庭。以后我们会负责与人类的一对一帮助服务，但是是有条件的，你们人类要值得被爱。现在你们的攻击性太强了，地球上还充满了暴力与冲突。你们赶快把地球上的那些破事解决了，让人类成为一个真正文明的种族，我们才愿意帮助你们。 我们会在未来主动联系你们人类，等我们的消息吧。 我想起自己是整个人类的代表之一，便赶紧向外星人问起问题：“请问，你们在做什么？你们有终极目标吗？” 对方回答：“我们有终极目的，就是扭转热寂。简单说，就是扭转宇宙渐渐走向死亡的大趋势。我们正在试着给这个宇宙增加物质，扭转这个死亡的趋势。已经有好几个超级文明加入了我们。试验结果还不明确，但我们在努力。” 我又问：“在宇宙里，有你们畏惧的东西吗？或者说，你们有信仰吗？” 答：“我们有畏惧的东西，我们也有信仰。我们对于宇宙里的一些现象，感到非常困惑。很多迹象表明，这个宇宙在我们之前，就有高级文明存在，但它们灭亡了……这些事情我们说不清。同时，我们非常敬畏数学，如果真的有造物主的话，它应该是十一根手指头的。在圆周率 π 里，有造物主们留下的秘密。” 话音刚落，我发现自己的身体已经回到了机器的舱室里，就像刚做完一场梦醒来。其他4个人也都醒了。我得知，他们刚才的经历和我的很像，对话内容也基本一样。 我们出来后才知道，整个座舱根本没有离开过地球，仅仅是转了几圈就停下了。我们的随身摄像机也全是空白的，什么也没有记录下来。 结果，这次可以说是人类至今最伟大和里程碑式的经历，被大部分人当成了一个骗局：这整个事件，是建造承包商哈顿先生精心策划的阴谋，他从中谋取了巨额的财富。我和另外 4 名科学家都遭到了长期的审讯，但我们坚持认为自己看到的、听到的都是无可辩驳的事实！ 我知道，唯一的证明在于外星人最后的提示里。所以我用了大量的时间和精力，在十一进制下将 π 一直往下计算。 今天，当我的超级计算机终于计算到了 10 的 20 次方之后，震惊的一幕出现了——数字从随机分布的数字变成了 0 和 1 的组合！我开始试图寻找这些组合的意义。当我用特定的行数和列数将 0 和 1 排列成一个正方形时，在密密麻麻的 0 的背景上，1 这个数字形成了一个圆形！ 这就是让超级文明敬畏的东西，它是创造数学的那个神明（很可能就是造物主本人）的签名！ 神秘：科学的尽头以上，是20世纪80年代的科学家卡尔·萨根所著科幻小说《接触》的主要内容。在萨根眼中，科学的尽头是“有智崇拜”（出自《卡尔·萨根的上帝》）。他认为，人类从“无智崇拜”到“有智怀疑”是重大进步，但是，一流科学家所能证实的东西已经越来越少，而且科学的探索恐怕没有尽头。 理论物理学家罗韦力在《时间的秩序》中反复引用《俄狄浦斯王》里智者对俄狄浦斯的忠告：“停下来，不要再调查了，否则，你会找到你自己。”事实上，现今的科学家中，绝大多数都是怀疑或者否定“可知论”的（刘擎在讲尼采时说的）。 在自然界，物理学覆盖所有学科，但数学覆盖物理。物理学家往往是先得到一个数学公式，然后再对其作出物理意义上的解释，比如著名的薛定谔方程，就有许多种解释（比较出名的是哥本哈根解释）。数学是最难以撼动的真理。 有朝一日，当我们发现有人跑到数学中留下了“签名”，那会是何方神圣呢？ PS：想起小时候在 Windows98 上面玩 Word，发现一个神奇的现象：胡万进是何方神圣 往期相关文章：意识之骰对可知论的怀疑伟大的上帝；科学与神秘科学发展的量变是否能产生质变]]></content>
      <categories>
        <category>书中所得</category>
        <category>扯淡杂文</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《跟着李新学编剧》笔记]]></title>
    <url>%2F2020%2F02%2F26%2F%E3%80%8A%E8%B7%9F%E7%9D%80%E6%9D%8E%E6%96%B0%E5%AD%A6%E7%BC%96%E5%89%A7%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[神作的三个基本特质： 神作场景里的节拍更多。 看完一部神作，不仅会觉得爽，更可以从剧中搞懂一个行业的底层逻辑是什么。神作不仅提供观影体验，更提供知识。 编剧带着爱写所有人。神作中没有绝对的好人，也没有绝对的坏人。 节拍：在一场戏里，主角每次克服障碍、实现自己目标的努力就是一个节拍。节拍构建了戏剧冲突。神作的节拍浓度往往很高，而口水剧的节拍就要少很多。 戏核怎么知道一个创意可不可以发展成一个剧本？这个创意是不是一个好创意？ 戏核：一句话把整个剧本的核心创意说清楚。戏核能帮助编剧厘清思路。 好的戏核有三个元素： 陷入麻烦的主角。你的主角要遇到一个不可逃避的困境，他必须要去解决这个困境。 惊奇元素，不同寻常的内容。越惊奇，趣味和创意性越强。 反讽性，打破人的固有印象。反讽包含了两个矛盾甚至对抗的元素。 角色怎样打造一个有魅力的角色？一个角色要有哪些特质才能脱颖而出？ 让角色成为顶尖高手。可以是职业上的奇才，也可以有某项特长（如谋略）。 赋予角色强烈个性。个性极端化，会让观众对人物形成强烈的记忆点，会让观众爽。 混搭。给出一个跟主人公的特长非常不搭的一个职业、外貌或处境，暴露人物的弱点。能够增强人物的层次感，让一个人变得感性、有意思。 找一个跟班或对手。既衬托主角，又可以让主角显得更加真实立体。 结构怎样搭建剧本的整体结构？（当然，“艺术最忌讳教条”。） 大部分美剧和好莱坞电影采用的主流叙事框架：三幕戏 = 开头(25%) + 发展(50%) + 结局(25%) 第一幕做三件事： 展现模式：把主人公的日常模式展现出来。 打破模式：日常模式因为意外而打破。 给出行动理由：展现主人公内在的心理深层冲突。 第二幕：最难写的一幕，事态不断恶化，挑战接踵而来。 要给人物设计丰富的行动路线，而且一个行动要导向下一个行动。 好的编剧都是虐待狂，对自己的主人公下手都非常狠。 第三幕主要做两件事： 设置反转：用一个超大的脑洞（通常是一个反转和意外），把主人公从坑里救出来。 提供令人满意的完结方案。结尾直接影响观众的记忆观感。 编剧常常在最后安排个暖心时刻，让观众带着愉悦的记忆离开；当然如果是个悲剧，编剧最后也会让强烈的情绪绵延一会儿。 情节怎样让故事既合理（有逻辑）又惊奇（有脑洞）？ 一般遵循三原则： 多米诺原则。故事的情节要一环扣一环，遵循基本的因果关系，避免逻辑断档。 人设原则。故事的情节要符合人物的人设，做到真实可信。 不可预测原则。设置奇葩的解决方案跟转折元素，让观众猜不透剧情走向。 喜欢 = 熟悉 + 意外 怎样让剧情紧张刺激？（场景）关键是用对“节拍”。 单位时间内，增加节拍的数量：给主角增加行动障碍（可以来自对手，也可以是内心戏），以及让主角拥有更丰富的策略（把单回合战斗变成多回合交锋）。 写出人物情绪转折，并找准最后的落点。在写行动策略时裹挟着写情感变化，整场戏会显得更细腻丰富。 共情有了共情，观众才会深深卷入人物的内在世界，才会跟主角的感受逐渐合二为一。 怎样制造同情？打压主角，有三招： 让主角被误会、被羞辱、被忽视。 多重打击，包括：排除帮手和支持者，渲染敌人的强大与邪恶（甚至迫害主角），不幸的宿命，大自然的力量、社会的力量。 提高失败风险。失败的成本太低廉，就不能制造足够的紧张和危机感。 怎样让观众对局中人物产生欣赏和爱慕，甚至有希望变成他们的冲动？创造比普通人“高一厘米”的角色。也就是说主角人设应该具备普通人的大多数缺点，配以一两个超凡的优点，让这个角色显得既鹤立鸡群，又触手可及。 台词怎样写出精彩的台词？ 利用潜台词。在写台词时尽量用暗示的手法解释信息，不要事事都讲得像白开水一样。具体有三招： 话只说一半，另一半留给观众脑补和想象； 移花接木，用类比和比喻的方法，置换逻辑类似的两种东西；、 木马计，想表达的信息伴随干扰信息一起出现，达到漫不经心、混淆视听地夹带私货的效果。 用金句打动人心。最简洁快速的方法是改写经典台词。 建立角色与角色之间的连接。角色之间的对话，不要只传达信息，更要传达他们之间的关系。 初级玩家只会传递信息，中级玩家是文字游戏高手，顶级玩家则是直接诛心，可以把角色之间的关系以及情绪状态准确传达出来。 悬念制造悬念是编剧的吸引力法则中的核心技巧。怎样制造悬念？ 第一步是对问题进行拆分。将故事的核心悬念（/问题/矛盾）拆分成无数个小问题。 加深问题的紧迫感，挖坑。“悬崖抓手”经常出现在单集结尾的部分，主角面临一个看似无法逃脱的危险，或者即将揭示一个巨大的秘密。 控制信息披露，这是悬念的本质。“拼图游戏”分为 5 步：给予，掺水，限能（限制角色掌握的信息、认知和理解），搜集，试错。 写故事四误区 驱动故事的不是情节，而是人物。 吸引观众的不是逻辑，而是情感。 塑造人物的不是“作者视角”，而是“人物视角”。很多编剧一不小心就会把剧本中的人物写成相同的说话风格。 剧本呈现的不是生活素材，而是艺术加工。]]></content>
      <categories>
        <category>高屋建瓴</category>
      </categories>
      <tags>
        <tag>得到</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【设计模式】设计原则 SOLID]]></title>
    <url>%2F2019%2F12%2F17%2F%E3%80%90%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E3%80%91%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99-SOLID%2F</url>
    <content type="text"><![CDATA[SOLID 原则并非单纯的 1 个原则，而是由 5 个设计原则组成的，它们分别是： 单一职责原则 开闭原则 里式替换原则 接口隔离原则 依赖反转原则 单一职责原则（SRP）Single Responsibility Principle: A class or module should have a single reponsibility. 关于 class 和 module 有两种理解方式： 把模块看作比类更加抽象的概念，类也可以看作模块。 把模块看作比类更加粗粒度的代码块，模块中包含多个类，多个类组成一个模块。 接下来只从“类”设计的角度，来讲解如何应用这个设计原则。对于“模块”来说，可以自行引申。 一个类只负责完成一个职责或者功能。也就是说，不要设计大而全的类，要设计粒度小、功能单一的类。换个角度来讲就是，一个类包含了两个或者两个以上业务不相干的功能，那我们就说它职责不够单一，应该将它拆分成多个功能更加单一、粒度更细的类。 如何判断类的职责是否足够单一？大部分情况下，类里的方法是归为同一类功能，还是归为不相关的两类功能，并不是那么容易判定的。在真实的软件开发中，对于一个类是否职责单一的判定，是很难拿捏的。 在一个社交产品中，用下面的类来记录用户信息。1234567891011121314public class UserInfo &#123; private long userId; private String username; private String email; private String telephone; private long createTime; private long lastLoginTime; private String avatarUrl; private String provinceOfAddress; // 省 private String cityOfAddress; // 市 private String regionOfAddress; // 区 private String detailedAddress; // 详细地址 // ...省略其他属性和方法...&#125; 有两种不同的观点： UserInfo 类包含的都是跟用户相关的信息，所有的属性和方法都隶属于用户这样一个业务模型，满足单一职责原则； 地址信息在 UserInfo 类中，所占的比重比较高，可以继续拆分成独立的 UserAddress 类，UserInfo 只保留除 Address 之外的其他信息，拆分之后的两个类的职责更加单一。 不同的应用场景、不同阶段的需求背景下，对同一个类的职责是否单一的判定，可能都是不一样的。在某种应用场景或者当下的需求背景下，一个类的设计可能已经满足单一职责原则了，但如果换个应用场景或着在未来的某个需求背景下，可能就不满足了，需要继续拆分成粒度更细的类。 除此之外，从不同的业务层面去看待同一个类的设计，对类是否职责单一，也会有不同的认识。比如，例子中的 UserInfo 类。如果我们从“用户”这个业务层面来看，UserInfo 包含的信息都属于用户，满足职责单一原则。如果我们从更加细分的“用户展示信息”“地址信息”“登录认证信息”等等这些更细粒度的业务层面来看，那 UserInfo 就应该继续拆分。 综上所述，评价一个类的职责是否足够单一，我们并没有一个非常明确的、可以量化的标准，可以说，这是件非常主观、仁者见仁智者见智的事情。实际上，在真正的软件开发中，我们也没必要过于未雨绸缪，过度设计。所以，我们可以先写一个粗粒度的类，满足业务需求。随着业务的发展，如果粗粒度的类越来越庞大，代码越来越多，这个时候，我们就可以将这个粗粒度的类，拆分成几个更细粒度的类。这就是所谓的持续重构。 几条判断原则： 类中的代码行数、函数或属性过多，会影响代码的可读性和可维护性，我们就需要考虑对类进行拆分； 类依赖的其他类过多，或者依赖类的其他类过多，不符合高内聚、低耦合的设计思想，我们就需要考虑对类进行拆分； 私有方法过多，我们就要考虑能否将私有方法独立到新的类中，设置为 public 方法，供更多的类使用，从而提高代码的复用性； 比较难给类起一个合适名字，很难用一个业务名词概括，或者只能用一些笼统的 Manager、Context 之类的词语来命名，这就说明类的职责定义得可能不够清晰； 类中大量的方法都是集中操作类中的某几个属性，比如，在 UserInfo 例子中，如果一半的方法都是在操作 address 信息，那就可以考虑将这几个属性和对应的方法拆分出来。 类的职责是否设计得越专一越好？答案是否定的。 例：Serialization 类实现了一个简单协议的序列化和反序列功能，具体代码如下：123456789101112131415161718192021222324252627/** * Protocol format: identifier-string;&#123;gson string&#125; * For example: UEUEUE;&#123;&quot;a&quot;:&quot;A&quot;,&quot;b&quot;:&quot;B&quot;&#125; */public class Serialization &#123; private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;; private Gson gson; public Serialization() &#123; this.gson = new Gson(); &#125; public String serialize(Map&lt;String, String&gt; object) &#123; StringBuilder textBuilder = new StringBuilder(); textBuilder.append(IDENTIFIER_STRING); textBuilder.append(gson.toJson(object)); return textBuilder.toString(); &#125; public Map&lt;String, String&gt; deserialize(String text) &#123; if (!text.startsWith(IDENTIFIER_STRING)) &#123; return Collections.emptyMap(); &#125; String gsonStr = text.substring(IDENTIFIER_STRING.length()); return gson.fromJson(gsonStr, Map.class); &#125;&#125; 如果我们想让类的职责更加单一，我们对 Serialization 类进一步拆分，拆分成一个只负责序列化工作的 Serializer 类和另一个只负责反序列化工作的 Deserializer 类。拆分后的具体代码如下所示：1234567891011121314151617181920212223242526272829303132public class Serializer &#123; private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;; private Gson gson; public Serializer() &#123; this.gson = new Gson(); &#125; public String serialize(Map&lt;String, String&gt; object) &#123; StringBuilder textBuilder = new StringBuilder(); textBuilder.append(IDENTIFIER_STRING); textBuilder.append(gson.toJson(object)); return textBuilder.toString(); &#125;&#125;public class Deserializer &#123; private static final String IDENTIFIER_STRING = &quot;UEUEUE;&quot;; private Gson gson; public Deserializer() &#123; this.gson = new Gson(); &#125; public Map&lt;String, String&gt; deserialize(String text) &#123; if (!text.startsWith(IDENTIFIER_STRING)) &#123; return Collections.emptyMap(); &#125; String gsonStr = text.substring(IDENTIFIER_STRING.length()); return gson.fromJson(gsonStr, Map.class); &#125;&#125; 虽然经过拆分之后，Serializer 类和 Deserializer 类的职责更加单一了，但也随之带来了新的问题： 如果我们修改了协议的格式，数据标识从“UEUEUE”改为“DFDFDF”，或者序列化方式从 JSON 改为了 XML，那 Serializer 类和 Deserializer 类都需要做相应的修改，代码的内聚性显然没有原来 Serialization 高了。 而且，如果我们仅仅对 Serializer 类做了协议修改，而忘记了修改 Deserializer 类的代码，那就会导致序列化、反序列化不匹配，程序运行出错，也就是说，拆分之后，代码的可维护性变差了。 不管是应用设计原则还是设计模式，最终目的还是提高代码的可读性、可扩展性、复用性、可维护性等。我们在考虑应用某一个设计原则是否合理的时候，也可以以此作为最终的考量标准。 对扩展开放、修改封闭（OCP）Open Closed Principle: software entities (modules, classes, functions, etc.) should be open for extension , but closed for modification. 扩展性是代码质量最重要的衡量标准之一。在 23 种经典设计模式中，大部分设计模式都是为了解决代码的扩展性问题而存在的，主要遵从的设计原则就是开闭原则。 如何理解“对扩展开放、修改封闭”？添加一个新的功能应该是，在已有代码基础上扩展代码（新增模块、类、方法等），而非修改已有代码（修改模块、类、方法等）。 举例略……（这个场景中，代码的扩展性与可读性有冲突）如果我们要想添加新的告警逻辑，只需要基于扩展的方式创建新的 handler 类即可，不需要改动原来的 check() 函数的逻辑。而且，我们只需要为新的 handler 类添加单元测试，老的单元测试都不会失败，也不用修改。 修改代码就意味着 违背开放封闭原则吗？给类中添加新的属性和方法，算作“修改”还是“扩展”？ 开闭原则的定义：软件实体（模块、类、方法等）应该“对扩展开放、对修改关闭”。从定义中，我们可以看出，开闭原则可以应用在不同粒度的代码中，可以是模块，也可以类，还可以是方法（及其属性）。同样一个代码改动，在粗代码粒度下，被认定为“修改”，在细代码粒度下，又可以被认定为“扩展”。 只要它没有破坏原有的代码的正常运行，没有破坏原有的单元测试，我们就可以说，这是一个合格的代码改动。 最后，要认识到：添加一个新功能，不可能任何模块、类、方法的代码都不“修改”，这个是做不到的。类需要创建、组装、并且做一些初始化操作，才能构建成可运行的的程序，这部分代码的修改是在所难免的。我们要做的是尽量让修改操作更集中、更少、更上层，尽量让最核心、最复杂的那部分逻辑代码满足开闭原则。 如何做到“对扩展开放、修改关闭”？在讲具体的方法论之前，我们先来看一些更加偏向顶层的指导思想。为了尽量写出扩展性好的代码，我们要时刻具备扩展意识、抽象意识、封装意识。 在写代码时，我们要花点时间往前多思考一下，这段代码未来可能有哪些需求变更、如何设计代码结构，事先留好扩展点，以便在未来需求变更的时候，不需要改动代码整体结构、做到最小代码改动的情况下，新的代码能够很灵活地插入到扩展点上。 在识别出代码可变部分和不可变部分之后，我们要将可变部分封装起来，隔离变化，提供抽象化的不可变接口，给上层系统使用。当具体的实现发生变化的时候，我们只需要基于相同的抽象接口，扩展一个新的实现，替换掉老的实现即可，上游系统的代码几乎不需要修改。 多态、依赖注入、基于接口而非实现编程，以及抽象意识，说的都是同一种设计思路，只是从不同的角度、不同的层面来阐述而已。 里式替换（LSP）Liskov Substitution Principle: Barbara Liskov: If S is a subtype of T, then objects of type T may be replaced with objects of type S, without breaking the program. Robert Martin: Functions that use pointers of references to base classes must be able to use objects of derived classes without knowing it. 如何理解“里式替换原则”？子类对象（object of subtype/derived class）能够替换程序（program）中父类对象（object of base/parent class）出现的任何地方，并且保证原来程序的逻辑行为（behavior）不变及正确性不被破坏。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【浏览器工作原理】页面性能：如何系统地优化页面？]]></title>
    <url>%2F2019%2F10%2F25%2F%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%91%E9%A1%B5%E9%9D%A2%E6%80%A7%E8%83%BD%EF%BC%9A%E5%A6%82%E4%BD%95%E7%B3%BB%E7%BB%9F%E5%9C%B0%E4%BC%98%E5%8C%96%E9%A1%B5%E9%9D%A2%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[这里我们所谈论的页面优化，其实就是要让页面更快地显示和响应。由于一个页面在它不同的生命周期，侧重的关注点是不一样的，所以我们就要分析一个页面生存周期的不同阶段。 通常一个页面有三个阶段：加载阶段、交互阶段和关闭阶段。 加载阶段，是指从发出请求到渲染出完整页面的过程，影响到这个阶段的主要因素有网络和 JavaScript 脚本。 交互阶段，主要是从页面加载完成到用户交互的整合过程，影响到这个阶段的主要因素是 JavaScript 脚本。 关闭阶段，主要是用户发出指令后页面所做的一些清理操作。 这里我们要重点关注加载阶段和交互阶段，因为影响到我们体验到主要因素都在这两个阶段。下面我们来逐个分析一下。 加载阶段 并非所有的资源都会阻塞页面的首次绘制，比如图片、音频、视频等文件；而 JavaScript、首次请求的 HTML 资源文件、CSS 文件是会阻塞首次渲染的，因为在构建 DOM 的过程中需要 HTML 和 JavaScript 文件，在构造渲染树的过程中需要 CSS 文件。 这些能阻塞页面首次渲染的资源被称为关键资源。基于关键资源，我们可以继续细化出三个影响页面首次渲染的核心因素。 关键资源个数。 关键资源大小。 请求关键资源需要多少个 RTT（Round Trip Time）。 什么是 RTT 呢？当使用 TCP 协议传输一个文件时，由于 TCP 的特性，这个数据并不是一次传输到服务端的，而是需要拆分成一个个数据包来回多次进行传输的。RTT 就是这里的往返时延。它是网络中一个重要的性能指标，表示从发送端发送数据开始，到发送端收到来自接收的确认，总共经历的时延。通常一个 HTTP 数据包在 14KB 左右，所以一个 0.1M 的页面数据就需要拆分成 8 个包来传输，也就是说需要 8 个 RTT。 我们可以结合上图来看看它的关键资源请求需要多少个 RTT。首先是请求 HTML 资源，大小是 6KB，小于 14KB，所以 1 个 RTT 就可以解决了。至于 JavaScript 和 CSS 文件，这里需要注意一点，由于渲染引擎有一个预解析的线程，在接收到 HTML 数据之后，预解析线程会快速扫描 HTML 数据中的关键资源，一旦扫描到了，会立马发起请求，你可以认为 JavaScript 和 CSS 是同时发起请求的，所以它们的请求是重叠的，那么计算它们的 RTT 时，只需要计算体积最大的那个数据就可以了。这里最大的是 CSS 文件（9KB），所以我们就按照 9KB 来计算，同样由于 9KB 小于 14KB，所以 JavaScript 和 CSS 资源也就可以算成 1 个 RTT。也就是说，上图中关键资源请求共花费了 2 个 RTT。 所以总的优化原则是：减少关键资源个数，降低关键资源大小、降低关键资源的 RTT 次数。 可以将 JavaScript 和 CSS 改成内联的形式，比如上图中的 JavaScript 和 CSS 若都改成内联模式，那么关键资源的个数就从 3 个减少到了 1 个。 如果 JavaScript 代码没有 DOM 或者 CSSOM 的操作，则可以改成 async 或者 defer 属性；同样对于 CSS， 如果不是在构建页面之前加载的，则可以 CSSLink 属性之前添加取消阻止显现的标志。这时它们就变成了非关键资源。 减少关键资源的大小，可以压缩 CSS 和 JavaScript 资源，移除 HTML、CSS、JavaScript 文件中的一些注释内容。 可以使用 CDN 来减少每次 RTT 时长。 在优化实际页面的加载速度时，可以画出优化之前的关键资源的图表，然后按照上面的原则去优化，优化之后再画出优化之后的关键资源图表。 交互阶段在交互阶段，帧的渲染速度决定了交互的流畅程度。因此讨论页面优化实际上就是讨论渲染引擎是如何渲染帧的。 先看交互阶段的渲染流水线（如下图）。和加载阶段的渲染流水线不同的地方是，交互阶段没有加载关键资源和构建 DOM、CCSOM 流程，通常是由 JavaScript 触发交互动画的。 综合上图，在大部分情况下，交互阶段生成一个新的帧都是由 JavaScript 通过修改 DOM 或 CCSOM 来触发的。还有另外一部分是由 CSS 来触发的。 如果在计算样式阶段发现有布局信息的修改，那么就会触发重排操作，然后触发后续一系列操作，这个代价是非常大的。 如果在计算样式阶段没有发现有布局信息的修改，只是修改了颜色一类的信息，那么就不会涉及到布局相关的调整，所以可以直接跳过布局阶段，直接进入绘制阶段，这个过程叫做重绘。不过重绘的代价也不小。 另外一种情况是通过 CSS 实现一些变形、渐变、动画等特效，这是由 CSS 触发的，并且是在合成线程上执行的，这个过程称为合成。因为不会触发重排或重绘，而且合成造作本身速度就非常快，所以执行合成是效率最高的方式。 知道了在交互阶段的帧是如何合成的，就可以讨论优化方案了。一个大的原则是让单个帧的生成速度变快。以下介绍影响帧生成速度的因素，以及优化手段。 减少 JavaScript 脚本执行时间有时 JavaScript 函数的一次执行时间可能有几百毫秒，严重霸占了主线程执行其他渲染任务的时间。针对这种情况我们可以采取以下两种策略： 将一次执行的函数分解为多个任务，使得每次执行的时间不要过久。 采用 Web Workers。把 Web Workers 当作主线程之外的另一个线程，在 Web Worker 中是可以执行 JavaScript 脚本的，不过 Web Workers 中没有 DOM、CSSOM 环境，我们可以把一些和 DOM 操作无关且耗时的任务放到 Web Workers 中去执行。 总之，在交互阶段，对 JavaScript 脚本总的原则是不要一次霸占太久主线程。 避免强制同步布局通过 DOM 接口执行添加元素或者删除元素等操作后，是需要重新计算样式和布局的。正常情况下这些操作都是在另外的任务中异步完成的，这样做是为了避免当前的任务占用太长的主线程时间。 123456789101112131415161718192021&lt;html&gt;&lt;body&gt; &lt;div id=&quot;mian_div&quot;&gt; &lt;li id=&quot;time_li&quot;&gt;time&lt;/li&gt; &lt;li&gt;geekbang&lt;/li&gt; &lt;/div&gt; &lt;p id=&quot;demo&quot;&gt; 强制布局 demo&lt;/p&gt; &lt;button onclick=&quot;foo()&quot;&gt; 添加新元素 &lt;/button&gt; &lt;script&gt; function foo() &#123; let main_div = document.getElementById(&quot;mian_div&quot;) let new_node = document.createElement(&quot;li&quot;) let textnode = document.createTextNode(&quot;time.geekbang&quot;) new_node.appendChild(textnode); document.getElementById(&quot;mian_div&quot;).appendChild(new_node); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 对于上面这段代码，可以使用 Performance 工具来记录添加元素的过程，如下图所示： 从图中看，执行 JavaScript 添加元素是在一个任务中执行的，重新计算布局是在另一个任务中执行，这就是正常情况下的布局操作。 所谓强制同步布局，是指 JavaScript 强制将计算样式和布局操作提前到当前的任务中。为直观理解，对上述代码做一点修改，让它变成强制同步布局： 1234567891011function foo() &#123; let main_div = document.getElementById(&quot;mian_div&quot;) let new_node = document.createElement(&quot;li&quot;) let textnode = document.createTextNode(&quot;time.geekbang&quot;) new_node.appendChild(textnode); document.getElementById(&quot;mian_div&quot;).appendChild(new_node); // 由于要获取到 offsetHeight， // 但是此时的 offsetHeight 还是老的数据， // 所以需要立即执行布局操作 console.log(main_div.offsetHeight)&#125; 这里在获取到 main_div 的高度之前，JavaScript 还需要强制让渲染引擎默认执行一次布局操作。我们把这个操作称为强制同步布局。 上图中可以看到，计算样式和布局都是在当前脚本执行过程中触发的，这就是强制同步布局。 为了避免强制同步布局，我们可调整策略，在修改 DOM 信息之前查询相关值。代码如下： 12345678910function foo() &#123; let main_div = document.getElementById(&quot;mian_div&quot;) // 为了避免强制同步布局，在修改 DOM 之前查询相关值 console.log(main_div.offsetHeight) let new_node = document.createElement(&quot;li&quot;) let textnode = document.createTextNode(&quot;time.geekbang&quot;) new_node.appendChild(textnode); document.getElementById(&quot;mian_div&quot;).appendChild(new_node); &#125; 避免布局抖动布局抖动是比强制同步布局更坏的情况。所谓布局抖动，是指在一次 JavaScript 执行过程中，多次执行强制布局和抖动操作。 1234567891011function foo() &#123; let time_li = document.getElementById(&quot;time_li&quot;) for (let i = 0; i &lt; 100; i++) &#123; let main_div = document.getElementById(&quot;mian_div&quot;) let new_node = document.createElement(&quot;li&quot;) let textnode = document.createTextNode(&quot;time.geekbang&quot;) new_node.appendChild(textnode); new_node.offsetHeight = time_li.offsetHeight; document.getElementById(&quot;mian_div&quot;).appendChild(new_node); &#125;&#125; 上述代码在一个 for 循环语句里不断读取属性值，每次读取属性值之前都要进行计算样式和布局。执行代码之后，使用 Performance 记录的状态如下所示： 避免这种情况的方式也是尽量不要在修改 DOM 结构时再去查询一些相关值。 合理利用 CSS 合成动画合成动画是在合成线程上执行的，这和布局、绘制等在主线程上执行的操作不同，如果主线程被 JavaScript 或者一些布局任务占用，CSS 动画依然能继续执行。所以如果能让 CSS 处理动画，就尽量让 CSS 来操作。 另外，如果能提前知道对哪个元素执行动画操作，那就最好将其标记为 will-change，这是告诉渲染引擎需要将该元素单独生成一个图层。 避免垃圾的频繁回收如果在一些函数中频繁创建临时对象，那么垃圾回收也会频繁地去执行垃圾回收策略。当垃圾回收时会占用主线程，影响其他任务的执行，严重的话还会产生掉帧、不流畅的感觉。 所以要尽量避免产生那些临时垃圾数据——尽可能优化存储结构，避免小颗粒对象的产生。 总结我们主要讲解了如何系统优化加载阶段和交互阶段的页面。 在加载阶段，核心的优化原则是：优化关键资源的加载速度，减少关键资源的个数，降低关键资源的 RTT 次数。 在交互阶段，核心的优化原则是：尽量减少一帧的生成时间。可以通过减少单次 JavaScript 的执行时间、避免强制同步布局、避免布局抖动、尽量采用 CSS 的合成动画、避免频繁的垃圾回收等方式。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【浏览器工作原理】分层与合成机制]]></title>
    <url>%2F2019%2F10%2F07%2F%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%91%E5%88%86%E5%B1%82%E4%B8%8E%E5%90%88%E6%88%90%E6%9C%BA%E5%88%B6%2F</url>
    <content type="text"><![CDATA[为什么 CSS 动画比 JavaScript 高效？ 我们知道，在 DOM 树生成之后，还要经过分层、合成、显示等阶段后才能显示出漂亮的页面。本文主要讲解渲染引擎的分层和合成机制，了解其工作原理，有助于更深刻地理解 CSS 动画和 JavaScript 底层工作机制。 显示器是怎么显示图像的每个显示器的刷新频率固定，一般是 60Hz。更新的图片都来自于显卡中一个叫前缓冲区的地方，显示器每秒固定读取 60 次前缓冲区中的图像，并显示到显示器上。 显卡的职责：合成新的图像，并将其保存到后缓冲区中。 一旦显卡把合成的图像写到后缓冲区，系统就会让前缓冲区和后缓冲区互换，保证前显示器能读取到显卡最新生成的图像。通常情况下，显卡的更新频率和显示器的刷新频率是一致的。但有时候，在一些复杂的场景中，显卡处理一张图片的速度会变慢，这样就会造成视觉上的卡顿。 帧 vs 频率当你通过滚动条滚动页面，或者通过手势缩放页面时，屏幕上就会产生动画的效果。之所以你能感觉到有动画的效果，是因为在滚动或者缩放操作时，渲染引擎会通过渲染流水线生成新的图片，并发送到显卡的后缓冲区。 大多数设备屏幕的更新频率是 60 次 / 秒，这也就意味着正常情况下要实现流畅的动画效果，渲染引擎需要每秒更新 60 张图片到显卡的后缓冲区。我们把渲染流水线生成的每一副图片称为一帧，把渲染流水线每秒更新了多少帧称为帧率，比如滚动过程中 1 秒更新了 60 帧，那么帧率就是 60Hz（或者 60FPS）。 由于用户很容易观察到那些丢失的帧，如果在一次动画过程中，渲染引擎生成某些帧的时间过久，那么用户就会感受到卡顿，这会给用户造成非常不好的印象。要解决卡顿问题，就要解决每帧生成时间过久的问题，为此 Chrome 对浏览器渲染方式做了大量的工作，其中最卓有成效的策略就是引入了分层和合成机制。分层和合成机制代表了当今最先进的渲染技术，所以接下来我们就来分析下什么是合成和渲染技术。 如何生成一帧图像任意一帧的生成方式有三种：重排、重绘、合成。具体看第 6 课：渲染流程（下） 这三种方式的渲染路径是不同的，通常渲染路径越长，生成图像花费的时间就越多。 重排：需要重新根据 CSSOM 和 DOM 来计算布局树，这样生成一幅图片时，会让整个渲染流水线的每个阶段都执行一遍，如果布局复杂的话，就很难保证渲染的效率了。重绘：因为没有了重新布局的阶段，操作效率稍微高点，但是依然需要重新计算绘制信息，并触发绘制操作之后的一系列操作。合成：相较于重排和重绘，合成操作的路径就显得非常短了，并不需要触发布局和绘制两个阶段，如果采用了 GPU，那么合成的效率会非常高。 回答本文开头提出的问题： 对某个元素做几何形状变换、透明度变换或者一些缩放操作，如果使用 JavaScript 来写这些效果，会牵涉到整个渲染流水线，所以 JavaScript 的绘制效率会非常低下。 这时你可以使用 will-change 来告诉渲染引擎你会对该元素做一些特效变换，让引擎为该元素准备独立的层。CSS 代码如下： 123.box &#123;will-change: transform, opacity;&#125; 这段代码就是提前告诉渲染引擎 box 元素将要做几何变换和透明度变换操作，这时候渲染引擎会将该元素单独实现一帧，等这些变换发生时，渲染引擎会通过合成线程直接去处理变换，这些变换并没有涉及到主线程，这样就大大提升了渲染的效率。这也是 CSS 动画比 JavaScript 动画高效的原因。 但是凡事都有两面性，每当渲染引擎为一个元素准备一个独立层的时候，它占用的内存也会大大增加，因为从层树开始，后续每个阶段都会多一个层结构，这些都需要额外的内存，所以你需要恰当地使用 will-change。 本文的焦点在合成上，接下来深入分析下 Chrome 浏览器是怎么实现合成操作的。Chrome 中的合成技术，可以用三个词来概括总结：分层、分块和合成。 分层和合成如果没有采用分层机制，从布局树直接生成目标图片的话，那么每次页面有很小的变化时，都会触发重排或者重绘机制，这种“牵一发而动全身”的绘制策略会严重影响页面的渲染效率。 为了提升每帧的渲染效率，Chrome 引入了分层和合成的机制。你可以把一张网页想象成是由很多个图片叠加在一起的，每个图片就对应一个图层，Chrome 合成器最终将这些图层合成了用于显示页面的图片。将素材分解为多个图层的操作就称为分层，最后将这些图层合并到一起的操作就称为合成。所以，分层和合成通常是一起使用的。 在 Chrome 的渲染流水线中，分层体现在生成布局树之后，渲染引擎会根据布局树的特点将其转换为层树（Layer Tree），层树是渲染流水线后续流程的基础结构。层树中的每个节点都对应着一个图层，下一步的绘制阶段就依赖于层树中的节点。绘制阶段其实并不是真正地绘出图片，而是将绘制指令组合成一个列表。有了绘制列表之后，进入光栅化阶段，就是按照绘制列表中的指令生成图片。每一个图层都对应一张图片，合成线程有了这些图片之后，会将这些图片合成为“一张”图片，并最终将生成的图片发送到后缓冲区。这就是一个大致的分层、合成流程。 需要重点关注的是，合成操作是在合成线程上完成的，这也就意味着在执行合成操作时，是不会影响到主线程执行的。这就是为什么经常主线程卡住了，但是 CSS 动画依然能执行的原因。 分块如果说分层是从宏观上提升了渲染效率，那么分块则是从微观层面提升了渲染效率。 通常情况下，页面的内容都要比屏幕大得多，显示一个页面时，如果等待所有的图层都生成完毕，再进行合成的话，会产生一些不必要的开销，也会让合成图片的时间变得更久。 因此，合成线程会将每个图层分割为大小固定的图块，然后优先绘制靠近视口的图块，这样就可以大大加速页面的显示速度。不过有时候， 即使只绘制那些优先级最高的图块，也要耗费不少的时间，因为涉及到一个很关键的因素——纹理上传，这是因为从计算机内存上传到 GPU 内存的操作会比较慢。 为了解决这个问题，Chrome 又采取了一个策略：在首次合成图块的时候使用一个低分辨率的图片。分辨率减少一半，纹理就减少了四分之三。在首次显示页面内容的时候，将这个低分辨率的图片显示出来，然后合成器继续绘制正常比例的网页内容，当正常比例的网页内容绘制完成后，再替换掉当前显示的低分辨率内容。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[薛兆丰的经济学课第一季度复盘]]></title>
    <url>%2F2019%2F10%2F06%2F%E8%96%9B%E5%85%86%E4%B8%B0%E7%9A%84%E7%BB%8F%E6%B5%8E%E5%AD%A6%E8%AF%BE%E7%AC%AC%E4%B8%80%E5%AD%A3%E5%BA%A6%E5%A4%8D%E7%9B%98%2F</url>
    <content type="text"><![CDATA[目前我的学习进度是完成了一、二季度。其中第一季度的所有课都学了两遍，积累的笔记比较多，故做复盘。准备等把第二季度再复习一遍之后，复盘第二季。 第一季度复盘：人类是如何做出选择的？ 四个概念： 稀缺 成本 需求 价格 四句总结： 凡选择必有歧视 凡竞争必有成本 凡政策必遭对策 凡争夺必有妥协 人性与稀缺经济学视角 战俘营里的经济组织 马粪争夺案 看得见的和看不见的 经济学不关心阴谋论 人的本性 不确定性、进化与经济理论 亚当·斯密的人性观 铅笔的故事 商业是最大的慈善 我们讨论人是不是理性的，要不要把人是理性的当做经济学的基础，我们抛弃了这个基础；我们讨论人是不是自私的，要不要把人是自私的当做经济学的基础，我们也抛弃了这个基础；我们讨论了人是不是追求利益最大化的。我们说，其实人也没有这样的算计，人们最终要追求的，只不过是在不确定的情况下的存活。树叶很可能是没有理性的，但不管树叶有没有理性，我们关心的只是一个规律，就是朝阳光的地方树叶长得茂盛，背着阳光的地方树叶长得稀松。这是我们经济学关心的问题。 经济学不关心个体的决策，只关心整体现象背后的规律。量子解释：经济学本身不受个人主观意志的影响，但是当个体意志的数量足够多之后，就会有统计上的规律，这就是经济学的规律。进化论解释：存在即合理。人是否理性、市场是否有效、价格是否可以预测，我们不知道，我们只知道那些适应市场的幸存者们最终呈现出的样子。 所以，亚当·斯密非常睿智的看到了这一点：我们终我们的一生，花一辈子的时间，都很难赢得和维持几个人对我们的友情和爱情，但我们无时不刻需要成千上万人的帮助。我们看看自己吃的穿的住的，有多少人涉及其中，有多少人在帮助我们，但他们都不爱我们，他们都不认识我们。这怎么办？这么大的一个空隙怎么填补？答案就是市场。市场是一个陌生人跟陌生人之间打交道的地方，是一个陌生人服务陌生人的地方。 亚当斯密并不认为人完全是自私的，只是人的爱非常有限。 稀缺与选择 稀缺 选择和歧视 凡歧视必得付代价 歧视的作用和限制歧视的恶果 我们把稀缺当做经济学最坚实的一个基础。因为稀缺不是一个假设，而是一个基本事实。凡是有稀缺就有选择，而有选择必有标准，必有歧视，接着我们讨论了歧视的合理性问题及反歧视的后果。 歧视不可避免，它与稀缺、选择是一体的，而稀缺是一个基本事实。 人们经常以偏概全做判断，那是不得已，因为信息费用很高。以偏概全作判断当然会发生错误。但是跟他要付出的成本相比，还是值得的。 歧视起源1：偏好不同。歧视起源2：信息不对称，信息代价高，导致以偏概全。 竞争越激烈，人们需要的信息越多，无知所付出的代价越大。所以竞争激烈 → 少歧视 很少有人明白，其实（08年金融危机）真正的原因，是政府强迫商业银行改变区别对待贷款申请人的标准造成的。这不是市场失败，而是政府失败。 颠覆了我的认知。歧视有时候是必要的，是合理的。 第一单元总结：经济学的基础建立在事实而非假设之上。这个事实就是“稀缺”。 成本 一句话定义：成本就是放弃了的最大代价。 你的成本由别人决定（由社会上所有其他人共同决定） 别只盯着钱（不止有价格成本） 沉没成本不是成本 理解盈利与亏损 最终产品的供需决定原材料的成本 “租”是对资产的付费 寻租 这块地有两种竞争性的用途：要么拿来做采石场，要么拿来做居民区。最终哪一种用途能够获胜，则取决于这两种用途的使用者，谁的出价更高。这两种用途，我们现在说是两种人，一种是参观博物馆的人，一种是要住房子的居民。他们可以是两拨人。但其实，他们也有可能是同一个人，一个人可以同时有两种需求，他要在这两种需求中做一个权衡，做一个取舍。这时候成本的概念就自然而然地出来了：成本就是放弃了的最大代价。 成本的源头是选择。凡稀缺必有选择，（凡选择必有歧视，）这就回到了经济学的基础上。 成本是什么？成本是放弃了的最大代价。我坚持用这个铺位来卖茶叶蛋，成本是放弃了的其他可能性。这个铺位如果租给别人，我能赚很多很多钱，那么我坚持卖茶叶蛋，放弃了的就是把这个铺位租出去所能赚到的铺租。铺租是谁决定的？不是我们家决定的，是社会上所有其他人共同决定的，是他们的看法决定了长安街上这个位置的铺租值多少钱，所以是社会上其他的人决定了我坚持卖茶叶蛋的成本。他们看法的改变会影响我卖茶叶蛋的成本。 成本由社会决定。 我们不仅仅要看到货币成本，不仅仅要看到钱，还要看到钱以外的其他成本。比如，时间成本、更高风险的成本。做决策的时候，我们要权衡的是全部成本，而不仅仅是货币成本。为什么给士兵发薪比免费征兵更便宜？看透“成本是放弃了的最大收益（或者代价，这不单单是钱）”是关键。 有选择就有成本，没有选择就没有成本。当我们没办法再做选择的时候，就不存在成本，这是“沉没成本不是成本”这句话的含义。 沉没成本是如何影响决策的呢？比如一件事完成后收益为200，执行方案1完成的成本为100，已经干了80％进度，因为沉没成本不是成本，所以剩下的成本只有20。突然发现有更好的方案2，收益不变，执行起来的成本只有50。然而因为方案1此时只剩20的成本，故还是采取方案1。除非有方案3，成本小于20，才会考虑放弃方案1。当然，如果发现有另一件事，收益远超200，是500，而执行成本有150，那还是当断则断，放弃沉没成本，把资源转而投入第二件事吧。总之，影响决策的是当下时间点，投资的回报率。也就是单位成本的收益多少。如果再加入概率和时间因素的话，就很复杂了。 租就是对资产的付费，这里所说的资产含义非常广，包括土地、矿山、人的才能、发明创造，甚至是特权，只要能够带来收入的就叫资产，而对资产的付费就叫租。 我们要区分两种不同的行为。一种是，比方说一个医生花很多时间去研制一种治疗癌症的药物，或者歌星迈克尔·杰克逊（ Michael Jackson ）花很多时间去研究他的舞姿，让观众得到更高的娱乐享受；而另外一种活动，是那些利益团体想方设法，怎么去获得政府特殊的优惠政策。这两种活动，表面上看都是在努力工作，都是在积极进取，但他们实际上对社会财富有不同的意义。前者对社会财富有正的贡献，而后者，是在消耗社会的财富。从此在经济学界，“寻租”这个词就专门用来指那些向政府争取优惠政策，让自己得到好处，而社会总的资源会发生耗散的行为。 我在想，以应试为导向的教育体制某种程度上也助长了寻租——小孩花在训练考试技巧上面的精力很多，花在提升综合素质上面的精力就少了。而他们之中的很多人，并不会在以后的人生中用到中学所学的绝大多数应试知识。这不也是社会资源的耗散吗？但是进一步推演，如果改为以“素质”教育为导向，只不过是统一改换了大学的录取标准，寻租活动仍然会发生，只不过换成了比拼“素质”的形式。 科斯定律与交易费用科斯定律 社会成本问题：伤害与被伤害 社会成本问题：值得与不值得 谁用的好就归谁 越富足越健康 具体内容很多，有个简短的相关视频。 交易费用 有人群就有交易费用 征地的权衡 寻求合作解 成本概念的递进 在开始讲社会成本的时候，我们讲过123（123思考法）的概念，我们怎么理解社会成本呢？最好的办法，是先把所有的纠纷、所有的冲突，看成是一个主人，然后变成两个主人。一个主人的时候他会怎么处理，也就是说交易费用为零的时候会怎么处理，这是一个参照系。然后我们引入交易费用，我们说有两个人的情况下，存在交易费用的时候，情况会怎么样？还有一种情况，是三个人，我们把整个社会都引进来，情况就会更复杂。当然这也更贴近我们的现实。机场的例子就是这样。 第一，上个单元说的科斯定律：“资源不管谁拥有，它最终都会落到使用价值最高的人手上。”那是一种理想状态，跟我们的现实生活有很大差距。现实生活中到处都有交易费用。第二，恰恰由于到处都有交易费用，所以制度、风俗、习惯就变得非常重要，因为它们是所有权利和责任的初始界定。 现实中，交易费用可能高不可攀，以至于资源无法达到最优配置。然而，老师不承认这是“市场的失败”，而说是“造物主的失败”。但我认为，总之这就是市场失灵。 需求 个人主义的主观价值论（微妙的个人估值论） 边际革命（边际就是新增的新增） 需求第一定律：价格提高，商品的需求量就减少；价格降到一定的程度，需求量就会增加。 需求第二定律：随着时间的推移，需求对价格的弹性会增加。 需求第三定律：附加费越高，高品质的商品相对低品质的商品，就会变得越便宜。 这时候水带给我们的边际收益怎么样？在下降，下降到一定程度，假设说到第一千个铜板的时候，边际上带给我们的收益已经相当低了。这时候，我们会动一个念头，说第一千零一个铜板，咱们能不能换一个花样，买一点点钻石？那一个铜板给我们买来的一点点的钻石，能够很好地满足我们的虚荣心。于是咱们就把第一千零一个铜板用来买钻石。也就是说，在边际上你们家的水和你们家的钻石，给你带来的幸福是一样的。 边际效用，影响决策的是这个。这是解答水和钻石问题的关键。 在讲成本的时候，我们说原材料的价格由需求决定，意思是说，社会的整体需求，决定商品的价格，比如说房价，比方说钻石的价格。有消费者争抢最终消费品，其原材料才有价。这是整个社会里每个人对原材料价格的作用。而与此对照，当商人给最终商品标价后，价格又决定每一个人的需求曲线上的需求量。请注意区分需求和需求量这两个概念。 社会供需决定价格。然后，在需求不变的前提下，价格决定需求量。 整条曲线是需求，需求曲线。曲线上点的横坐标，才是需求量（而且是因变量）。需求受很多因素的影响，因此需求曲线经常变动。而需求量则是随着价格变化，在需求曲线上滑动。 一条倾斜向下的需求曲线，当它价格比较高的部分，它的弹性是大于1的；它的价格比较低的部分，它的弹性是小于1的。而每一点的弹性都是不一样的，是在渐变的。 需求的价格弹性 = (y/x) * |k| 需求对价格的弹性，就是需求量的变化百分比，除以价格变化的百分比。它的含义是说：每当价格变化百分之一，需求量会变化百分之几。你看看我给你准备的下图的公式就非常清楚了。 需求的价格弹性 之 定义。弹性越小，越是必需品。 为了保住冰箱里的食物，你愿意花300块钱，但你实际上每天所付的电费也就是一两块钱。这一两块钱跟300块钱之间的差距叫剩余。所以我们在日常生活当中，消费各种各样的商品所享受到的剩余是巨大的。同样，生产者和商品的提供者，他们也享受很大的剩余。 这就是“交易剩余”，经济学里叫“消费者剩余”。 价格与价格管制 经济计算问题 知识在社会中的运用 如何分饼决定饼做多大 换个角度看发国难财的行为 各种竞争规则 短缺和过剩：均源于价格管制 春运火车价还不够高 美国的房租管制 解除价格管制——果断与沉稳的拿捏 实物补贴和货物补贴的权衡 价格的三个作用： 传递关于稀缺的信号； 指导生产； 做出奖惩，或者说指导人们对商品的分配。 在所有的竞争规则当中，没有任何一个规则是比别的规则更公平的，不同的人站在不同的立场就有不同的偏好，不同的选择；不论你选择哪一种竞争方式，人们都会按照这种竞争方式去竞争，而竞争本身就会耗费资源；在竞争过程当中所损耗的资源，通常都是一种无谓的损失。也就是说，对竞争者本身，对那些赢家来说，这是值得付出的代价，但是对社会其他人来说，他们从中得不到好处；用出价的办法来竞争的话，有一个特点，跟其他的竞争方式不一样，那就是每当人们为了赚更多的钱，从而在出价的过程当中胜出的时候，人们不得不向社会其他人提供他们所需要的产品。这时候，整个社会因为竞争带来的不是无谓的损失，而是更多的财富。 价格的三个作用当中，第三个（指导产品的分配）最重要。没有公平的竞争规则，但是“价高者得”是最有效的竞争方式。因为这种方式所导致的无谓损失（因为竞争而产生的资源耗散）最低。所以，用出价的办法来竞争是最有效的。 稀缺是永恒的，而短缺和过剩都是价格受到人为干预的结果。当价格过低的时候，人们不得不展开价格以外的竞争方式，来争夺他们需要的商品，这时候就会出现短缺。而当价格被人为拔高以后，卖家就不得不采用价格以外的方式，才能把东西卖出去，这时候就会出现所谓的过剩现象。 价格被干预，失去调解供需的作用，就会造成短缺或过剩。 价格的教益 房价上升好不好 廉价保障房更贵 没有“使用需求”就没有“投资需求” 价格是高度分权的结果 从亚当·斯密到欧文·费雪，半个世纪的经济学成就，就是建立了一个高度分权的抽象模型，其中没有任何人可以控制价格或其他重要的市场指标。薛兆丰觉得，这句话概括了经济学发展150多年最基本的教训。]]></content>
      <categories>
        <category>跬步之积</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>得到</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《追时间的人》读书（纸质书）笔记]]></title>
    <url>%2F2019%2F10%2F01%2F%E3%80%8A%E8%BF%BD%E6%97%B6%E9%97%B4%E7%9A%84%E4%BA%BA%E3%80%8B%E8%AF%BB%E4%B9%A6%EF%BC%88%E7%BA%B8%E8%B4%A8%E4%B9%A6%EF%BC%89%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[（未完成） 我与这本书的缘分从 XTecher 到郝景芳，再到开智16 年暑假，我结束了大三，在学校准备年底的研究生考试。当时除了复习之外，没有什么其他事情，但是一天的时间都用来复习是实在无法忍受的，所以我除了下午最热的时候会去健身房蹭蹭空调再洗个澡之外，大约有一半的时间都在上网浏览网页、在 QQ 群高谈阔论、在微信浏览订阅号文章。 当时经常看的一个订阅号叫做“XTecher”（现在改成“甲子光年”了），上边的文章都写得又长又硬，加上我本来就看得仔细，所以一篇文章能看上一个小时。某天突然见到一篇人物特稿，介绍一个叫郝景芳的人。看完之后，扫码加群，等待起晚上的粉丝交流会。 群里，我慢慢翻看了郝景芳的 10 条朋友圈，还关注了她分享的公众号，其中之一是“开智学堂”。我注意到，“开智学堂”那篇分享里有郝景芳与另外几位嘉宾的质量极高的对话记录，就下载到电脑上看了一遍。 粉丝交流会上将抽取两位群友，赠送郝景芳亲笔签名的著作。可能是因为我发言活跃而且发言的质量较高，有两三个群友加了我好友。其中一个问我：你北大的？我答：不是。对方又问：清华的？我答：不是……普通211……当时我还把这个聊天记录截图发给某好友看，心里的兴奋劲立马被该好友戳穿了。 那个暑假，我收到了郝景芳赠书《生于1984》，难得地看了一本纸质书，还写了一篇类似读后感的东西，发布在自己的个人订阅号“人间的我”，而且文章主题和“人间的我”还有点契合。 开智社群的开智文库之《追时间的人》关注了“开智学堂”以后，我时常浏览它推送的文章，大多数的质量都不错，而且长度适中，阅读不算困难。 我发现，开智学堂除了提供价格不菲的高强度课程以外，它的背后还有一个叫“开智社群”的高质量线上组织，是阳志平组织的。郝景芳、魏坤琳、陈虎平、李笑来、陈海贤、采铜这些平时只在书的作者栏或者电视节目上才能看见的大佬们，都是开智社群的成员。 这个社群之前组织过多次线上讨论会和线下演讲活动，基本上都是些实在有用的话题（因为本身就都是同一时间段的人嘛）。 线上讨论的精华内容，后来编撰成了《追时间的人》这本书；线下演讲的内容，后来编撰成了《认知尺度》这本书。这些书和《生于1984》一样，都是“开智文库”出版的。 当时我就对《追时间的人》中“时间源头”概念深以为然，不过里面的很多经典文章，都已经在公众号上阅读过了，所以也没什么想要买书的冲动，直到读研一的时候才用科研经费买了这本书。买来之后，翻了感兴趣的几章，也没有全部都看。 直到2019年的国庆长假期间，我应经快要研究生毕业了，才想起重读这本书，并且摘录一些读书笔记。 序言 | 追时间的人未来已经来临，只是分布不均；信息不再饥渴，而是已经过载。学如逆水行舟，但信息汪洋，怎能乘独木舟？因此，你需要用信任来过滤信息，站在时间源头，看潺潺溪流，肆意大海。 …… 序言全文链接 2015年2月2日 思维模式与积极教养刘建鸿：当你认为世界一成不变，智力不可提升，那么你可能一成不变。当你认为智力可以提升，思维模式能够改变，那么你可能拥有更大的世界。 思维模式（mindset）是指一个人看待自己（能力/人际关系/个性）的方式，例如，你认为智力是固定不变的还是可以成长的。这些日常生活中隐藏的思维模式会极大地影响我们的态度和行为方式。 什么是思维模式它是你看世界的“眼镜”。 僵固型思维模式（fixed mindset）——成长型思维模式（growth mindset）认为能力是固定的，认为努力和能力成反比——认为努力是激活能力的必要手段，付出的能力越多，能力的提高也越多每个人都可能同时这两方面的思维模式。德韦克认为，人在学习、人际、情绪三个领域的思维模式可能会有所不同。比如，我在学习领域容易采取成长型思维模式，但在交友领域则不然。 成长型思维模式比单纯强调积累的看法（如愚公移山、精卫填海）要更乐观。成长过程中，自身能力应该也有发展。 僵固型思维对人的最大影响：受挫力差。 德韦克《看见成长的自己》中提出了一些可供评估的描述。对于同龄人的看法，也是一个判断依据：无论是他比你优秀，还是稍逊与你，你是否能看到他们的积累和努力？ 刘建鸿认为，思维模式主要还是后天培养的。改变思维模式可能是渐进的，也有可能因为特殊事件而改变。（想到我自己高中时，在学习方面的思维模式就有了一些转变。） 培养孩子的成长型思维模式情绪调节：接纳孩子的真实感受（比如嫉妒、羞愧）。先接纳、承认、理解，而不是否定或不允许，再鼓励他成长、进步、超越自己。 区分鼓励与表扬——认清谁是主体。表扬的时候，主体其实是父母、老师，他们是否满意；鼓励的时候，主体则是孩子。表扬是评价性的；鼓励是描述性的，更具体。 不少小孩认为自己是在为父母读书，因为这些父母经常会对孩子说：你成绩考得好，是我们的骄傲；你考不好，真让我们丢脸。应该让孩子知道：读书是为了自己。你考得好，开心、骄傲的是自己，父母只会替你高兴；考不好，不开心、难过的还是自己，我们只会替你难过，并给予你可能的帮助。 一般家长总是向孩子强调“我要奖励你什么”，李晓文老师家却是女儿来请父母吃饭。 高级鼓励技巧：深描。比如，培养孩子做家务，如何鼓励？要让孩子有成就感，体会到成长，多方面、多角度鼓励。描述后续影响，而不带夸大赞赏，让孩子体会真实的成就感。其实主体还是孩子。 推荐家长更多让孩子自我评价，鼓励孩子自我评价。让孩子给自己做记录，比如记下学习英语 CD 的次数、给弹钢琴录音。自评的方法也适用于成人。 给孩子提供丰富的资源，比如英文原版书或动画片、手耳互动的游戏。意外收获：为什么读书有效？读好书有效？其实它提供了丰富性与多样性。你看到太多成功人士的故事。 语录和荐书语录： 打骂永远不能让孩子明白什么是正确的行为。如果孩子听你的话，只是因为他想着如何避免挨打，而不是因为他明白“什么是真正正确和对他有利的”，只会适得其反。 男孩和女孩都应该是精神上富养，物质上根据自身的条件适当满足。物质上的过度满足很容易造成孩子的物质主义，非名牌美食不能满足，如果自身能力不足，将来的生活幸福感可能更低。 成人当然也需要成长。举个简单的例子，夫妻俩开始“志同道合”，后来如果事业、见识的差距越拉越大，则常常难以维持。既然变化不可避免，那么共同成长就是更健康的相处之道，某种程度上也是一种“需要”。 荐书： 《专念：积极心理学的力量》（Mindefulness） 《成功，目标与动机》（Success: How We Can Reach Our Goals）你会发现平时听到的太多建议都是显而易见且无用的——保持积极心态，制定计划，行动起来，做到最好……作者解释了人类动机的基本理论。 《看见成长的自己》（Mindset: The New Psychology of Success） 人类的择偶权衡吴宝沛：你的时间和精力都非常有限，当你在一个选项中投入越多，就意味着在另一个选项中投入得少。择偶同样如此，是在长相、性格与资源三者中权衡，其中，性格为王。 权衡，就是在不同的选项上分配自己的时间、精力和资源。你拿来投资的时间、精力和资源都是有限的。既然有限，就意味着要根据自身的条件，进行投资组合。存在择偶权衡的前提是：资源稀缺（时间、精力和资源），任务多样（三大任务是生存、发展和繁殖），选择具有多效性（同一选择对于不同任务的影响不同，比如选择现在繁殖，就可能影响自身生存和发展）。 社会心理学家弗莱彻对择偶偏好的研究：他将择偶偏好归结为对三大因素的偏好——长相、性格和资源。其中，性格为王；男女在资源和长相的权衡上有所差异。12345678if 长相相同或资源相同: 性格 &gt; 资源 性格 &gt; 长相elseif 性格相同: if 性别 = 男: 长相 = 资源 if 性别 = 女： 资源 &gt; 长相 诺曼·李认为，有必要区分择偶偏好中的必需品和奢侈品。（必需品在资源较少时的投资比重较大，而资源较多时的投资比重较小；奢侈品的特点恰好相反。）他发现，女人的外表和智力被男人视作必需品，而男人的薪水和智力也被女人视作必需品。 权衡跟真爱其实不矛盾。权衡更多是一个无意识的过程，有意识也可以。你必须清楚对方哪些优点你在乎，必须有；哪些优点你虽然在乎，但是可有可无。 人类喜欢随大流，连找对象也不例外。这被称为“抄袭式择偶”（mate copying）。李·杜盖金拿孔雀鱼做过一个经典实验。许多发现都暗示，拥有一个气质迷人的伴侣，就能提高自己在异性心目中的魅力。 此外还提到：长期和短期择偶策略、男女友情（线人这个观点有意思，解释了为什么很多女性和弯男是好朋友）……自由谈的内容也很丰富，但是结构太散了。 语录： 真正的认可，或许会迟到，但从不缺席。时间是一个公正无私的裁判。 每个人都有自己未曾发现的才干。他至少需要打败惯性和惰性这两个敌人，才可能从他们嘴里打听到才干的下落。 做事不认真的人，就是在出卖自己。 很难对自己写的文字满意，这不是病，是清醒。 在这个世界上，很多流行的东西都不是真理。这是一个严酷的现实：很多似是而非的理论都能劫持我们的大脑。 最好的修炼，是当下的修炼；最好的归隐，是尘世的归隐。有梦，有爱，才完整。 “二”是一种很难伪装的品质，他是一个人天赋异禀的自然流露。 荐书： 《猿猴的把戏》达里奥·马埃斯特里皮埃里著，吴宝沛译； 《看不见的影响力》讲群体影响； 《亲密关系》看过了； 《论人性》（Psychology on Human Nature）考察了人类行为的进化论解释。]]></content>
      <categories>
        <category>书中所得</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【浏览器工作原理】CSS 如何影响首次加载时的白屏时间？]]></title>
    <url>%2F2019%2F09%2F30%2F%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%91CSS-%E5%A6%82%E4%BD%95%E5%BD%B1%E5%93%8D%E9%A6%96%E6%AC%A1%E5%8A%A0%E8%BD%BD%E6%97%B6%E7%9A%84%E7%99%BD%E5%B1%8F%E6%97%B6%E9%97%B4%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[上一篇《JavaScript 对构建 DOM 树的影响》介绍了 DOM 的生成过程，并分析了 JavaScript 是如何阻塞 DOM 生成的。 本文继续聊渲染流水线中的 CSS。首先站在渲染流水线的视角来介绍 CSS 是如何工作的，然后通过 CSS 的工作流程来分析性能瓶颈，最后再来讨论如何减少首次加载时的白屏时间。 渲染流水线视角下的 CSS先看最简单的渲染流程12345//theme.cssdiv&#123; color : coral; background-color:black&#125; 12345678&lt;html&gt;&lt;head&gt; &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;geekbang com&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 首先是发起主页面的请求，这个发起请求方可能是渲染进程，也有可能是浏览器进程，发起的请求被送到网络进程中去执行。网络进程接收到返回的 HTML 数据之后，将其发送给渲染进程，渲染进程会解析 HTML 数据并构建 DOM。这里你需要特别注意下，请求 HTML 数据和构建 DOM 中间有一段空闲时间，这个空闲时间有可能成为页面渲染的瓶颈。 上一篇文章提到过，当渲染进程接收 HTML 文件字节流时，会开启一个预解析线程，如果遇到 JavaScript 文件或者 CSS 文件，那么预解析进程会提前下载这些数据。对于上面的代码，预解析线程会解析出来一个外部的 theme.css 文件，并发起 theme.css 的下载。这里也有一个空闲时间需要你注意一下，就是在 DOM 构建结束之后、theme.css 文件还未下载完成的这段时间内，渲染流水线无事可做，因为下一步是合成布局树，而合成布局树需要 CSSOM 和 DOM，所以这里需要等待 CSS 加载结束并解析成 CSSOM。 渲染流水线为什么需要 CCSOM 呢？ 和 HTML 一样，渲染流水线也是无法直接理解 CSS 文件的内容的，所以须要将其解析成浏览器能够理解的结构，这个结构就是 CSSOM。和 DOM 一样，CSSOM 也有两个作用，第一个是提供给 JavaScript 操作样式表的能力，第二个是为布局树的合成提供基础的样式信息。这个 CCSOM 体现在 DOM 中就是 document.styleSheets。 有了 DOM 和 CSSOM，接下来就可以合成布局树了。布局树的结构基本上就是复制 DOM 树的结构，不同之处在于 DOM 树中那些不需要显示的元素会被过滤掉，如 display:none 属性的元素、head 标签、script 标签等。复制好基本的布局树结构之后，渲染引擎会为对应的 DOM 元素选择对应的样式信息，这个过程就是样式计算。样式计算完成之后，渲染引擎还需要计算布局树中每个元素对应的几何位置，这个过程就是计算布局。通过样式计算和计算布局就完成了最终布局树的构建。再之后，就该进行后续的绘制操作了。 以上就是在渲染过程中涉及到 CSS 的一些主要流程。 再看稍微复杂一点的场景在 body 标签的内部加了一个简单的 JavaScript： 12345//theme.cssdiv&#123; color : coral; background-color:black&#125; 123456789101112&lt;html&gt;&lt;head&gt; &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;geekbang com&lt;/div&gt; &lt;script&gt; console.log(&apos;time.geekbang.org&apos;) &lt;/script&gt; &lt;div&gt;geekbang com&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 在解析 DOM 的过程中，如果遇到了 JavaScript 脚本，那么需要先暂停 DOM 解析去执行 JavaScript，因为 JavaScript 有可能会修改当前状态下的 DOM。 不过在执行 JavaScript 脚本之前，如果页面中包含了外部 CSS 文件的引用，或者通过 style 标签内置了 CSS 内容，那么渲染引擎还需要将这些内容转换为 CSSOM，因为 JavaScript 有修改 CSSOM 的能力，所以在执行 JavaScript 之前，还需要依赖 CSSOM。也就是说 CSS 在部分情况下也会阻塞 DOM 的生成。 再看更加复杂一点的情况如果在 body 中被包含的是 JavaScript 外部引用文件，Demo 代码如下所示： 12345//theme.cssdiv&#123; color : coral; background-color:black&#125; 12//foo.jsconsole.log(&apos;time.geekbang.org&apos;) 12345678910&lt;html&gt;&lt;head&gt; &lt;link href=&quot;theme.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div&gt;geekbang com&lt;/div&gt; &lt;script src=&apos;foo.js&apos;&gt;&lt;/script&gt; &lt;div&gt;geekbang com&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 从图中可以看出来，在接收到 HTML 数据之后的预解析过程中，HTML 预解析器识别出来了有 CSS 文件和 JavaScript 文件需要下载，然后就同时发起这两个文件的下载请求，需要注意的是，这两个文件的下载过程是重叠的，所以下载时间按照最久的那个文件来算。 后面的流水线就和前面是一样的了，不管 CSS 文件和 JavaScript 文件谁先到达，都要先等到 CSS 文件下载完成并生成 CSSOM，然后再执行 JavaScript 脚本，最后再继续构建 DOM，构建布局树，绘制页面。 影响页面展示的因素以及优化策略渲染流水线影响了首次页面展示的速度，而首次页面展示的速度又直接影响到了用户体验。所以，我们分析渲染流水线的目的就是为了找出一些影响到首屏展示的因素，再基于这些因素做一些针对性的调整。 那么接下来我们就来看看从发起 URL 请求开始，到首次显示页面的内容，在视觉上经历的三个阶段： 第一个阶段，等请求发出去之后，到提交数据阶段，这时页面展示出来的还是之前页面的内容。关于提交数据，可以参考导航流程那篇文章。 第二个阶段，提交数据之后渲染进程会创建一个空白页面，我们通常把这段时间称为解析白屏，并等待 CSS 文件和 JavaScript 文件的加载完成，生成 CSSOM 和 DOM，然后合成布局树，最后还要经过一系列的步骤准备首次渲染。 第三个阶段，等首次渲染完成之后，就开始进入完整页面的生成阶段了，然后页面会一点点被绘制出来。 现在我们重点关注第二个阶段，这个阶段的主要问题是白屏时间，如果白屏时间过久，就会影响到用户体验。为了缩短白屏时间，我们来挨个分析这个阶段的主要任务，包括了解析 HTML、下载 CSS、下载 JavaScript、生成 CSSOM、执行 JavaScript、生成布局树、绘制页面一系列操作。 通常情况下的瓶颈主要体现在下载 CSS 文件、下载 JavaScript 文件和执行 JavaScript。 所以要想缩短白屏时长，可以有以下策略： 通过内联 JavaScript、内联 CSS 来移除这两种类型的文件下载，这样获取到 HTML 文件之后就可以直接开始渲染流程了。 但并不是所有的场合都适合内联，那么还可以尽量减少文件大小，比如通过 webpack 等工具移除一些不必要的注释，并压缩 JavaScript 文件。 还可以将一些不需要在解析 HTML 阶段使用的 JavaScript 标记上 sync 或者 defer。 对于大的 CSS 文件，可以通过媒体查询属性，将其拆分为多个不同用途的 CSS 文件，这样只有在特定的场景下才会加载特定的 CSS 文件。 通过以上策略就能缩短白屏展示的时长了，不过在实际项目中，总是存在各种各样的情况，这些策略并不能随心所欲地去引用，所以还需要结合实际情况来调整最佳方案。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 对构建 DOM 树的影响]]></title>
    <url>%2F2019%2F09%2F29%2FJavaScript-%E5%AF%B9%E6%9E%84%E5%BB%BA-DOM-%E6%A0%91%E7%9A%84%E5%BD%B1%E5%93%8D%2F</url>
    <content type="text"><![CDATA[DOM 提供了对 HTML 文档结构化的表述。在渲染引擎中，DOM 有三个层面的作用： 从页面的视角来看，DOM 是生成页面的基础数据结构。 从 JavaScript 脚本视角来看，DOM 提供给 JavaScript 脚本操作的接口，通过这套接口，JavaScript 可以对 DOM 结构进行访问，从而改变文档的结构、样式和内容。 从安全视角来看，DOM 是一道安全防护线，一些不安全的内容在 DOM 解析阶段就被拒之门外了。 简言之，DOM 是表述 HTML 的内部数据结构，它会将 Web 页面和 JavaScript 脚本连接起来，并过滤一些不安全的内容。 DOM 树如何生成在渲染引擎内部，有一个叫做 HTML 解析器（HTMLParser）的模块，负责将 HTML 字节流转换为 DOM 结构。 HTML 解析器并不是等整个文档加载完成之后才开始解析的，而是网络进程加载了多少数据，HTML 解析器便解析多少数据。 网络进程接收到响应头之后，会根据响应头中的 content-type 字段来判断文件的类型，比如 content-type 的值是“text/html”，那么浏览器就会判断这是一个 HTML 类型的文件，然后为该请求选择或者创建一个渲染进程。 渲染进程准备好之后，网络进程和渲染进程之间会建立一个共享数据的管道，网络进程接收到数据后就往这个管道里面放，而渲染进程则从管道的另外一端不断地读取数据，并同时将读取的数据“喂”给 HTML 解析器。你可以把这个管道想象成一个“水管”，网络进程接收到的字节流像水一样倒进这个“水管”，而“水管”的另外一端是渲染进程的 HTML 解析器，它会动态接收字节流，并对其进行解析。 字节流 Bytes —&gt; 分词器 Tokens —&gt; 生成结点 Node，并将结点添加到 DOM 树中。 HTML 解析器维护了一个 Token 栈结构，该 Token 栈主要用来计算节点之间的父子关系，在第一个阶段中生成的 Token 会被按照顺序压到这个栈中。具体的处理规则如下所示： 如果压入到栈中的是StartTag Token，HTML 解析器会为该 Token 创建一个 DOM 节点，然后将该节点加入到 DOM 树中，它的父节点就是栈中相邻的那个元素生成的节点。 如果分词器解析出来是文本 Token，那么会生成一个文本节点，然后将该节点加入到 DOM 树中，文本 Token 是不需要压入到栈中，它的父节点就是当前栈顶 Token 所对应的 DOM 节点。 如果分词器解析出来的是EndTag Token，比如是 EndTag div，HTML 解析器会查看 Token 栈顶的元素是否是 StartTag div，如果是，就将 StartTag div 从栈中弹出，表示该 div 元素解析完成。 通过分词器产生的新 Token 就这样不停地压栈和出栈，整个解析过程就这样一直持续下去，直到分词器将所有字节流分词完成。 （补充：HTML 解析器开始工作时，会默认创建一个根为 document 的空 DOM 结构，同时将一个 startTag document 的 Token 压入栈底。） JavaScript 是如何影响 DOM 生成的&lt;script&gt;标签之前，所有的解析流程还是和之前介绍的一样，但是解析到&lt;script&gt;标签时，渲染引擎判断这是一段脚本，此时 HTML 解析器就会暂停 DOM 的解析，让 JavaScript 引擎介入执行&lt;script&gt;标签内的脚本。 除了在页面内直接内嵌 JavaScript 脚本之外，我们通常还需要在页面中引入 JavaScript 文件，这个解析过程就稍微复杂了些。这时，解析到 JavaScript 标签时，需要先下载 JavaScript 代码，这个下载过程会阻塞 DOM 解析，而且通常下载是非常耗时的。 不过 Chrome 浏览器做了很多优化，其中一个主要的优化是预解析操作——当渲染引擎收到字节流之后，会开启一个预解析线程，用来分析 HTML 文件中包含的 JavaScript、CSS 等相关文件，解析到相关文件之后，预解析线程会提前下载这些文件。 再回到 DOM 解析上，我们知道引入 JavaScript 线程会阻塞 DOM，不过也有一些相关的策略来规避，比如使用 CDN 来加速 JavaScript 文件的加载，压缩 JavaScript 文件的体积。 另外，如果 JavaScript 文件中没有操作 DOM 相关代码，就可以将该 JavaScript 脚本设置为异步加载，通过 async 或 defer 来标记代码。（async 和 defer 虽然都是异步的，不过还有一些差异，使用 async 标志的脚本文件一旦加载完成，会立即执行；而使用了 defer 标记的脚本文件，需要在 DOMContentLoaded 事件之前执行。） CSS 会阻塞 JavaScript 解析12//theme.cssdiv &#123;color:blue&#125; 1234567891011121314&lt;html&gt; &lt;head&gt; &lt;style src=&apos;theme.css&apos;&gt;&lt;/style&gt; &lt;/head&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;script&gt; let div1 = document.getElementsByTagName(&apos;div&apos;)[0] div1.innerText = &apos;time.geekbang&apos; // 需要 DOM div1.style.color = &apos;red&apos; // 需要 CSSOM &lt;/script&gt; &lt;div&gt;test&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 该示例中，JavaScript 代码出现了 div1.style.color = &#39;red&#39; 的语句，它是用来操纵 CSSOM 的，所以在执行 JavaScript 之前，需要先解析 JavaScript 语句之上所有的 CSS 样式。所以如果代码里引用了外部的 CSS 文件，那么在执行 JavaScript 之前，还需要等待外部的 CSS 文件下载完成，并解析生成 CSSOM 对象之后，才能执行 JavaScript 脚本。 而 JavaScript 引擎在解析 JavaScript 之前，是不知道 JavaScript 是否操纵了 CSSOM 的，所以渲染引擎在遇到 JavaScript 脚本时，不管该脚本是否操纵了 CSSOM，都会执行 CSS 文件下载，解析操作，再执行 JavaScript 脚本。 所以说 JavaScript 脚本是依赖样式表的，这又多了一个阻塞过程。至于如何优化，我们在下篇文章中再来深入探讨。 通过上面的分析，我们知道了 JavaScript 会阻塞 DOM 生成，而样式文件又会阻塞 JavaScript 的执行，所以在实际的工程中需要重点关注 JavaScript 文件和样式表文件，使用不当会影响到页面性能的。 小结首先我们介绍了 DOM 是如何生成的，然后又基于 DOM 的生成过程分析了 JavaScript 是如何影响到 DOM 生成的。因为 CSS 和 JavaScript 都会影响到 DOM 的生成，所以我们又介绍了一些加速生成 DOM 的方案，理解了这些，能让你更加深刻地理解如何去优化首次页面渲染。 额外说明一下，渲染引擎还有一个安全检查模块叫 XSSAuditor，是用来检测词法安全的。在分词器解析出来 Token 之后，它会检测这些模块是否安全，比如是否引用了外部脚本，是否符合 CSP 规范，是否存在跨站点请求等。如果出现不符合规范的内容，XSSAuditor 会对该脚本或者下载任务进行拦截。详细内容我们会在后面的安全模块介绍，这里就不赘述了。 思考：打开下面这个 HTML 页面，页面显示的内容会是什么？12345678910111213&lt;html&gt;&lt;body&gt; &lt;div&gt;1&lt;/div&gt; &lt;script&gt; let div1 = document.getElementsByTagName(&apos;div&apos;)[0] div1.innerText = &apos;time.geekbang&apos; let div2 = document.getElementsByTagName(&apos;div&apos;)[1] div2.innerText = &apos;time.geekbang.com&apos; &lt;/script&gt; &lt;div&gt;test&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[有关时间管理技巧的一些总结]]></title>
    <url>%2F2019%2F09%2F14%2F%E6%9C%89%E5%85%B3%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86%E6%8A%80%E5%B7%A7%E7%9A%84%E4%B8%80%E4%BA%9B%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[（未完成） 有效的时间管理建立在“取舍”的基础上曾经是新东方英语名师的李笑来，对于大学生群体的洞察是十分深刻的。他在《把时间当作朋友》中写道： 很多人的计划之所以不能坚持完成，是因为他们的计划实际上是“超人计划”——“不可能完成之任务”。我经常看到学生的计划上写着“每天背两百个单词”、“每天写五篇英语作文”什么的。这样的强度，对起步的人来讲，只不过是“貌似可行”而已。在一个所有人都匆匆忙忙的世界里，想放慢节奏实在是一件非常难的事情。但是，应该记住的是：凡是值得做的事情，都值得慢慢做——做很久很久。 同样，绝大多数人的时间管理之所以无效，是因为他们成天只想着“我要做什么”，根本就不考虑“我应该做什么”。 “想要做”的事情，和“应该做”的事情，它们是非常不同的，其中的区别应该好好体会……此外，还有一些被称为“喜欢做”、“擅长做”、“值得做”、“必须做”之类的事。 现在许多互联网企业开始流行 OKR 管理，在制定 OKR 时，Object（目标）一般不能超过 3 个。为什么？因为一个人同一时段中“应该做”的事情，不能太多，甚至，我认为一个人在一个阶段中“最应该做”的事应该只有一个。 我这至少是第三次在“人间的我”引用《暗时间》中的这段话了(一次是在《&lt;疯狂的程序员&gt;佳句摘抄》，另一次是在《时间：公平的资产（说两本书）》）： 兴趣遍地都是，专注和持之以恒才是真正稀缺的。其实人天生就对新事物怀有好奇心，然而不同的是，有些人的兴趣只能持续几天，当遇到第一个困难、第一道坎的时候，他们就熄灭了；然而另一些人的兴趣火花会变成火苗，火苗会变成火种，一直稳定地燃烧很多年。 之前写过《反思：专注就是让自己慢下来》，倒不是说要及时行乐，而是说不能太贪心、太急躁，要懂得用“慢功”，将时间和精力集中到一件最关键的事情上，最小化自己的“行动半径”——其实就是做“取舍”。只有舍弃那些只是“想要做”却不一定是“应该做”的事情，才能把“应该做”的事情做好，这就是“少就是多”。 讲了那么多，可是到底我们“取舍”的标准是什么？哪件事情是“最应该做”的？ 我觉得这首先得是一件有助于打造自己“内核”的事情。 所谓“内核”，即为我在之前的《与自己的对话（二）》和《生物学思维的启示》中反复提及的“可持续增长的核心不变量”，它既要足够简单，又要稳定（是不变量），还要具有构建系统的能力（可以不断成长、不断扩展边界）。有了“内核”，才能在充满不确定性的环境中，拥有坚决执行的耐心和定力。 除此之外，这件事最好还是一件对人类社会有价值的事情（值得做），最好还是一件带给自己“创造型快乐”（《创造：驱动人生的引擎》）的事情（喜欢做），以及，它当然最好是自己擅长做的。最后，这件事如果还能让我混口饭吃，就再好不过了。 事实上，极少有人能够找到符合所有上述标准的事情。比如，搞懂自己是否擅长做某件事，这本身就要经过时间的检验，而时间却不可再生。我们只能做到尽量根据这些标准对自己能做的事情进行筛选。 时间管理的第一步是培养感知时间的能力]]></content>
      <categories>
        <category>扯淡杂文</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【浏览器工作原理】消息队列和事件循环]]></title>
    <url>%2F2019%2F09%2F07%2F%E3%80%90%E6%B5%8F%E8%A7%88%E5%99%A8%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E3%80%91%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%92%8C%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF%2F</url>
    <content type="text"><![CDATA[前面讲到：每个渲染进程都有一个主线程，并且主线程非常繁忙，既要处理 DOM，又要计算样式，还要处理布局，同时还需要处理 JavaScript 任务以及各种输入事件。 要让这么多不同类型的任务在主线程中有条不紊地执行，这就需要一个系统来统筹调度这些任务，这个统筹调度系统就是我们今天要讲的消息队列和事件循环系统。 引入事件循环使用单线程处理任务： 123456void MainThread()&#123; int num1 = 1+2; // 任务 1 int num2 = 20/5; // 任务 2 int num3 = 7*8; // 任务 3 print(&quot; 最终计算的值为:%d,%d,%d&quot;,num,num2,num3)； // 任务 4 &#125; 上面的 C++ 代码中，所有任务的代码按照顺序写进了主线程。 但并不是所有的任务都是在执行之前统一安排好的。大部分情况下，新的任务是在线程运行过程中产生的。 想要在线程运行过程中，能接收并执行新的任务，就要采取事件循环机制。 我们可以通过一个 for 循环语句来监听是否有新的任务，如下所示： 1234567891011121314151617// 等待用户从键盘输入一个数字，并返回该输入的数字int GetInput()&#123; int input_number = 0; cout&lt;&lt;&quot; 请输入一个数:&quot;; cin&gt;&gt;input_number; return input_number;&#125;// 主线程 (Main Thread)void MainThread()&#123; for(;;)&#123; int first_num = GetInput()； int second_num = GetInput()； result_num = first_num + second_num; print(&quot; 最终计算的值为:%d&quot;,result_num)； &#125;&#125; 这个版本的线程做了两点改进： 引入了循环机制。 引入了事件。等待用户输入的过程中，线程处于暂停状态。 通过引入事件循环机制，就让该线程“活”起来了，可以在执行过程中接受新的任务。 引入消息队列线程间通信第二版的线程模型中，所有的任务都来自于线程内部。 事实上，浏览器中的渲染主线程经常接收其他线程发送过来的任务。比如，接收到资源加载完成的消息后，就要进行 DOM 解析了；接收到鼠标的点击之后，就要开始执行相应的 JavaScript 脚本来处理该事件。 如何设计一个线程模型，让其能够接收其他线程发送的消息呢？ 一个通用的模式是使用消息队列。 IO 线程中产生的新任务添加进消息队列的尾部；渲染主线程会循环地从消息队列头部读取任务，执行任务。 代码实现： 123456789101112131415class TaskQueue&#123; public: Task takeTask(); // 取出队列头部的一个任务 void pushTask(Task task); // 添加一个任务到队列尾部&#125;;TaskQueue task_queue；void ProcessTask();void MainThread()&#123; for(;;)&#123; Task task = task_queue.takeTask(); ProcessTask(task); &#125;&#125; 如果有其他线程想要发送任务让主线程去执行，只需要将任务添加到消息队列中就可以了，代码如下： 12Task clickTask;task_queue.pushTask(clickTask) 由于多个线程操作同一个消息队列，所以在添加任务、取出任务时还会加上一个同步锁。 进程间通信在 Chrome 中，跨进程之间的任务也是频繁发生的，那么如何处理其他进程发送过来的任务？ 渲染进程内，专门有一个 IO 线程，用来接收其他进程传进来的消息。 如何安全退出当页面主线程执行完成之后，又该如何保证页面主线程能够安全退出呢？Chrome 是这样解决的，确定要退出当前页面时，页面主线程会设置一个退出标志的变量，在每次执行完一个任务时，判断是否有设置退出标志。 如果设置了，那么就直接中断当前的所有任务，退出线程，你可以参考下面代码： 1234567891011TaskQueue task_queue；void ProcessTask();bool keep_running = true;void MainThread()&#123; for(;;)&#123; Task task = task_queue.takeTask(); ProcessTask(task); if(!keep_running) // 如果设置了退出标志，那么直接退出线程循环 break; &#125;&#125; 页面使用单线程的缺点知道了页面的循环系统是如何工作的，接下来，讨论页面线程的一些特征。 鉴于消息队列“先进先出”的属性，就有如下两个问题需要解决。 如何处理高优先级的任务比如一个典型的场景是监控 DOM 节点的变化情况（节点的插入、修改、删除等动态变化），然后根据这些变化来处理相应的业务逻辑。一个通用的设计的是，利用 JavaScript 设计一套监听接口，当变化发生时，渲染引擎同步调用这些接口，这是一个典型的观察者模式。 不过这个模式有个问题，因为 DOM 变化非常频繁，如果每次发生变化的时候，都直接调用相应的 JavaScript 接口，那么这个当前的任务执行时间会被拉长，从而导致执行效率的下降。 如果将这些 DOM 变化做成异步的消息事件，添加到消息队列的尾部，那么又会影响到监控的实时性，因为在添加到消息队列的过程中，可能前面就有很多任务在排队了。 这也就是说，如果 DOM 发生变化，采用同步通知的方式，会影响当前任务的执行效率；如果采用异步方式，又会影响到监控的实时性。 那该如何权衡效率和实时性呢？ 通常我们把消息队列中的任务称为宏任务，每个宏任务中都包含了一个微任务队列，在执行宏任务的过程中，如果 DOM 有变化，那么就会将该变化添加到微任务列表中，这样就不会影响到宏任务的继续执行，因此也就解决了执行效率的问题。 等宏任务中的主要功能都直接完成之后，这时候，渲染引擎并不着急去执行下一个宏任务，而是执行当前宏任务中的微任务，因为 DOM 变化的事件都保存在这些微任务队列中，这样也就解决了实时性问题。 如何解决单个任务执行时间过久的问题浏览器通过回调功能来规避这种问题。至于回调功能如何实现，以后再详细介绍。 小结 如果有一些确定好的任务，可以使用一个单线程来按照顺序处理这些任务，这是第一版线程模型。 要在线程执行过程中接收并处理新的任务，就需要引入循环语句和事件系统，这是第二版线程模型。 如果要接收其他线程发送过来的任务，就需要引入消息队列，这是第三版线程模型。 如果其他进程想要发送任务给页面主线程，那么先通过 IPC 把任务发送给渲染进程的 IO 线程，IO 线程再把任务发送给页面主线程。 消息队列机制并不是太灵活，为了适应效率和实时性，引入了微任务。 基于消息队列的设计是目前使用最广的消息架构，无论是安卓还是 Chrome 都采用了类似的任务机制。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>浏览器工作原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编译原理之美】面向对象的实现]]></title>
    <url>%2F2019%2F09%2F02%2F%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[从（编译原理的）语义设计和运行时机制的角度，剖析面向对象的特性。 理解面向对象的实现机制。 面向对象的语义特征从类型角度：类型处理是语义分析时的重要工作。我们要扩展语言的类型机制，让程序员可以在基础数据类型之上扩展自己的类型。 从作用域角度： 类的可见性。 对象的成员的作用域。它们可以在整个对象的内部访问，无论在哪个位置声明（这点，和函数或块中的本地变量不一样）。 从生存期的角度： 对象的成员变量的生存期，一般跟对象的生存期是一样的。当然，如果某个成员引用了从堆中申请的内存，这些内存需要手动释放或者由垃圾收集机制释放。 还有一些成员，不是与对象绑定的，而是与类型绑定的，比如静态成员。静态成员的作用域和生存期都与普通成员不同。 以上三个语义概念，解释清楚了面向对象的封装特性（在底层的实现）。 类的语法（设计与解析）设计语法规则如下： 1234567891011121314151617181920212223242526classDeclaration : CLASS IDENTIFIER (EXTENDS typeType)? (IMPLEMENTS typeList)? classBody ;classBody : &apos;&#123;&apos; classBodyDeclaration* &apos;&#125;&apos; ;classBodyDeclaration : &apos;;&apos; | memberDeclaration ;memberDeclaration : functionDeclaration | fieldDeclaration ;functionDeclaration : typeTypeOrVoid IDENTIFIER formalParameters (&apos;[&apos; &apos;]&apos;)* (THROWS qualifiedNameList)? functionBody ; 类声明以 class 关键字开头，有一个标识符是类型名称，后面跟着类的主体。 类的主体里要声明类的成员。在简化的情况下，可以只关注类的属性和方法两种成员。我们故意把类的方法也叫做 function，而不是 method，是想把对象方法和函数做一些统一的设计。 函数声明现在的角色是类的方法。 类的成员变量的声明和普通变量声明在语法上没什么区别。 之前形成的一些基础的语法模块都可以复用，比如变量声明、代码块（block）等。 可以运行它： 12345678910111213141516171819202122232425262728293031323334/*ClassTest.play 简单的面向对象特性。*/class Mammal&#123; // 类属性 string name = &quot;&quot;; // 构造方法 Mammal(string str)&#123; name = str; &#125; // 方法 void speak()&#123; println(&quot;mammal &quot; + name +&quot; speaking...&quot;); &#125;&#125;Mammal mammal = Mammal(&quot;dog&quot;); //playscript 特别的构造方法，不需要 new 关键字mammal.speak(); // 访问对象方法println(&quot;mammal.name = &quot; + mammal.name); // 访问对象的属性// 没有构造方法，创建的时候用缺省构造方法class Bird&#123; int speed = 50; // 在缺省构造方法里初始化 void fly()&#123; println(&quot;bird flying...&quot;); &#125;&#125;Bird bird = Bird(); // 采用缺省构造方法println(&quot;bird.speed : &quot; + bird.speed + &quot;km/h&quot;);bird.fly(); 解析做完词法分析和语法分析之后，playscript 会在语义分析阶段扫描 AST，识别出所有自定义的类型，以便在其他地方引用这些类型来声明变量。因为类型的声明可以在代码中的任何位置，所以最好用单独的一次遍历来识别和记录类型。（类型扫描的代码在 TypeAndScopeScanner.java 里。） 语义分析的工作之一，就是做变量类型的消解。当我们声明 Bird bird = Bird(); 时，需要知道 Bird 对象的定义在哪里。（变量类型消解的代码在 TypeResolver.java 里。） 语义分析时，把类型的定义保存在一个数据结构中，实现如下：1234567891011121314public class Class extends Scope implements Type&#123; ...&#125;public abstract class Scope extends Symbol&#123; // 该 Scope 中的成员，包括变量、方法、类等。 protected List&lt;Symbol&gt; symbols = new LinkedList&lt;Symbol&gt;(&#125;public interface Type &#123; public String getName(); // 类型名称 public Scope getEnclosingScope();&#125; 其中，Class 就是一个 Scope。Scope 里原来就能保存各种成员，现在可以直接复用。 类图如下： 图中的几个类是符号体系的主要成员。在做词法分析时，我们会解析出很多标识符，这些标识符出现在不同的语法规则里，包括变量声明、表达式，以及作为类名、方法名等出现。在语义分析阶段，我们要把这些标识符一一识别：这个是一个变量，指的是一个本地变量；那个是一个方法名等。 变量、类和函数的名称，我们都叫做符号，比如示例程序中的 Mammal、Bird、mammal、bird、name、speed 等。编译过程中的一项重要工作就是建立符号表，它帮助我们进一步地编译或执行程序，而符号表就用上面几个类来保存信息。在符号表里，我们保存它的名称、类型、作用域等信息。对于类和函数，我们也有相应的地方来保存类变量、方法、参数、返回值等信息。你可以看一看示例代码里面是如何解析和记录这些符号的。 面向对象程序的运行机制实例化对象我们的语法中没有使用 new 关键字，而是直接调用一个跟类名相同的函数，示例代码如下： 12Mammal mammal = Mammal(&quot;dog&quot;); //playscript 特别的构造方法，不需要 new 关键字Bird bird = Bird(); // 采用缺省构造方法 语义检查时，无法在当前作用域找到这样的函数。我们需要检查 Mammal 和 Bird 是不是类名。在 RefResolver.java 中做语义分析的时候，下面的代码能够检测出某个函数调用其实是类的构造方法，或者是缺省构造方法： 1234567891011121314151617// 看看是不是类的构建函数，用相同的名称查找一个 classClass theClass = at.lookupClass(scope, idName);if (theClass != null) &#123; function = theClass.findConstructor(paramTypes); if (function != null) &#123; at.symbolOfNode.put(ctx, function); &#125; // 如果是与类名相同的方法，并且没有参数，那么就是缺省构造方法 else if (ctx.expressionList() == null)&#123; at.symbolOfNode.put(ctx, theClass); // TODO 直接赋予 class &#125; else&#123; at.log(&quot;unknown class constructor: &quot; + ctx.getText(), ctx); &#125; at.typeOfNode.put(ctx, theClass); // 这次函数调用是返回一个对象&#125; 类的构造方法跟普通函数有所不同，比如我们不允许构造方法定义返回值，因为它的返回值一定是这个类的一个实例对象。 对象数据的内存管理我们可以把对象的数据和其他数据一样，保存在栈里。C 语言的结构体 struct 和 C++ 语言的对象，都可以保存在栈里（直接声明并实例化，而不是用 new 关键字创建的）。如果用 new 关键字来创建，实际上是在堆里申请一块内存，赋值给一个指针变量。 当对象保存在堆里的时候，可以有多个变量都引用同一个对象，对象的生存期可以超越创建它的栈桢的生存期。 分析完对象的内存管理方式之后，回到 playscript 的实现。在 playscrip 的 Java 版本里，我们用一个 ClassObject 对象来保存对象数据，而 ClassObject 是 PlayObject 的子类。我们已经讲过 PlayObject，它被栈桢用来保存本地变量，可以通过传入 Variable 来访问对象的属性值： 123456789101112131415161718192021// 类的实例public class ClassObject extends PlayObject&#123; // 类型 protected Class type = null; ... &#125;// 保存对象数据public class PlayObject &#123; // 成员变量 protected Map&lt;Variable, Object&gt; fields = new HashMap&lt;Variable, Object&gt;(); public Object getValue(Variable variable)&#123; Object rtn = fields.get(variable); return rtn; &#125; public void setValue(Variable variable, Object value)&#123; fields.put(variable, value); &#125;&#125; 访问对象的属性和方法在示例代码中，我们用点操作符来访问对象的属性和方法，比如： 12mammal.speak(); // 访问对象方法println(&quot;mammal.name = &quot; + mammal.name); // 访问对象的属性 属性和方法的引用也是一种表达式，语法定义如下： 12345678expression : ... | expression bop=&apos;.&apos; ( IDENTIFIER // 对象属性 | functionCall // 对象方法 ) ... ; 注意，点符号的操作可以是级联的，比如： 12obj1.obj2.field1;obj1.getObject2().field1; 所以，对表达式的求值，要能够获得正确的对象引用。可以参考 GitHub 项目中的实现。 另外，对象成员还可以设置可见性。这是个语义问题，在编译阶段做语义检查的时候，不允许私有的成员被外部访问，报编译错误就可以了，其他方面没有不同。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[限制与抽象：找到不变量的方法]]></title>
    <url>%2F2019%2F08%2F31%2F%E9%99%90%E5%88%B6%E4%B8%8E%E6%8A%BD%E8%B1%A1%EF%BC%9A%E6%89%BE%E5%88%B0%E4%B8%8D%E5%8F%98%E9%87%8F%E7%9A%84%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[思想实验：发明万能机器能否发明一台可以解决一切问题的机器？ “解决一切问题”，这似乎是异想天开，因为它实在太大，大到不着边际。这里的问题包罗万象、变化万千，以至于让人完全不知道从何入手。 如果我们人为加上一些“限制”，问题就会变得可解（其实就是更容易被人理解）。因此，我们不妨在头脑中做一些假设。 假设我们有一台机器，它有极强的“计算”能力。然后把“一切问题”限制为“一切可计算的问题”。 由此，我们很容易会想到去思考“计算”本身。 所谓计算，其实就是将一个数据（输入x）变换为另一个数据（输出y）。在数学中，我们用“函数”来表示：y = F(x) 无论数据 x、y 的含义是什么，它们的本质都是信息（它们都可以抽象成信息）。而信息可以用 bit 量化为数字（根据信息论），物理上可以用一段连续的字节内容来表达。所以，我们需要有一个物理“存储”用来存放操作的数据。 解决了 x、y，接下来的问题是“函数 F”也是未知的。 假设，我们只掌握最小化的计算单元，比如“加减乘除”。怎样用这些计算单元，表达任意复杂度的函数（计算）？ 估计多数人首先想到的是泰勒展开式——如果函数足够光滑的话，可以用某一点（x = a）的各阶导数值做系数，构建一个多项式来近似函数在这一点的邻域中的值。这样确实可以用来表达某些函数（比如正弦函数），但还远远不够。 再加上一些限制。函数的计算具有各种各样的复杂流程，我们把这些流程限制成 3 种：顺序、分支、循环。通过这个限制，大大降低了函数的表达难度，但是并没有降低复杂性。因为 3 种流程的排列组合，仍然可以实现无数种算法——就像 DNA 只有 4 种碱基一样。 为了便于理解，我们还需要抽象——把“一系列流程的组合”封装成一个“黑盒子”，我们忽略它的内部细节，只关注它的输入、输出。 好，这样我们就可以用一组指令的序列来表达函数了。这些指令包括： 执行最小计算单元（也就是内置函数）； 执行顺序，包括条件分支、循环； 执行其他自定义的函数（子函数）。 我们把这样的指令序列叫做“程序”，它是计算的载体。程序也是信息，它也存放在“存储”中。 于是，我们给负责计算的机器加上物理存储。看上去，它已经可以进行任意复杂的“计算”了。但是它还无法和现实世界发生交互，即输入和输出。 除了要有能够把现实世界的信号抽象成数据的设备，还要限制各个设备之间交换数据的方式，即定义好统一的数据交换契约。 至此，经由多次的限制与抽象，我们得到了简化的冯·诺依曼机。它是所有现代计算机的原型。]]></content>
      <categories>
        <category>扯淡杂文</category>
      </categories>
      <tags>
        <tag>软件</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编译原理之美】作用域和生存期]]></title>
    <url>%2F2019%2F08%2F30%2F%E3%80%90%E7%BC%96%E8%AF%91%E5%8E%9F%E7%90%86%E4%B9%8B%E7%BE%8E%E3%80%91%E4%BD%9C%E7%94%A8%E5%9F%9F%E5%92%8C%E7%94%9F%E5%AD%98%E6%9C%9F%2F</url>
    <content type="text"><![CDATA[使用 Antlr 工具，我们实现了简单的脚本解释器。当然，还有一些更高级的功能也能实现，比如函数功能、面向对象功能。只是我们还要克服一些挑战，如： 如果要实现函数功能，要升级变量管理机制； 引入作用域机制，来保证变量的引用指向正确的变量定义； 变量存储，不能再把变量和它的值简单的存储到一个 HashMap 里。要管理它的生存期，减少对内存的占用。 本文将借实现块级作用域和函数功能，带你讨论作用域和生存期及其实现机制，并升级变量管理机制。 深入理解作用域和生存期，了解它们在编译期和运行期的机制之后，可以回答一些实际问题： 闭包的机理到底是什么？ 为什么需要栈和堆两种机制来管理内存？ 一个静态的内部类和普通的内部类有什么区别？ 作用域（Scope）作用域是指计算机语言中变量、函数、类等起作用的范围。 以 C 语言为例，它的作用域包括这些规律： 变量的作用域有大有小，外部变量可以在函数内访问，而函数中的本地变量，只有在本地才可以访问。 变量的作用域，从声明以后开始。 在函数中，可以声明与外部变量同名的变量，它会覆盖外部变量。 块级作用域（用花括号包围的语句）的特征和函数作用域的特征相似。 即使是相同的块级作用域（花括号）语法，不同语言（C, Java, JS）的作用域特征都不尽相同。这种不同是语义差别的一个例子。 对作用域的分析就是语义分析的任务之一。Antlr 能够完成很多词法分析和语法分析的工作，但语义分析工作需要我们自己做。 生存期（Extent）生存期是指变量可以被访问的时间段，也就是从“分配内存给它”到“收回它的内存”之间的时间。 本地变量的特征：变量的生存期和作用域是一致的。本地变量用栈来管理。 有些情况，变量的生存期跟语法上的作用域不一致，比如在堆中申请的内存，退出作用域后仍然存在。在 C 语言中，通过 free() 回收堆中的内存；在 Java 和 JS 中，通过垃圾回收机制。 虽然各门语言设计上的特性是不同的，但在运行期的机制都很相似，比如都会用到栈和堆来做内存管理。 实现作用域之前处理变量赋值时，我们简单地把变量存在一个哈希表里，用变量名去引用，就像下面这样： 1234public class SimpleScript &#123; private HashMap&lt;String, Integer&gt; variables = new HashMap&lt;String, Integer&gt;(); ...&#125; 但如果变量存在多个作用域，这样做就不行了。 我们需要一个数据结构来区分不同的作用域。我们可以看到，C 语言中的作用域是一个树状的结构，比如： 全局 fun() ……块（如果有的话） main() if 块 else 块 面向对象的语言不太相同，它不是一棵树，而是一片森林。每个类对应一棵树，而且没有全局变量。 我们创建了下面的对象结构来表示 Scope： 1234567891011121314151617181920212223242526272829303132333435// 编译过程中产生的变量、函数、类、块，都被称作符号public abstract class Symbol &#123; // 符号的名称 protected String name = null; // 所属作用域 protected Scope enclosingScope = null; // 可见性，比如 public 还是 private protected int visibility = 0; //Symbol 关联的 AST 节点 protected ParserRuleContext ctx = null;&#125;// 作用域public abstract class Scope extends Symbol&#123; // 该 Scope 中的成员，包括变量、方法、类等。 protected List&lt;Symbol&gt; symbols = new LinkedList&lt;Symbol&gt;();&#125;// 块作用域public class BlockScope extends Scope&#123; ...&#125;// 函数作用域public class Function extends Scope implements FunctionType&#123; ... &#125;// 类作用域public class Class extends Scope implements Type&#123; ...&#125; 我们在解释执代码的 AST（抽象语法树）的时候，需要建立起作用域的树结构。对作用域的分析过程是语义分析的一部分。（在运行 AST 之前，我们还要做语义分析，比如对作用域做分析，让每个变量都能做正确的引用，这样才能正确地执行这个程序。） 实现生命期（栈）随着代码的执行，各个变量的生存期表现如下： 进入程序，全局变量逐一生效； 进入 main 函数，main 函数里的变量顺序生效； 进入 fun 函数，fun 函数里的变量顺序生效； 退出 fun 函数，fun 函数里的变量失效； 进入 if 语句块，if 语句块里的变量顺序生效； 退出 if 语句块，if 语句块里的变量失效； 退出 main 函数，main 函数里的变量失效； 退出程序，全局变量失效。 代码执行时进入和退出一个个作用域的过程，可以用栈来实现。每进入一个作用域，就往栈里压入一个数据结构，这个数据结构叫做栈桢（Stack Frame）。栈桢能够保存当前作用域的所有本地变量的值，当退出这个作用域的时候，这个栈桢就被弹出，里面的变量也就失效了。栈的机制可以有效地使用内存。 在概念上模仿栈桢： 1234567891011121314151617private Stack&lt;StackFrame&gt; stack = new Stack&lt;StackFrame&gt;();public class StackFrame &#123; // 该 frame 所对应的 scope Scope scope = null; // enclosingScope 所对应的 frame StackFrame parentFrame = null; // 实际存放变量的地方 PlayObject object = null;&#125;public class PlayObject &#123; // 成员变量 protected Map&lt;Variable, Object&gt; fields = new HashMap&lt;Variable, Object&gt;();&#125; 事实上，Java 中除了基础类型（比如 int）之外的所有对象都是存放在堆里的，因此上面代码中的 PlayObject 对象存放在堆里。这只是模仿。我们将在后端技术部分实现真正意义上的栈桢。 要注意的是，栈的结构和 Scope 的树状结构是不一致的。所以，栈里的上一级栈桢，不一定是 Scope 的父节点。要访问上一级 Scope 中的变量数据，要顺着栈桢的 parentFrame 去找。 块级作用域示例我们已经做好了作用域和栈，下面以 for 语句为例，visit 方法首先为它实现一个栈桢，并加入到栈中。运行完毕之后，再将栈桢弹出。 12345678BlockScope scope = (BlockScope) cr.node2Scope.get(ctx); // 获得 ScopeStackFrame frame = new StackFrame(scope); // 创建一个栈桢pushStack(frame); // 加入栈中...// 运行完毕，弹出栈stack.pop(); 当我们在代码中需要获取某个变量的值的时候，首先在当前桢中寻找。找不到的话，就到上一级作用域对应的桢中去找： 1234567891011StackFrame f = stack.peek(); // 获取栈顶的桢PlayObject valueContainer = null;while (f != null) &#123; // 看变量是否属于当前栈桢里 if (f.scope.containsSymbol(variable))&#123; valueContainer = f.object; break; &#125; // 从上一级 scope 对应的栈桢里去找 f = f.parentFrame;&#125; 函数功能示例与函数有关的语法： 1234567891011121314151617181920212223242526272829303132333435363738// 函数声明functionDeclaration : typeTypeOrVoid? IDENTIFIER formalParameters (&apos;[&apos; &apos;]&apos;)* functionBody ;// 函数体functionBody : block | &apos;;&apos; ;// 类型或 voidtypeTypeOrVoid : typeType | VOID ;// 函数所有参数formalParameters : &apos;(&apos; formalParameterList? &apos;)&apos; ;// 参数列表formalParameterList : formalParameter (&apos;,&apos; formalParameter)* (&apos;,&apos; lastFormalParameter)? | lastFormalParameter ;// 单个参数formalParameter : variableModifier* typeType variableDeclaratorId ;// 可变参数数量情况下，最后一个参数lastFormalParameter : variableModifier* typeType &apos;...&apos; variableDeclaratorId ;// 函数调用 functionCall : IDENTIFIER &apos;(&apos; expressionList? &apos;)&apos; | THIS &apos;(&apos; expressionList? &apos;)&apos; | SUPER &apos;(&apos; expressionList? &apos;)&apos; ; 在函数里，我们还要考虑一个额外的因素：参数。在函数内部，参数变量跟普通的本地变量在使用时没什么不同，在运行期，它们也像本地变量一样，保存在栈桢里。 我们设计一个对象来代表函数的定义，它包括参数列表和返回值的类型： 123456789public class Function extends Scope implements FunctionType&#123; // 参数 protected List&lt;Variable&gt; parameters = new LinkedList&lt;Variable&gt;(); // 返回值 protected Type returnType = null; ...&#125; 在调用函数时，实际上做了三步工作： 建立一个栈桢； 计算所有参数的值，并放入栈桢； 执行函数声明中的函数体。 相关代码：123456789101112131415161718192021222324252627282930313233// 函数声明的 AST 节点FunctionDeclarationContext functionCode = (FunctionDeclarationContext) function.ctx;// 创建栈桢functionObject = new FunctionObject(function);StackFrame functionFrame = new StackFrame(functionObject);// 计算实参的值List&lt;Object&gt; paramValues = new LinkedList&lt;Object&gt;();if (ctx.expressionList() != null) &#123; for (ExpressionContext exp : ctx.expressionList().expression()) &#123; Object value = visitExpression(exp); if (value instanceof LValue) &#123; value = ((LValue) value).getValue(); &#125; paramValues.add(value); &#125;&#125;// 根据形参的名称，在栈桢中添加变量if (functionCode.formalParameters().formalParameterList() != null) &#123; for (int i = 0; i &lt; functionCode.formalParameters().formalParameterList().formalParameter().size(); i++) &#123; FormalParameterContext param = functionCode.formalParameters().formalParameterList().formalParameter(i); LValue lValue = (LValue) visitVariableDeclaratorId(param.variableDeclaratorId()); lValue.setValue(paramValues.get(i)); &#125;&#125;// 调用方法体rtn = visitFunctionDeclaration(functionCode);// 运行完毕，弹出栈stack.pop(); 本课程的 GitHub 项目]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>编译原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 中的 this]]></title>
    <url>%2F2019%2F08%2F29%2FJavaScript-%E4%B8%AD%E7%9A%84-this%2F</url>
    <content type="text"><![CDATA[执行上下文中的 this JS 代码在执行之前需要被 JS 引擎编译。经过编译之后，会产生两部分内容： 执行上下文（Execution context） 可执行代码 执行上下文是 JS 执行一段代码时的运行环境，它确定执行期间用到的数据。具体包括： 变量环境（Viriable Environment）对象，该对象中保存了变量提升的内容。 词法环境，保存了 let、const 关键字声明的变量。 外部环境（outer），与作用域链有关。 this。 执行上下文有三种，对应了三种 this： 全局执行上下文中的 this 函数执行上下文中的 this eval 执行上下文中的 this 全局执行上下文中的 this 一般指向 window 对象。这是作用域链和 this 的唯一交点——作用域链也包含了 windows 对象。作用域链和 this 是两套不同的系统，它们之间没有太多联系。 函数执行上下文中的 this1234function foo()&#123; console.log(this)&#125;foo() // window 这似乎说明，函数的 this 值也指向全局 windows 对象。（在严格模式下，这里的 this 值是 undefied。） 1234567var myObj = &#123; name : &quot; 极客时间 &quot;, showThis: function()&#123; console.log(this) &#125;&#125;myObj.showThis() // window 这说明，方法的 this 指向对象本身。（我们一般把对象内部的函数叫做“方法”。） 但是，改一下调用方式，把 showThis 赋给一个全局对象，然后再调用该对象，会发现 this 又指向了 windows 对象： 123456789var myObj = &#123; name : &quot; 极客时间 &quot;, showThis: function()&#123; this.name = &quot; 极客邦 &quot; console.log(this) &#125;&#125;var foo = myObj.showThisfoo() // window 改变函数中的 this 指向通过函数的 call、bind 和 apply 方法可以改变函数的 this 指向。可以参考《JS 中的 apply, call, bind》，本文就不展开了。 另外，还可以通过构造函数的方式，把函数中的 this 指向 new 出来的新对象： 1234function CreateObj()&#123; this.name = &quot; 极客时间 &quot;&#125;var myObj = new CreateObj() 当执行 new CreateObj() 的时候，JS 引擎做了如下四件事： 首先创建了一个空对象 tempObj； 接着调用 CreateObj.call(tempObj) 方法，创建 CreateObj 的执行上下文时，将 this 指向了 tempObj 对象。 执行 CreateObj 函数； 最后返回 tempObj 对象。 相当于以下代码： 123var tempObj = &#123;&#125;CreateObj.call(tempObj)return tempObj this 的设计缺陷普通函数中的 this 默认指向全局对象 window在实际工作中，并不希望如此，因为这样会打破数据的边界，造成一些误操作。 这个问题可以通过设置 JavaScript 的“严格模式”来解决。 嵌套函数中的 this 不会从外层函数中继承123456789var myObj = &#123; name : &quot; 极客时间 &quot;, showThis: function()&#123; console.log(this) function bar()&#123;console.log(this)&#125; bar() &#125;&#125;myObj.showThis() 如果刚接触 JavaScript，那么可能会很自然地觉得，bar 中的 this 应该和其外层 showThis 函数中的 this 是一致的，都是指向 myObj 对象的，这很符合人的直觉。 但实际上，函数 bar 中的 this 指向的是全局 window 对象，而函数 showThis 中的 this 指向的是 myObj 对象。 想要达到原来预想的效果，可以借助作用域，在外层函数中声明一个 self 变量来保存 this： 1234567891011121314var myObj = &#123; name : &quot; 极客时间 &quot;, showThis: function()&#123; console.log(this) var self = this function bar()&#123; self.name = &quot; 极客邦 &quot; &#125; bar() &#125;&#125;myObj.showThis()console.log(myObj.name)console.log(window.name) 也可以使用 ES6 中的箭头函数。箭头函数并不会创建它自身的执行上下文，所以箭头函数中 this 取决于它的外部函数。 思考题123456789101112131415let userInfo = &#123; name:&quot;jack.ma&quot;, age:13, sex:male, updateInfo:function()&#123; // 模拟 xmlhttprequest 请求延时 setTimeout(function()&#123; this.name = &quot;pony.ma&quot; this.age = 39 this.sex = female &#125;,100) &#125;&#125;userInfo.updateInfo() 我想通过 updateInfo 来更新 userInfo 里面的数据信息，但是这段代码存在一些问题，你能修复这段代码吗？]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程范式】编程的本质]]></title>
    <url>%2F2019%2F08%2F20%2F%E3%80%90%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E3%80%91%E7%BC%96%E7%A8%8B%E7%9A%84%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[Program = Logic + Control + Data Structure 两篇论文1976年，瑞士计算机科学家，Algol W，Modula，Oberon 和 Pascal 语言的设计师 Niklaus Emil Wirth写了”Algorithms + Data Structures = Programs” ，即《算法 + 数据结构 = 程序》。 1979 年，英国逻辑学家和计算机科学家 Robert Kowalski 发表论文 “Algorithm = Logic + Control”，论文里提到： 任何算法都会有两个部分， 一个是 Logic 部分，这是用来解决实际问题的。另一个是 Control 部分，这是用来决定用什么策略来解决问题。Logic 部分是真正意义上的解决问题的算法，而 Control 部分只是影响解决这个问题的效率。程序运行的效率问题和程序的逻辑其实是没有关系的。我们认为，如果将 Logic 和 Control 部分有效地分开，那么代码就会变得更容易改进和维护。 编程的本质 Programs = Algorithms + Data Structures Algorithm = Logic + Control 第二个表达式想表达的是，数据结构不复杂，复杂的是算法。算法由两个逻辑组成，一个是真正的业务逻辑，另外一种是控制逻辑。业务逻辑是复杂的。 算法的效率往往可以通过提高控制部分的效率来实现，而无须改变逻辑部分（也就是算法的意义）。举个阶乘的例子， X(n)！= X(n) * X(n-1) * X(n-2) * X(n-3)* … * 3 * 2 * 1。 逻辑——定义阶乘： 1） 1 是 0 的阶乘；2）如果 v 是 x 的阶乘，且 u=v*(x+1)，那么 u 是 x+1 的阶乘。 控制——实现上面的逻辑：用这个定义，既可以从上往下地将 x+1 的阶乘缩小为先计算 x 的阶乘，再将结果乘以 1（recursive，递归），也可以由下而上逐个计算一系列阶乘的结果（iteration，遍历）。 各种编程范式或程序设计的方法，比如： 函数式编程中的 Map/Reduce/Filter，它们都是一种控制。而传给这些控制模块的那个 Lambda 表达式才是我们要解决的问题的逻辑。它们共同组成了一个算法。 就像 Go 语言委托模式的那个 Undo。Undo 是我们要解决的问题，是 Logic，但是 Undo 的流程是控制。 就像我们面向对象中依赖于接口，而不是依赖于实现。接口是对逻辑的抽象，真正的逻辑放在不同的具象类中，通过多态或是依赖注入这样的控制来完成对数据在不同情况下的不同处理。 所有的语言或编程范式都在解决以下 3 个问题（它们体现了编程范式的本质）： Control 是可以标准化的。比如：遍历数据、查找数据、多线程、并发、异步等，都是可以标准化的。 因为 Control 需要处理数据，所以标准化 Control，需要标准化 Data Structure。我们可以通过泛型编程来解决这个事。 因为 Control 需要处理用户的业务逻辑，即 Logic。所以，我们通过标准化接口 / 协议来实现，我们的 Control 模式可以适配于任何的 Logic。 把逻辑和控制分离有效地分离 Logic、Control 和 Data 是写出好程序的关键所在！ 业务逻辑决定了程序的复杂度，业务逻辑本身就复杂。把控制逻辑和业务逻辑放在一块，代码就不可能写得简单。Logic 是程序复杂度的下限。Logic + Control 的互相交织成为了最终的程序复杂度。 逻辑是你的业务逻辑：逻辑过程的抽象 + 一个由术语表示的数据结构的定义。业务逻辑跟控制逻辑是没关系的。 控制，即程序执行的方式：一个程序流转的方式（自顶向下、自底向上） + 执行过程的策略（并行或串行，同步或异步） + 调度不同的执行路径或模块 + 数据之间的存储关系。这些和业务逻辑没有关系。 以文本解析为例前不久，我自己写了一个“服装制板语言”的解释器，代码里把 Logic 和 Control 都混在了一起，全部在一个解析函数里，这个函数十分冗长。 学习完“编译原理之美”后，我发现写“文本解析”有通用的套路： 词法分析。用一个有限自动机来匹配特定的 Token； 语法分析。用“递归向下”、“上下文无关”等方法构建一个“抽象语法树”。 语义分析。…… 这个通用的套路就属于 Control。有篇关于正则表达式的高效算法的论文，叫“Regular Expression Matching Can Be Simple And Fast”。 以表单检查为例常见的检查用户表单信息的代码：1234567891011121314151617181920212223242526function check_form_x() &#123; var name = $(&apos;#name&apos;).val(); if (null == name || name.length &lt;= 3) &#123; return &#123; status : 1, message: &apos;Invalid name&apos; &#125;; &#125; var password = $(&apos;#password&apos;).val(); if (null == password || password.length &lt;= 8) &#123; return &#123; status : 2, message: &apos;Invalid password&apos; &#125;; &#125; var repeat_password = $(&apos;#repeat_password&apos;).val(); if (repeat_password != password.length) &#123; return &#123; status : 3, message: &apos;Password and repeat password mismatch&apos; &#125;; &#125; var email = $(&apos;#email&apos;).val(); if (check_email_format(email)) &#123; return &#123; status : 4, message: &apos;Invalid email&apos; &#125;; &#125; ... return &#123; status : 0, message: &apos;OK&apos; &#125;; &#125; 其实，我们可以做一个 DSL + 一个 DSL 的解析器，比如：1234567891011var meta_create_user = &#123; form_id : &apos;create_user&apos;, fields : [ &#123; id : &apos;name&apos;, type : &apos;text&apos;, min_length : 3 &#125;, &#123; id : &apos;password&apos;, type : &apos;password&apos;, min_length : 8 &#125;, &#123; id : &apos;repeat-password&apos;, type : &apos;password&apos;, min_length : 8 &#125;, &#123; id : &apos;email&apos;, type : &apos;email&apos; &#125; ]&#125;; var r = check_form(meta_create_user); 这样，DSL 描述是“Logic”，而 check_form 则成了“Control”，代码就非常好看了。 小结代码复杂度的原因： 业务逻辑的复杂度决定了代码的复杂度； 控制逻辑的复杂度 + 业务逻辑的复杂度 =&gt; 程序代码的混乱不堪； 绝大多数程序复杂混乱的根本原因：业务逻辑与控制逻辑的耦合。 Logic 部分才是真正有意义的（What） Control 部分只是影响 Logic 部分的效率（How） 如何分离 Control 和 Logic 呢？我们可以使用下面的这些技术来解耦。 状态机 - State Machine 状态定义 状态变迁条件 状态的 action DSL - Domain Specific Language HTML，SQL，Unix Shell Script，AWK，正则表达式…… 编程范式 面向对象：委托、策略、桥接、修饰、IoC/DIP、MVC…… 函数式编程：修饰、管道、拼装 逻辑推导式编程：Prolog]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C++ 编码规范总结]]></title>
    <url>%2F2019%2F08%2F16%2FC-%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83%E6%80%BB%E7%BB%93%2F</url>
    <content type="text"><![CDATA[推荐文档：Google C++ 编程风格 头文件依赖与前向声明当我们在头文件中需要类的定义时，只需要声明 class CLASSNAME 就可以了，无需使用#include “CLASSNAME.h”。 优势： 减少文件依赖，节约编译时间； 更加明确的类的依赖关系。 函数的参数顺序参数的声明顺序为，输入参数在前，输出参数在后。 输入参数一般为传值和常数引用； 输出参数或输入/输出参数一般为非常数指针。 优势： 通过位置明确参数的作用； 利于代码的合并（用合并软件）。 示例：1234567class Foo;void Command(const int nInputParam1, const float nInputParam2, const Foo&amp; nInputClass1, const Foo* nInputClass2, void* pOutputParam1); 头文件包含的顺序顺序： 先包含类对应头文件 C 系统头文件 C++ 系统头文件 其他库头文件 本项目内头文件 之间通过空行区分。 优势： 增加可读性 利于代码合并 局部变量的初始化在尽可能小的作用域中声明变量，离第一次使用的位置越近越好。 好处： 使得代码易读，避免一些错误。 对于结构体或数组，声明以后，也应立刻进行初始化操作：12345TOOLTIP tooltip = &#123;0&#125;;char buff[1024] = &#123;0&#125;;memset(&amp;tooltip, 0, sizeof(tooltip));memset(buff, 0, 1024)； 局部类的初始化一个类的局部变量会默认做一次构造和析构，应注意避免多次的初始化与析构。 示例：1234for(int a = 0; a &lt; 1000; a++)&#123; Foo f; f.doFun();&#125; 在循环内初始化的 f 会构造和析构 1000 次。应改为：1234Foo f;for(int a = 0; a &lt; 1000; a++)&#123; f.doFun();&#125; 类的初始化（构造函数） 注意类成员的初始化，养成良好的类成员声明习惯（声明后立刻在构造函数中进行初始化操作）； 类的初始化虽然很简单，但很多程序员忘记做了，导致不可预知的问题（因为导致变量的初始值不可预料）。 类的拷贝构造函数编译器会默认为我们的类提供一个赋值操作符函数和拷贝构造函数，但同时也会带来问题。 注意： 禁用不必要的默认拷贝构造和赋值函数。 函数的参数，尽量使用引用或指针，避免拷贝或赋值构造。 深拷贝与浅拷贝：默认的浅拷贝，两个对象的指针指向相同一块内存。 深拷贝示例：123456789101112// 重载赋值操作符void operator=(const Foo&amp; srcFoo)&#123; if(this == &amp;srcFoo) // 防止自复制 return; if(srcFoo.m_pszName)&#123; size_t nSize = _tcslen(srcFoo.m_pszName); if(nSize &gt; 0)&#123; m_pszName = new wchar_t[nSize + 1]; _tcscpy_s(m_pszName, nSize + 1, srcFoo.m_pszName); &#125; &#125;&#125; 可以通过宏禁止不提供的拷贝函数，也就是将这些方法声明为私有函数：12345678910// 禁止使用拷贝构造函数和赋值操作的宏// 应在类的 private: 中使用#define DISALLOW_COPY_AND_ASSIGN(TypeName) \ TypeName(const TypeName&amp;); \ void operator=(const TypeName&amp;) class Foo &#123;private: DISALLOW_COPY_AND_ASSIGN(Foo); ... 结构体和类区别：在 C++ 中，struct 和 class 可以起到同样的作用，唯一的区别是 struct 默认方法和成员是 public 的，class 默认是 private 的。（struct 也可以和 class 一样使用构造和析构函数对数据进行初始化和释放。） 我们约定仅当只有数据的时候使用struct，其他一般使用class。 操作符重载操作符重载可以为我们的代码编写提供便利，但是也会使我们的代码变得不够直观。例如增加一个 Equals 方法比直接对 == 操作符重载要来的直观得多。 因此我们一般不要对操作符进行重载。 将类的成员私有化面向对象编程的一个原则是隐藏内部的数据。有时候我们为了方便直接将数据声明为 public，应避免这种做法，虽然一时间节约了不少编码时间，但有时也会代码极大的不便。 优势： 代码封装性好； 有利于调试（因为所有对成员变量的调试场景都在 get 和 set 方法中）。 类中的声明顺序顺序： public protected private 没有的块可以忽略。 块内顺序： typedef 和 enums 常量 构造函数 析构函数 成员函数，含静态成员函数 数据成员，含静态数据成员 优势： 代码封装性好； 有利于调试。 编写短小的函数如果没有特殊的需求，函数的长度控制在40行左右。如果过长，不影响程序的运行的情况将长函数进行分割。 优势： 提取重复的代码； 便于他人阅读和修改； 便于发现和定位bug。 引用参数与 const如果传入引用型参数，请务必添加上 const。 优势： 约束调用行为； 自解释了参数的作用。 尽量使用 const尽量使用 const 定义参数类型。 使用的条件： 函数不会修改的引用或指针类型的参数； 不修改数据的函数，指定为 const； 如果类的成员变量在构造后不会改变，声明为const。 优势： 约束变量的操作行为。 示例：123bool Equal(const Point&amp; p1, const Point* p2) const &#123;&#125;// 函数的参数，尽量使用引用或指针，避免拷贝或赋值构造。 其他 没有特殊要求，尽量不进行函数重载，通过函数名称进行区分。过多的重载函数有时也会是调用者无从选择。 禁用缺省参数。避免调用者理解错误。 禁用 RTTI（不使用 dynamic_cast）。运行时类型识别本身就说明设计存在问题。利用类型号或者 virtual 方法都可以做到同样的功能。 前置自增或自减的效率要好于后置，特别是迭代器，区别非常大。 尽可能用 sizeof(varname) 而不是 sizeof(type)，防止变量类型在运行时被改变了。 变量命名 不要定义无法自解释的名称； 不要拼写错误或者拼写不完整； 类名称全部以大写开头； 结构体，枚举全部大写开头； 变量命名一律小写开头； 类成员变量以 m_ 开头； 所有的全局变量使用 g_ 开头； 常量使用小写 k 开头。如const int m_kIndex； 函数名称以大写开头（我之前都是小写的..），单词之前首字母大写； 类的存取函数，取函数以Get开头，设置函数以Set开头； 枚举类型中的值全部大写表示； 宏名称全部大写，单词之间通过下划线进行分割。 0、NULL 与初始化 整数用0 实数用0.0 指针用NULL 字符串用“\0” 优势：通过初始化的值就可以判断变量的类型。 匈牙利命名规则类型 + 作用名称如 bVisible, pVecBooks, nIndexDay 类型 字符 示例 指针 p pWnd pData 函数 fn fnCalc 无效 v vData 句柄 h hBitmap 长整型 l lDays 布尔 b bVisible 浮点型（有时也指文件） f fAngle 双字 dw dwStyle 字符串 str strName 短整型 n nIndex 双精度浮点 d dRotate 计数 c（通常用cnt） cIndex 字符 ch（通常用c） cByte 整型 i（我们通常用n） iIndex 字节 by byData 字 w wChar 实型 r rPi 无符号 u uSize 格式要求 一行代码不要过长； 空格作为制表符，两个空格代表一个制表符（VS 设置 - 所有语言 - 制表符，制表符大小和缩进大小都设置为2）； 函数声明中返回类型和函数名在同一行中，如果过长对行数的参数进行分行处理，并进行对齐； 函数调用和返回放在同一行中，如果代码过长，对传入的参数进行分行处理； 条件判断的 if 要加括号，左/右括号要另起一行，else 也是一样； 加减等操作符前后添加空格。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[自我观察，更好地认清自己]]></title>
    <url>%2F2019%2F08%2F01%2F%E8%87%AA%E6%88%91%E8%A7%82%E5%AF%9F%EF%BC%8C%E6%9B%B4%E5%A5%BD%E5%9C%B0%E8%AE%A4%E6%B8%85%E8%87%AA%E5%B7%B1%2F</url>
    <content type="text"><![CDATA[未完成 理性地谦卑和敬畏17年的时候，我在公众号[1]中写道： 所以，世界上那么多东西，看起来很简单，其实都是因为它们被封装好了，只需寥寥几个外部接口处的参量，就可以直接调用。比如饿了想吃饭，直接找家饭店付钱点餐就行了，至于其余的如何炒菜、如何种粮食、物流怎么运作……一律不用管。 不明所以的调用者，往往还以为只要拥有看似大量的知识，懂得看似很有用的道理，生活仿佛就变得简单了。殊不知真正大量的知识，犹如浩瀚星河，无边无际，几代人的学习也不足其万一；真正有用的道理，就是知道自己什么都不知道。 尤其是在这个时代，社会的知识分工已经快超出人的生理极限，世界的复杂性已经超乎想象[2]。虽然我们的大脑发育水平和几千年前刀耕火种的祖先没有太大差别，但是现代社会的分工协作体系高度发达，即使是小小一支铅笔的生产，都涉及到成千上万的人，涉及到无数个专业知识，这些知识不可能被单个人所全部掌握[3]。 罗胖曾说：我们和原始人的区别在于，他们手里拿的是石头，我们手里拿的是手机，是一个将认知高密度折叠了的东西。我所谓的“封装”，罗胖所谓的“折叠”，一个意思。 身处风口的人取得成就之后，经常认为是自己的能力强；在大公司工作的人被高看一眼，往往也认为是自己足够优秀。但是他们可能犯了一个错误，他们错把系统的能力当成了个人的能力[4]。 自动化、模板化、流程化、模块化[5]，这些都属于系统的特性。企业想要做好，就要构建系统能力，将过往积累的经验转化成一套标准的方法论，企业员工只要遵守这套方法，就能稳定地将投入变成产出。 一旦环境发生变化，脱离了原来的系统，人就会发现自己的无力感——原来的经验和方法论都不再适用。不论是在学校里“一心向学，莫问前程”的学霸初次步入社会，还是一家巨头公司的员工跳槽到一家初创公司，他们往往会无所适从，发现自己的能力没有想象的这么好。 前面论述的都是封装、折叠、工具、系统，这些“黑盒子”给人带来的自信，经常会使得人们不能足够清醒地认识自己的能力。 而有关盲目自信，还有一个著名的“邓宁-克鲁格效应”（简称“达克效应”），如下图所示。它表明了知识和经验量对于人自信程度的影响。 图中的横坐标表示“智慧”——知识加上经验，纵坐标表示自信程度。我们可以直观地看到，拥有了一点点微不足道的智慧以后，自信程度会极速上升，达到“愚昧之峰”；而随着智慧继续增长，自信程度又快速下降到了“绝望之谷”；之后，随着知识和经验的漫长积累，最终，成为大师的人才会将自信维持在一个平稳的高原地带。 我自认为，整体而言，我现在的位置正处在 Enlightenment（启蒙、开悟） 的山坡上。当我初中那会儿，我可能是像井底之蛙那般，处在“自信巅峰”；当我高中至大学之时，意识到自己的渺小，我的自信好像又经历了一个“崩溃之坡”；最近三四年，我都在试着将自己的自信心稳定下来，可是它仍然在此起彼伏地波动。（当然，不同的专业领域，我所处的位置也不一样，有些事情我自认为擅长，可能只是因为我太弱……） “愚昧之峰”上的人，为什么那么自信？因为他们不知道“自己不知道”，自信建立在“自以为懂得很多道理”的基础上。他们对与自己相左的观点往往具有敌意，因为那些观点动摇了他们自信的根基。一旦他们发现“自己不知道”，构成自信的假设不复存在，自信自然就会快速崩溃。 那大师级的人物又为什么自信呢？有人可能会问，爱因斯坦那样的顶级科学家，不是经常承认自己的“无知”，所以诚惶诚恐、满怀敬畏之心吗？ 我想，那是因为大师的自信是建立在自己的理性上，而非知识上。这里的理性是不是经济学里的“追求利益最大化”，而是指批判性的思维、科学的思维等，是一种认知和思考的方式。 批判性思维批判的对象，不是一个人，甚至不是一个观点，而是一个观点背后的思考过程——它只审视这个思考有多缜密、多系统（学习批判性思维，可以参考我的笔记[6]）。科学的精神其实类似，科学最重要的特点是它可以被证伪，证伪比证实更重要。 前几年网上流传一句话“当科学厉尽艰险攀登至顶峰时，才发现宗教早已高居其上”。有些人会感叹宗教的伟大，但我们必须明白的是：宗教的的结论可能与科学一样，然而科学并不关心结论——科学看重的是方法和过程，科学的结论也未必是正确的结论。 这有点像僵固型思维与成长型思维之间的区别[7]，一个只关注结论，并以已有的结论为基准，试图证明和解释；另一个关注得出结论的过程，并以过程的正误为基准，随时可以推翻结论。 正确的大道理，会讲的人很多，但是却很廉价。 保持理性的思考方式，时刻对自我进行批判和审视，却少有人能做到。 生物学思维复杂性与不可预测对于程序员来说，bug 永远无法彻底消除，因为软件系统中总会有一些脱离他们控制的东西。软件工程越庞大、越复杂，不可控的因素就会越多[8]。 比起使用机器指令或者汇编语言的时代，现在的计算机编程效率有了巨大的进步，各种应用的开发越来越迅速。但是，程序员对于机器的控制程度，整体上也变得越来越低。高级语言中，除了历史最久的 C 语言（以及继承者 C++）可以在微观层面上精确地控制内存，其他追求开发效率的语言大多隔离了程序员对系统底层的控制。 程序员可能并不知道系统如何编译他的源代码，如何运行他的程序。不过至少，编程语言的设计者知道这些，这就足够了。 可是万一……最初的设计者已经失联，而世上已经没有第二个人明白他是如何设计的了，这时，系统运行的环境或条件又发生了意料之外的变化，那会发生什么？ 谁也不知道会发生什么。未来变得不可预测。 2000 年时影响巨大的“千年虫”问题，它的根源就是因为早期的工程师设计的年份只有 2 位数。老一辈工程师退休以后，2000 年的年份运算导致了各种不可预测的 bug。 一个系统的复杂性，随着其部件数量的增多，会呈现指数级的增长，这是因为各部件之间相互联系产生的“级联效应”。而且因为“吸积效应”，系统的复杂性只会越来越高[9]。 所以，理论上如果人类的认知能力不能持续大幅度地提升，上面假设的的情形(世上再也无人知晓系统的内部规则）就一定会发生。 ……事实上，可能已经发生了。（下图截自“甲子光年”的文章。） 人工智能与生物学某种意义上，我们正试图让电脑学习人脑——从经验中构建假设，而不再坚持“绝对正确”。想让计算机能够处理自然语言，就必须不再执着于基于规则的方法，而改为基于统计的方法。《语言、认知背后的信息论》 人们不知道“深度学习”为什么能习得知识，就好像人们不太清楚自己的大脑是如何学习的一样。然而这并不妨碍人们对深度学习技术的应用——因为它已经在某些领域（比如围棋竞技、人脸识别）展现了它的有效性。 事实上人工智能的研究一直存在两大派系，符号主义和联结主义。 符号主义的智能是基于规则和逻辑推理的，它和经典物理学一样，追求精确控制、准确无误，以及可预测、可控制。物理学家拉普拉斯：“假设有一个拥有无穷运算能力的智慧生物，只要它掌握了某一时刻宇宙内所有原子的状态，就能向前、向后推知任意时刻宇宙内所有原子的状态，从而能够得知任意时间任意地点发生的事情。”（那时离海森堡提出“测不准原理”还有大约 100 年。） 而联结主义的智能是基于统计和数据分析的。它的一个经典模型就是人工神经网络，基于大量样本数据对神经网络进行训练，最终可以使用网络模型来解决分类、预测等问题。但是，训练得到的模型并不可控，它的准确性依赖于训练样本，也没有人清楚它的内部规则——“真实”并没有那么重要，人们对其也只是“不求甚解，能用就好”的态度。显然，这是一种不同于物理学思维的生物学思维。 经历过漫长演化、十分多元的生态环境，就是一个极为复杂的系统，人类就是在这个系统中孕育的。 生物学并不是没有规则，只是，它仅仅给最核心的事务制定规则——比如创造 DNA 这种物质。接下来，通过庞大的冗余（不管数量上还是功能上）、持续且自由的进化，换取极强的适应能力。 通过 DNA 结构中 4 组碱基对的排列组合，不但形成了大千世界的无数种生物，而且同种类生物的个体之间也各有差异。DNA 通过自我复制和变异得以延续。DNA 的宿主在不断变化的自然环境中不断被淘汰，以这种方式，在大量的 DNA 中筛选出适应环境的变异体。 人工神经网络也类似。它的核心、它不变的东西是“算法”，其中包含了误差反馈机制，使得它能完成“进化”；它赖以成长的“环境”是大量的数据，通过对数据的不断计算、对误差的不断反馈、对反馈的不断调整，建立与待解决问题相“适应”的模型。 相对于符号主义，联结主义的智能显然更善于应对高复杂度的问题，因为在复杂系统中找出所有规则的成本实在太高了。用自我迭代来适应变化，也不失为一个好的解决方法。 生物学思维的启示灰度认知，有机思维承认复杂性，承认自己的认知是有极限的。然后对世间万物保持灰度的认知——也就是保持在黑与白之间的灰色地带[10]。这是一种脱离了线性思维的有机思维。 菲茨杰拉德说过：“测试是否拥有第一流的智慧，就是要看一个人能否在头脑中同时持有两种对立的想法，并且依然能够保持运转。”苏格拉底也告诉我们，要在两种对立的观点之间保持必要的张力，保持一种半信半疑、又信又疑的态度。（苏格拉底善用“反诘法”，可以算是批判性思维的开山鼻祖。） 今年春节期间，我玩了几天“推理大师”游戏（俗称“剧本杀”）。这个游戏给不同的玩家看不同虚构人物的剧本，然后让玩家一起探讨凶手的身份。每个人看到的剧本都是单个人物的认知，包括他的过往经历、他在案发期间的所作所为。 由于好奇，我常常会把所有人物的剧本都拿来看一遍，然后惊讶地发现：对同一件事物的认知，人与人之间的差别竟然如此之大。我们往往只是看到了自己能看到的，只掌握了部分的信息，却以为那就能得出事情的真相。 就像芥川龙之介的小说《竹林中》所揭示的那样： 人类习惯于希望因果关系是明确的、清晰的、不变的，不喜欢漂移不定的道理。这样，人们才有规律可循，才会觉得心里踏实。但事实上，真相确实是漂移不定的——遇到诱惑，圣人一样会动摇；遇到打击，勇士一样会崩溃。引用自《【人性探秘】开篇》 正因为人们有这种追求确定性的心理，再加上无处不在的信息不对称，所以媒体只须给出“部分真相”，就可以达到操纵民意的目的。 比起纸媒时代的人，生活在互联网时代的我们，每天都能接收海量的信息，知道哪里和哪里又发生了什么大事。但是互联网也无法消除信息不对称，互联网只是降低了信息传播的成本，某种程度上这也降低了信息的质量[11]。互联网时代，信息不再稀缺，但是需要个人具备更强的鉴别能力，以及培养有机的思维。 我虽然这么说，但也不强求人们都有灰度认知的能力。因为，对很多人来说，真理没有那么重要，找到自己生活的意义，解决自己的具体问题才重要。也许网络对他们来说，只不过是寻找自我认同、强化自我价值的一种方式，他们不在乎真真假假，只要对自己有用就行了。 这正是生物学教我们的。 专注不变，不断微调其实说了这么多，目的还是为了解决自己的问题。凡事预则立，不预则废，如何做好一个长期（跨度3年以上）的规划？ 首先我们要弄清楚：什么才是有效的规划。由于我们所处的世界变化飞速、高度复杂，所以不论是谁，几乎都不可能从微观上预测几年后世界的样子。那么，我们就不能用线性的推理做长期规划，而要用生物学的思维—— 一个不变的核心算法，加上大量的反馈和调整。 世界首富、亚马逊的创始人贝索斯，有句经典问题：“什么是未来 10 年都不会改变的东西？”核心算法，一定要稳定且有效。 据说 Facebook 的高管出来做基金，也是大举买入亚马逊而非 Facebook 的股票。因为 Facebook 的成功是用户行为驱动的，而用户行为一直在变；亚马逊的成功是模式驱动的，模式是一个不变量。 贝索斯创立亚马逊时，找到的就是这样一条不变的“增强回路”：更低的商品价格 → 更好的客户体验 → 巨大的流量 → 向供货商进更多的货，形成规模效应 → 低成本结构 → 更低的商品价格。 这个不变量，是方法论，是一切规划的基石，所有调整都建立在它的基础上。找到方法论，是为了让自己能够获得战略上的定力，能够沉下心来，获得专注于一件事情的底气。 有了方法论，还要靠不断刻意练习，将它内化到自己身上。所谓刻意练习就是指在舒适区以外练习，从犯的错误中学习，同时不断对自己的规划进行微调。 上面是得到大学2019春季开学典礼上，舰船工程师孔维玮的演讲截图。军舰的建造是一项周期很长的复杂工程，在建造过程中还会不断涌现出新的技术。为了对新技术做出快速响应，往往会并行地展开几个项目，多层次、短周期地快速迭代升级。 不仅是这种大型建造项目，游戏开发中也会使用相似的架构。 芬兰有一家 200 人的手机游戏公司叫 SuperCell，15 年的年利润接近10亿美元（平均每人贡献了 500 万美元的净收益）。这家公司深刻影响了阿里巴巴，导致后者成立了“中台技术群”。SuperCell 团队内部拥有十几个小团队，每个团队由十几个人组成。这些团队虽然共享“中台”服务（其实就是各种通用的、不变的技术），但是团队内部的决策完全自由，团队之间展开并行的开发、相互竞争，最终做出非常符合市场的优秀手游。 作为个人，也许并没有太多的并行策略可以实施，但是通过对自己过往行为的记录、复盘，通过这种自我观察和反思，也能达到自我进化（吴军说的可叠加式进步）的效果。 限制与抽象与自己的对话寒冬的郊区。一座花园式的院落中，有幢不大不小的房子。地方很偏僻，所以虽然楼房的建筑颇为讲究（院门也只是虚掩着），却门庭冷若，空气中弥漫着萧索和孤寂。偶尔会有那么几个人路过。有人会好奇地向里张望一眼。不过多数时候他们都不会驻足，而是继续赶路。也曾有被宅邸吸引，忍不住进入院中观摩的。幸运的话，他们会进入房中，顺着房屋主人精心布置的线索，来到某个房间跟前。里面，似乎有两人正在谈话，又似乎是一人在自言自语…… 往期文章：与自己的对话（一） 鳌翃惘：老弟，那天凌晨4点，我见你发了条朋友圈。文字中浸满了迷茫和焦虑，甚至还有那么一丝绝望…… 图 无双BaOY_WHA：你说的是上图那条……？别看我平日里的外表一直波澜不惊，但那只是“喜怒不形于色”而已。深入内心，你会看见一个极度悲观、满怀不安全感的我。3年前，我在大学健身社团的一位学长换了血癌，他的一段文字令我感同身受：“其实，很怕被人说坚强。因为我知道，我一点儿也不坚强。我只是不太爱流眼泪，不太表露悲伤而已。我只是在咬牙硬撑着，和坚强搭不上半毛钱的边。……甚至，有些时候，我觉得自己懦弱。……”（《且听窝扯淡》） 鳌翃惘：深入认识一个人很难。不管你（自认为）内心有多么丰富，多数人往往只会用一个标签来认识你。另外，人们也常常忽视环境的作用。谁也看不见风，只能看见风中跳舞的树叶。 无双BaOY_WHA：我曾经用过这句个性签名：一命二运三风水，四积阴德五读书。当时就是为了突出“个人主观努力”的无力感。什么是命？生物层面，每个人的基因不同，这是人生而不平等的物质基础。什么是运？时运，包括时机和运气。除了字面的意思之外，它还有一层意思——每个人都享有时间权和概率权，只是富人懂得利用（金融的本质是时间的魔法和风险的量化），而穷人只知道贱卖自己的这2种权利。什么是风水？就是塑造一个人的环境。我们都知道生物性状由基因和环境共同决定。什么是阴德？就是人脉。《大潜能》这本书论述过集体的力量——一个人裸奔需要极大的勇气，但是一群人就可以轻松做到。《同步》的副标题也很有哲理——“秩序如何从混乱中涌现”。人脉就是为了让更高级的价值“涌现”。最后才轮到“读书”，也就是个人的努力。它虽然重要，但远不如前几项重要。 鳌翃惘：虽然对于改变命运而言，“读书”的作用微不足道，但也聊胜于无，不是吗？ 无双BaOY_WHA：没错。但是读书的天赋也是由命决定的啊。人的强悍在于善于借势、善假于物。改变不了命，就应该尽量改变后面几项，因为这里还是能发挥一些主观能动性的。 鳌翃惘：话说，难道你真的想做一个看门的门卫……？我还听说，你挺羡慕那些“干一天，玩三天”的三和大神……然而你曾经在《由自杀说起》中说过不应该“放弃寻找生命的价值和意义”，而要“勇敢地接受荒诞”，“坚信既是人类的存在是荒诞的，生命的意义依然可以实现”。 无双BaOY_WHA：我羡慕《海边的卡夫卡》里的主角，可以被甲村图书馆收留。图书管理员的工作看上去很不错，有很多闲暇的读书时间。而宿舍的门卫大爷看上去也很闲，同理……事实上，工作并不是实现意义的唯一途径。我甚至担心工作会侵占我的自由时间，使得我没有时间去做真正有意义的事情。我的成功动机只有中等偏上的水平，我的权力欲望和亲和欲望都很低。如果没有太多外界压力，我最希望从事自由职业，并采取闭关式的生活方式。许多牛人在成功之前都采取了“闭关修炼”的方式——导演饺子、李安，《GEB》作者侯世达、《英雄之旅》作者坎贝尔……就连牛顿，他最伟大的思想也是在他（为了躲避瘟疫）回乡下没事干的时候产生的。我更羡慕的是侯世达，他只关心自己感兴趣的研究领域，并且在脱产多年之后做出了瞩目的成就，以至于作为一个教授，他没有被强制教学和发表论文。 鳌翃惘：你看到的这些人只是特例，只是因为“幸存者效应”，他们被你看到了。 无双BaOY_WHA：没错，就像人们所记住的古代战役，多数都是“以弱胜强”的个案。这导致人们往往误读《孙子兵法》里的“以正合，以奇胜”，以为胜利靠的是“奇招险招”。其实奇是“奇数”的奇，意思是多余的兵力。虽然我们看不见他们背后的“命运”（天赋与时运），但是可以学习他们主动选择“环境”的勇气，以及“朝着自己的愿景，坚持不懈地努力”的品质。 鳌翃惘：实在太难了。 无双BaOY_WHA：关键在于寻找正确的方向，以及使用正确的执行方式。想要找到这些，就要不断追问，不断形成“假设→执行→验证”的闭环。 鳌翃惘：就像昨天你做的那个“思想实验”一样追问和假设，是吧？ 无双BaOY_WHA：是的。就说追问，什么是好的问题？我认为好的问题有两种，一种可以帮助自己抽象出“why”，另一种可以帮助自己把问题具体到“how”。前者得到一种（芒格所谓的）“普适”知识，具有归纳性和可延伸性、可扩展性；后者则能把问题变得越来越具体，直到产生出具体解——换句话说，使问题成为可执行的、可实现的问题。做出假设，就是给出限制。人类之所以会产生发明，就是因为有了特定的条件，和有限的问题。 鳌翃惘：嗯，难怪你的“思想实验”中，一开始的问题看上去什么限制都没有，但却根本无从下手。《从祖先到算法》里就提到：在20万年前，人类祖先的智力水平就和现在一样了，为什么直到近几千年才产生高度文明？因为知识的进化和生物的进化一样，是一个不断发现问题、解决问题的过程。某个知识没出现，不是因为人类大脑不够聪明，而是因为人类还没有遇到“能够触发这个知识”的问题。（换句话说，知识的产生其实和生物变异一样，是偶然的。）这本书中的“问题”，其实就是大自然给人类带来的限制。限制，有助于我们找到清晰的道路。 无双BaOY_WHA：知识的产生是偶然的，知识的传播却是必然的。书中说人们通过模仿和效仿传播知识。其中模仿只是对结果的复制，而效仿则是对思考的再现。这里的效仿，很大程度上体现出了人类思维的“抽象”能力。人类的大脑善于从表象中归纳出原因，从因果中抽象出模型，然后不断对这个模型进行验证。验证时如果发现出错，进行反馈和纠正的话，就成了“微创新”。不断重复这个验证、反馈、纠错的过程，就叫做自我迭代。 鳌翃惘：知识的产生，来源于特定问题给出的“限制”；知识的传播，则包含了“抽象”的门道。2星期前，你谈论长期规划，说要寻找可以持续增长的核心不变量，老喻把这个叫做“内核”。内核有两个特征：简单（大概率、可复制、大规模）；有构建系统的潜力。似乎，“简单”就是限制和抽象出的“核心不变量”，而“系统”则是指“可以持续增长”。 无双BaOY_WHA：嗯，“限制”和“抽象”算是我哲学体系的一部分吧。我们通过“限制”和“抽象”来追问“why”和“how”，把追问得到的答案当成假设来进行验证，不断迭代，或许就可以找到“正确的方向”、“正确的执行方式”。我为此还画了一张图： 图 鳌翃惘：面对眼前的具体的问题，探险者不得不沿着迂回的道路前进；而夜空中的北极星，时刻提醒着他不要迷失方向。看上去还是太简单了。 无双BaOY_WHA：在《漫谈有字、无字、心灵之书》里讲过：就如围棋讲究轻、重、厚、薄：虽然薄弱，机会却多；固然厚实，负担却重……把握好“度”对我们个人来说才是最重要的。棋手需要判断的是，各种可能性之间的利弊得失。而影响判断标准的则是不同的局势、不同的阶段。 鳌翃惘：跳出人生的棋局，做自己的旁观者。你我都要抓住人生中每一个阶段的主要矛盾，具体问题具体分析，这样才能对自己的人生稍微多一些掌控感。 无双BaOY_WHA：从旁观者的角度，确实比较容易分析“每一阶段的主要矛盾是什么”——这也许可以看作是“目标”，它是阶段性的。不同阶段的目标排列在一起，指向最终的那个“愿景”。 这些不知所谓的对话“漂浮”在上下文中，犹如冰山露在海面之上的部分。由于看不到全貌，访客们不得不对其做出自己的解释。于是，思考再现。 凌乱的笔记why what how 有关：高中数学和高中物理学习方法（管理学）编程 logic what, control how 知识的进化，和生物的进化一样。它都是一个不断发现问题，解决问题的过程。这个知识没出现，不是因为大脑不够聪明，而是因为，人类还没有遇到，能够触发这个知识的问题。知识世界不是由领域来划分的，而是由挑战来构成的。 追问（越来越具体，越细化），直到变成 可执行的 how 问题（puzzle） 变得“具体”、“细化”的关键在于：限制 《罪恶之城》导演的第一部作品，就是限制生物学中的“代偿”效应，本质上是资源限制促成了强大。 程序的流程控制，就是限制。封装 就是限制。 契约 就是限制。 主动“吃苦”（受穷是被动）意志，内控，思考率。博客上的那句话就是自勉。 信息不对称→歧视 意志力，自律：社会激励、及时奖励与进度监控。 成洁：做减法，休息，片段专注，自我观察。 柳比歇夫一天专注时间4～6小时？睡觉10小时。记录、复盘，就是自我观察。 复盘目的：形成认知闭环。 管理年轻人：任务清晰，目标分解，即时反馈，及时鼓励。 刻意练习——有反馈，形成闭环。练习什么最有效？反脆弱的事情，比如说相声。宁向东：近30才留学，为了突破语言障碍，整天坐在礼堂听大课，直至能靠本能感受到语言从整片变成了一字一字。“读书百遍，其义自见”。大一高数老师也说过“读书百遍，其义自见”，她举的是抄书的例子。 商鞅的思想具有特定时期的意义。其实商鞅先是以尧舜禹汤的“帝道”、文王武王的“王道”游说秦孝公，可是得不到采纳，才换成了可以速成的“霸道”。之后有人问他：“既然你知道大王的心思是富国强兵、称霸诸侯，为什么前两次还要和他谈帝道、王道？”商鞅说：“我是怕如果他真实一个有大志向的人，我一开始就说那些低层面的事情，把他看低了。……这样一来（急功近利），国运终究不可能超过商朝和周朝。”治国必须构建一套人们共同相信的价值体系。孔子推崇周礼，也是为了治理国家，“刑不上大夫，礼不下庶人”，用礼来约束统治阶层，用“神道设教”骗百姓安心做良民。民主社会推行的价值观，本质上也是虚构的，自由和平等这两个概念本身互相冲突（比如面对难民问题）。只不过，面对不同的情况，国家的治理方法要作出相应调整。比如，秦朝统一之后仍然采取严苛的法令，就导致陈胜吴广因为“失期，法皆斩”而揭竿起义。 引用[1]《为什么懂得很多道理，却依旧过不好这一生》[2]参考《科技发展的量变能否产生质变？》中的“复杂性牢笼”这一部分。[3]参考《铅笔的故事蕴含的经济学原理》[4]刘润《比频繁跳槽更可怕的，是把系统能力当成个人能力》[5]以下摘自公众号“L先生说”： 自动化：如果需要大量机械化步骤，能否搭建一个工作流（VBA、Python、宏等），实现自动化处理？ 模板化：如果需要频繁沟通、传递信息，能否制作一套模板，将信息结构化，最大限度避免遗漏和误解？ 流程化：如果一项工作的步骤非常繁琐，能否设计一套流程，降低注意力和认知资源的消耗？ 模块化：如果一项工作需要多种技能，能否创建一套模块，可以灵活搭配、自由组合？ [6]《得到&lt;批判性思维15讲&gt;笔记》[7]《防御性思维——陈海贤自我发展心理学（四）》[8]复杂性可以分为两个层次。一是理解上的复杂，受系统规模和结构的影响；二是预测上的复杂，受各种变化的影响。[9]“吸积效应”的概念出自《为什么需要生物学思维》一书。[10]《认知可以灰度，但决策只能黑白》[11]根据经济学的需求第三定律（“好东西运到远方去定律”）：以前信息传播的成本高，人们更愿意传播高质量信息（精选品）。而如今，互联网降低了信息传播的成本，导致低质量信息（普通品）更容易被传播。]]></content>
      <categories>
        <category>扯淡杂文</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程范式】面向对象编程]]></title>
    <url>%2F2019%2F07%2F28%2F%E3%80%90%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E3%80%91%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[函数式编程把一些功能或逻辑代码通过函数拼装起来。代码中处理的数据，就是所谓的“状态”。函数式编程要求我们写出无状态的代码。但是天下并不存在没有状态、没有数据的代码。 我们很熟悉的面向对象编程（Object-oriented programming, OOP）有三大特性：封装、继承和多态。 介绍一些常识我就不摘录了，但不得不提的是《设计模式：可复用面向对象软件的基础》一书，在此书中共收录了 23 种设计模式。 这本书的 23 个经典的设计模式，基本上就是说了两个面向对象的核心理念： “Program to an ‘interface’, not an ‘implementation’.”面向“接口”编程，而不是“实现”。 使用者不需要知道数据类型、结构、算法的细节。 使用者不需要知道实现细节，只需要知道提供的接口。 利于抽象、封装、动态绑定、多态。 符合面向对象的特质和理念。 “Favor ‘object composition’ over ‘class inheritance’.”“对象组合”优于“类继承”。 继承需要给子类暴露一些父类的设计和实现细节。 父类实现的改变会造成子类也需要改变。 我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。 继承更多的应该是为了多态。 示例一：拼装对象有如下描述： 四个物体：木头桌子、木头椅子、塑料桌子、塑料椅子 四个属性：燃点、密度、价格、重量 怎么用面向对象的方式来设计我们的类呢？ 材质类 Material。属性：燃点，密度。被 Wood 和 Plastic 类继承。 家具类 Furniture。属性：价格，体积。被 Table 和 Chair 类继承 在家具类中耦合了材质类。而具体材质是 Wood 还是 Plastic，这在构造对象的时候注入到 Furniture 里就好了。 在家具类中，通过材质的密度属性和家具的体积属性就可以计算出重量属性。 它和现实世界相对应，而且材质是可重用的。这个模式（桥接模式）还表现了面向对象拼装数据的另一个精髓——喜欢组合，而不是继承。 示例二：拼装功能需求：处理电商系统中的订单。一个关键的动作是计算订单的价格。有的订单需要打折，有的则不打折。 假设我们用 Java 语言，我们需要先写一个接口（使用 interface 关键字）——BillingStrategy，其中一个方法就是GetActPrice(double rawPrice)，输入一个原始价格，输出一个根据相应策略计算出来的价格。 这个接口只是对接口的抽象，与实现无关。我们用 class NormalStrategy implements BillingStrategy 和 class HappyHourStrategy implements BillingStrategy 对这个接口进行两个策略的实现。 我们封装订单项 OrderItem，它包含每个商品的原始价格和数量，以及价格计算的策略。然后，在订单类 Order 中封装 OrderItem 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 BillingStrategy。 定价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，有很高的灵活度。剩下的就是交给运营人员来配置不同的商品使用什么样的价格计算策略。 这个设计模式叫策略模式。这是设计模式中最为经典的模式，充分体现了面向对象编程的方式。 注意：现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的 pipeline 或 decorator 就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。 示例三：资源管理123456789mutex m;void foo() &#123; m.lock(); Func(); if ( ! everythingOk() ) return; ... ... m.unlock();&#125; 上面的代码有问题：if 语句返回时没有把锁给 unlock 掉。但是，在所有函数退出的地方都要加上 m.unlock(); 语句，会让我们很难维护代码。于是，我们先设置一个代理类： 1234567class lock_guard &#123;private: mutex &amp;_m;public: lock_guard(mutex &amp;m):_m(m) &#123; _m.lock(); &#125; ~lock_guard() &#123; _m.unlock(); &#125;&#125;; 然后就可以这样写了： 12345678910mutex m;void foo() &#123; lock_guard guard(m); Func(); if ( ! everythingOk() ) &#123; return; &#125; ... ...&#125; 这是 C++ 中的一个利用了面向对象的技术，叫 RALL（直译：资源获取就是初始化）。这个模式叫做代理模式，我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后只需要关注业务逻辑代码了。在业务逻辑代码中，减少了与业务逻辑不相关的程序控制代码。 IoC 控制反转在上面的示例中： 我们使用接口抽象了具体的实现类。 然后其它类耦合的是接口而不是实现类。这就是多态，其增加了程序的可扩展性。 因为这就是接口编程，所谓接口也就是一种“协议”，就像 HTTP 协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解除依赖关系，而去依赖于一个标准的协议。 这就是面向对象的编程范式的精髓！同样也是 IoC/DIP（控制反转 / 依赖倒置）的本质。 IoC 技术描述（百度百科、维基百科）： Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。 举例略。所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，开关从依赖设备这种情况，变成了设备反过来依赖于开关所定义的接口。 这样的例子在生活中太多见了，比如说钱就是一个很好的例子。所谓“钱”其实就是一种交易协议，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。这就是反转控制。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。 这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。 我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。 这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口…… 通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。总而言之，我们就是想通过一种标准来让业务更为规范。 总结面向对象优缺点优点： 能和真实的世界交相辉映，符合人的直觉。 面向对象和数据库模型设计类型，更多地关注对象间的模型设计。 强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。 根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。 拥有大量非常优秀的设计原则和设计模式。 S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP…… 缺点： 代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。 代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。 因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程范式】函数式编程]]></title>
    <url>%2F2019%2F07%2F25%2F%E3%80%90%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E3%80%91%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Functional Programming核心思想：将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做（声明式）。 λ 演算是一套用于研究函数定义、函数应用和递归的形式系统。 Alonzo 说，像 boolean、intergers 或者其他的数据结构都可以被函数取代掉。 特性对于函数式编程来说，它只关心定义输入数据和输出数据相关的关系，数学表达式里面其实是在做一种映射（mapping），输入的数据和输出的数据关系是什么样的，是用函数来定义的。 函数式编程有以下特征： stateless：函数不维护任何状态。它不存在状态。 immutable：输入数据是不能动（不可变）的，要返回新的数据集。 优势： 没有状态就没有伤害。 并行执行无伤害。 Copy-Paste 重构代码无伤害。 函数的执行没有顺序上的问题。 有以下好处： 惰性求值。这需要编译器的支持，表达式不在它被绑定到变量之后就立即求值，而是在该值被取用的时候求值。 确定性。同一个参数，在不同的场景下会计算出相同的结果。所谓不同的场景，就是我们的函数会根据运行中的状态信息的不同而发生变化。 我们知道，因为状态，在并行执行和 copy-paste 时引发 bug 的概率是非常高的，所以没有状态就没有伤害，就像没有依赖就没有伤害一样，并行执行无伤害，copy 代码无伤害，因为没有状态，代码怎样拷都行。 劣势：数据复制比较严重。（不见得会导致性能不好，因为没有状态，代码可以拼命地并发，反而让性能很不错，Erlang 就是其中的代表。） 1234int cnt;void increment()&#123; cnt++;&#125; 这个函数调用了全局变量，这个函数就是有外部状态的。如果是多线程，这个代码不安全。如果写成纯 pure function函数，应该是下面这样： 123int increment(int cnt)&#123; return cnt++;&#125; 代码随便拷，而且与线程无关。并行的时候不用锁，因为是复制了原有的数据并返回了新的数据。 各个语言对纯函数式（即完全没有状态的函数）的支持程度如下： 完全纯函数式 Haskell 容易写纯函数 F#, Ocaml, Clojure, Scala 纯函数需要花点精力 C#, Java, JavaScript 函数式编程和过程式编程的思维方式完全不一样。函数式编程的抽象度更大，在实现方式上，有函数套函数、函数返回函数、函数里定义函数…… 用到的技术 first class function（头等函数）：让函数像变量一样来使用。 tail recursion optimization（尾递归优化）：递归太深会导致 stack 受不了，并导致性能大幅度下降。支持尾递归优化就是每次递归都会重用 stack，这样能够提升性能。有的语言或编译器不支持，如 Python。 map &amp; reduce：函数式编程最常见的技术就是对一个集合做 Map 和 Reduce 操作。很像 C++ STL 中 foreach、find_if、count_if 等函数的玩法。 pipline（管道）：将函数实例成一个个 action，然后组成一个 action list，再传入数据。数据就像一个 pipline 一样顺序地被各个函数所操作。 recursing（递归）：递归最大的好处是简化代码。精髓在于描述问题，这也正是函数式编程的精髓。 currying（柯里化）：将一个函数的多个参数分解成多个函数，这样可以简化函数的多个参数。很像 C++ STL 中的 bind1st 或 bind2nd。 higher order function（高阶函数）：就是把函数当参数，把传入的函数做一个封装，然会返回封装后的函数。现象上就是函数传入传出。用来做 Decorator 很不错。 体会函数式编程的理念： 12345678910def inc(x): def incx(y): return x+y return incx inc2 = inc(2)inc5 = inc(5) print inc2(5) # 输出 7print inc5(5) # 输出 10 我们可以看到，inc()函数返回了另一个函数incx()，于是可以用inc()函数来构造各种版本的 inc 函数，比如：inc2()和inc5()。这个技术其实就是上面所说的 currying 技术。 理念：把函数当成变量来用，关注描述问题而不是怎么实现。（Describe what to do, rather than how to do it.） 典型代表：Lisp 语言，它的数据和函数都是采用符号表达式定义的。 函数式编程的思维方式以前的过程式编程范式，被称作 Imperative Programming——指令式编程；函数式编程范式，被称作 Declarative Programming——声明式编程。 用 Python 解决一个问题： 有 3 辆车比赛，简单起见，这 3 辆车分别有 70% 的概率和 5 次机会往前走一步。打出每一次这 3 辆车的前行状态。 指令式的写法1234567891011121314151617from random import random time = 5car_positions = [1, 1, 1] while time: # decrease time time -= 1 print &apos;&apos; for i in range(len(car_positions)): # move car if random() &gt; 0.3: car_positions[i] += 1 # draw car print &apos;-&apos; * car_positions[i] 我们可以把这两重循环变成一些函数模块，这样更容易阅读代码： 1234567891011121314151617181920212223242526from random import random def move_cars(): for i, _ in enumerate(car_positions): if random() &gt; 0.3: car_positions[i] += 1 def draw_car(car_position): print &apos;-&apos; * car_position def run_step_of_race(): global time time -= 1 move_cars() def draw(): print &apos;&apos; for car_position in car_positions: draw_car(car_position) time = 5car_positions = [1, 1, 1] while time: run_step_of_race() draw() 对于指令式编程来说，我们把一个问题的解决逻辑拆分成一些函数模块，这样有利于更容易地阅读代码——将代码逻辑封装成了函数之后，相当于给每个相对独立的逻辑取了个名字，于是代码成了自解释的。 但是，封装成函数后，这些代码都会依赖于共享的变量来同步其状态。在读代码时，我们在函数里读到访问了一个外部变量的时候，就要马上去查看这个变量的上下文，然后在大脑里推演这个变量的状态，才能知道程序的真正逻辑。也就是说，这些函数必须知道其它函数是怎么修改它们之间的共享变量的。所以，这些函数是有状态的。 函数式的写法有状态，对于代码重用、代码并行，都有副作用。函数式编程范式可以把这些状态搞掉。 123456789101112131415161718192021222324from random import random def move_cars(car_positions): return map(lambda x: x + 1 if random() &gt; 0.3 else x, car_positions) def output_car(car_position): return &apos;-&apos; * car_position def run_step_of_race(state): return &#123;&apos;time&apos;: state[&apos;time&apos;] - 1, &apos;car_positions&apos;: move_cars(state[&apos;car_positions&apos;])&#125; def draw(state): print &apos;&apos; print &apos;\n&apos;.join(map(output_car, state[&apos;car_positions&apos;])) def race(state): draw(state) if state[&apos;time&apos;]: race(run_step_of_race(state)) race(&#123;&apos;time&apos;: 5, &apos;car_positions&apos;: [1, 1, 1]&#125;) 依然是把程序的逻辑分成了函数，不过这些函数都是函数式的。它们之间没有共享的变量；函数间通过参数和返回值来传递数据；在函数里没有临时变量。并且，for 循环被递归取代了，而递归的本质就是描述问题是什么。 函数式语言的三件套Map, Reduce, Filter：它们不关心输入数据，它们只是控制，并不是业务。控制是描述怎么干，而业务是描述要干什么。 需求示例：把一个字符串数组中的字符串都转成小写（Python）。 12345# 传统的非函数式upname =[&apos;HAO&apos;, &apos;CHEN&apos;, &apos;COOLSHELL&apos;]lowname =[] for i in range(len(upname)): lowname.append( upname[i].lower() ) 123456# 函数式def toUpper(item): return item.upper() upper_name = map(toUpper, [&quot;hao&quot;, &quot;chen&quot;, &quot;coolshell&quot;])print upper_name # 输出 [&apos;HAO&apos;, &apos;CHEN&apos;, &apos;COOLSHELL&apos;] 再看一个对比示例： 12345678910111213# 计算数组中正数的平均值num = [2, -5, 9, 7, -2, 5, 3, 1, 0, -3, 8]positive_num_cnt = 0positive_num_sum = 0for i in range(len(num)): if num[i] &gt; 0: positive_num_cnt += 1 positive_num_sum += num[i] if positive_num_cnt &gt; 0: average = positive_num_sum / positive_num_cnt print average 123# 计算数组中正数的平均值positive_num = filter(lambda x: x&gt;0, num)average = reduce(lambda x,y: x+y, positive_num) / len( positive_num ) 隐藏了数组遍历并过滤数组控制流程的 filter 和 reduce，不仅让代码更为简洁，因为代码里只有业务逻辑了，而且让我们能更容易地理解代码。 数据集、对数据的操作和返回值都放在了一起。 没有了循环体，就可以少了些临时用来控制程序执行逻辑的变量，也少了把数据倒来倒去的控制逻辑。 代码变成了在描述你要干什么，而不是怎么干。 函数式的 pipline 模式设计哲学：让每个功能就做一件事，并把这件事做到极致，软件或程序的拼装就会变得更为简单和直观。它影响深远，包括今天的 Web Service、云计算、大数据的流式计算等。 pipline（管道）借鉴 Unix Shell 的管道操作——把若干个命令串起来，前面命令的输出成为后面命令的输入，如此完成一个流式计算。 比如如下的 shell 命令：1ps auwwx | awk &apos;&#123;print $2&#125;&apos; | sort -n | xargs echo 抽象成函数式的样子（反过来，一层套一层）：1xargs( echo, sort(n, awk(&apos;print $2&apos;, ps(auwwx))) ) 当然，也可以把函数放进数组里，然后顺序执行：1pids = for_each(result, [ps_auwwx, awk_p2, sort_n, xargs_echo]) 如果把函数比作微服务，管道就像是在做服务的编排。 实现 pipline 的简单示例一个程序的 process() 有三个步骤： 找出偶数； 乘以3； 转成字符串返回。 传统的非函数式实现如下： 123456789101112131415161718192021222324def process(num): # filter out non-evens if num % 2 != 0: return num = num * 3 num = &apos;The Number: %s&apos; % num return num nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] for num in nums: print process(num) # 输出：# None# The Number: 6# None# The Number: 12# None# The Number: 18# None# The Number: 24# None# The Number: 30 函数式的 pipline（第一种方式）怎么写？ 先把三个“子需求”写成函数，然后再把这三个函数串起来： 123456789101112131415161718192021def even_filter(nums): for num in nums: if num % 2 == 0: yield numdef multiply_by_three(nums): for num in nums: yield num * 3def convert_to_string(nums): for num in nums: yield &apos;The Number: %s&apos; % numnums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]pipeline = convert_to_string(multiply_by_three(even_filter(nums)))for num in pipeline: print num# 输出：# The Number: 6# The Number: 12# The Number: 18# The Number: 24# The Number: 30 上面，我们动用了 Python 的关键字 yield，它是一个类似 return 的关键字，只是这个函数返回的是 Generator（生成器）。 所谓生成器，指的是 yield 返回的是一个可迭代的对象，并没有真正的执行函数。也就是说，只有其返回的迭代对象被迭代时，yield 函数才会真正运行，运行到 yield 语句时就会停住，然后等下一次的迭代。这就是 lazy evluation（懒惰加载）。 好了，根据前面的原则——“使用 Map &amp; Reduce，不要使用循环”（使用循环会让我们只能使用顺序型的数据结构），那我们用比较纯朴的 Map &amp; Reduce 吧： 1234567891011121314151617def even_filter(nums): return filter(lambda x: x%2==0, nums) def multiply_by_three(nums): return map(lambda x: x*3, nums) def convert_to_string(nums): return map(lambda x: &apos;The Number: %s&apos; % x, nums) nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]pipeline = convert_to_string( multiply_by_three( even_filter(nums) ) )for num in pipeline: print num 上面的代码变得更易读了，但是需要嵌套使用函数。如果能向下面这样就好了（第二种方式）： 123456pipeline_func(nums, [even_filter, multiply_by_three, convert_to_string])def pipeline_func(data, fns): return reduce(lambda a, x: x(a), fns, data) 当然，使用 Python 的 force 函数以及 decorator 模式可以把上面的代码写得更像管道： 12345678910111213141516171819202122232425262728293031323334class Pipe(object): def __init__(self, func): self.func = func def __ror__(self, other): def generator(): for obj in other: if obj is not None: yield self.func(obj) return generator() @Pipedef even_filter(num): return num if num % 2 == 0 else None @Pipedef multiply_by_three(num): return num*3 @Pipedef convert_to_string(num): return &apos;The Number: %s&apos; % num @Pipedef echo(item): print item return item def force(sqs): for item in sqs: pass nums = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] force(nums | even_filter | multiply_by_three | convert_to_string | echo) 小结相对于计算机发展史，函数式编程是个非常古老的概念，它的核心思想是将运算过程尽量写成一系列嵌套的函数调用，关注的是做什么而不是怎么做，因而被称为声明式编程。 以 Stateless（无状态）和 Immutable（不可变）为主要特点，代码简洁，易于理解，能便于进行并行执行，易于做代码重构，函数执行没有顺序上的问题，支持惰性求值，具有函数的确定性——无论在什么场景下都会得到同样的结果。 本文结合递归、map 和 reduce，以及 pipeline 等技术，对比了非函数式编程和函数式编程在解决相同问题时的不同处理思路，让你对函数式编程范式有了清晰明确的认知。并在文末引入了 decorator（修饰器），使得将普通函数管道化成为一件轻而易举的事情。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【编程范式】泛型编程（以C/C++为例）]]></title>
    <url>%2F2019%2F07%2F23%2F%E3%80%90%E7%BC%96%E7%A8%8B%E8%8C%83%E5%BC%8F%E3%80%91%E6%B3%9B%E5%9E%8B%E7%BC%96%E7%A8%8B%EF%BC%88%E4%BB%A5C-C-%E4%B8%BA%E4%BE%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[通过对编程范式的了解，不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能。 C++ 中的 STL 是泛型编程（Generic Programming）的代表。 从 C 语言开始C 语言历史悠久，现在看到的几乎所有编程语言都是以 C 语言为基础来扩展的。 大多数 C Like 编程语言其实都是在改善 C 语言带来的问题。 设计目标和理念总体来说，C 语言设计目标是提供一种能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行的编程语言。C 语言也很适合搭配汇编语言来使用。 C 语言的理念是： 相信程序员； 不会阻止程序员做任何底层的事； 保持语言最小和最简的特性； 保证 C 语言最快的运行速度，哪怕牺牲移植性。 像 C 语言这样的过程式编程语言的优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用效率较高的程序。 C 语言特性的简单总结 静态弱类型，使用变量时需要声明变量类型，但是类型建有隐式转换； 不同的变量类型可以用结构体组合在一起，以此声明新的数据类型； 可以用 typedef 关键字来定义类型的别名，以此达到变量类型的抽象； 是有结构化程序设计、具有变量作用域以及递归功能的过程式语言； 传递参数一般以值传递，也可以传递指针； 通过指针可以容易地对内存进行低级控制，然而这加大了编程的复杂度； 编译预处理让 C 语言的编译更具有弹性，比如跨平台。 这些特性让程序员在微观层面的操作非常精准，可以在底层和系统细节上非常自由、灵活、精确地控制代码。 然而在代码组织和功能编程上，上述特性就不那么美妙了。 静态语言最糟糕的问题数据类型就好像螺帽，有多种：平口的、十字的、六角的。而螺丝刀就像函数，或是操作这些螺丝的算法或代码。而且螺丝还有不同的尺寸（比如整型的 int, long, …）。与之匹配的工具的复杂度很高。 这就是类型为编程带来的问题。 通过一种更为通用的方式，即抽象和隔离，可以让复杂的世界变得简单一些。 要做到抽象，对于 C 语言这样的类型语言来说，首先要抽象类型——就是泛型。 C 语言的泛型C 语言的类型泛型基本上就是使用 void* 关键字或是使用宏定义。 void*一个使用 void* 泛型的 swap 函数：1234567void swap(void* x, void* y, size_t size)&#123; char tmp[size]; memcpy(tmp, y, size); memcpy(y, x, size); memcpy(x, tmp, size);&#125; 这个是实现方式有三个重点： 加上类型长度的标识参数 size。因为类型被抽象掉，编译器不能通过类型得到类型的尺寸。增加了接口复杂度。 函数实现中使用了 memcpy 函数。因为类型被抽象掉，不能用赋值表达式，只能用内存复制的方法。 函数实现中使用了 temp[size] 数组。 C 语言的类型抽象，使编程复杂度提升。 同时，还有问题。比如，交换两个 char* 类型，x 和 y 参数就要用 void** 了。 宏定义123456#define swap(x, y, size) &#123;\ char temp[size]; \ memcpy(temp, &amp;y, size); \ memcpy(&amp;y, &amp;x, size); \ memcpy(&amp;x, temp, size); \&#125; 带来问题：编译器做字符串替换，导致代码膨胀，进而导致编译出的执行文件比较大。 最大的一个问题：可能会有重复执行。如以下代码：1234#define min(x, y) （(x)&gt;(y) ? (y) : (x)）min(i++, j++) // i++ j++会被调用两次min(foo(), bar()) // foo() bar() 被调用两次 而且，这种泛型太宽松，完全不检查类型，直接拷贝内存，比较危险。 更为复杂的数据结构泛型数据类型的自适应已经够复杂的了，数据结构的自适应会把这个事的复杂度搞高上几个数量级。 语言问题小结 一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来其它的很多问题。 适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。 算法其实是在操作数据结构，而数据则是放到数据结构中的，所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升，比如，容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型；再比如，对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。 最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来的。而如何平衡和选择，并没有定论，也不好解决。 C++ 语言随着认知的升级，面向过程的 C 语言无法满足更高层次编程的需要，于是 C++ 出现了。 1980 年，AT&amp;T 贝尔实验室。推荐《C++语言的设计和演化》，作者是语言创建者本人。 C++ 解决了很多C 的问题和不方便，参考《C++的坑真的多吗？》。 C++ 泛型编程C++ 是支持编程范式最多的一门语言。它最大的意义是解决了 C 语言的泛型编程问题。 理想情况下，算法应该是与数据结构及类型无关的，只关心一个标准的实现。 一个良好的泛型编程要解决如下问题： 算法的泛型； 类型的泛型； 数据结构（数据容器）的泛型。 C++ 如何有效解决泛型问题？ 类 构造函数、析构函数，表示类的分配和释放。 拷贝构造函数，表示对内存的复制。 重载操作符。 这样，通过类就能让用户自定义的数据类型和内建的数据类型很一致了。 模板 模板有点像 DSL，的特化会根据使用者的类型在编译时期生成那个模板的代码。 模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时带来的问题。 通过模板，取代了 C 时代的宏定义。 虚函数和运行时类型识别 虚函数带来的多态在语义上可以支持“同一类”的类型泛型。 运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。 通过这些，可以写出基于抽象类型的借接口。 C++ 泛型编程示例实现一个遍历算法的泛型。 使用模板技术来抽象类型，这样可以写出与类型无关的数据结构（数据容器）。 使用一个迭代器来遍历或是操作数据结构内的元素。 C 语言的代码：123456789int search(void* a, size_t size, void* target, size_t elem_size, int(*cmpFn)(void*, void*) )&#123; for(int i=0; i&lt;size; i++) &#123; if ( cmpFn (a + elem_size * i, target) == 0 ) return i; &#125; return -1;&#125; C++泛型版的代码：123456789template&lt;typename T, typename Iter&gt;Iter search(Iter pStart, Iter pEnd, T target) &#123; for(Iter p = pStart; p != pEnd; p++) &#123; if ( *p == target ) return p; &#125; return NULL;&#125; 在 C++ 的泛型版本中，我们可以看到： 使用typename T抽象了数据结构中存储数据的类型。 使用typename Iter，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了不同类型的数据结构。 然后，我们对数据容器的遍历使用了Iter中的++方法，这是数据容器需要重载的操作符，这样通过操作符重载也就泛型掉了遍历。 在函数的入参上使用了pStart和pEnd来表示遍历的起止。 使用*Iter来取得这个“指针”的内容。这也是通过重载 * 操作符来达到取值的泛型。 当然，你可能会问，为什么我们不用标准接口Iter.Next()取代++， 用Iter.GetValue()来取代*，而是通过重载操作符？其实这样做是为了兼容原有 C 语言的编程习惯。 重要技术 - 迭代器如何解决泛型函数中T result = 0 前面这个类型 T 的问题？ 在调用者使用vector&lt;int&gt;::iterator这样的声明时，数据类型int已经被传入Iter中了。 我们要精心地设计一个迭代器，下面是一个精简版（C++ STL 代码里的迭代器代码很多很复杂）： 12345678910111213141516171819202122232425template &lt;class T&gt;class container &#123;public: class iterator &#123; public: typedef iterator self_type; typedef T value_type; typedef T* pointer; typedef T&amp; reference; reference operator*(); pointer operator-&gt;(); bool operator==(const self_type&amp; rhs)； bool operator!=(const self_type&amp; rhs)； self_type operator++() &#123; self_type i = *this; ptr_++; return i; &#125; self_type operator++(int junk) &#123; ptr_++; return *this; &#125; ... ... private: pointer _ptr; &#125;; iterator begin(); iterator end(); ... ...&#125;; 几个关键点： 首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。 它需要重载一些操作符，比如：取值操作*、成员操作-&gt;、比较操作==和!=，还有遍历操作++，等等。 然后，还要typedef一些类型，比如value_type，告诉我们容器内的数据的实际类型是什么样子。 还有一些，如begin()和end()的基本操作。 我们还可以看到其中有一个pointer _ptr的内部指针来指向当前的数据（注意，pointer就是 T*）。 如何解决泛型函数中T result = 0 后面这个0（初始化）的问题？算法没办法搞定，只能让用户传入。 求和的泛型函数如下：12345678910template &lt;class Iter&gt;typename Iter::value_typesum(Iter start, Iter end, T init) &#123; typename Iter::value_type result = init; // 这是关键，解决了 T result = 0 的所有问题 while (start != end) &#123; result = result + *start; start++; &#125; return result;&#125; 更高维度的抽象上面的求和函数，让它的业务逻辑不局限于求和（与业务逻辑分离），抽象度更高： 123456789template&lt;class Iter, class T, class Op&gt;T reduce (Iter start, Iter end, T init, Op op) &#123; T result = init; while ( start != end ) &#123; result = op( result, *start ); // 把迭代器的值交给 op 函数来操作。 start++; &#125; return result;&#125; 可以使用这个reduce函数和其他函数以期实现更为复杂的功能。 比如，定义一个函数对象counter。这个函数需要一个Cond函数对象，用来做条件判断。 123456template&lt;class T, class Cond&gt;struct counter &#123; size_t operator()(size_t c, T t) const &#123; return c + (Cond(t) ? 1 : 0); &#125;&#125;; 然后，用reduce和counter共同打造counter_if算法（当条件满足的时候，就记个数）： 1234template&lt;class Iter, class Cond&gt;size_t count_if(Iter begin, Iter end, Cond c)&#123; return reduce(begin, end, 0, counter&lt;Iter::value_type, Cond&gt;(c));&#125; 至于是什么样的条件（Cond），这个属于业务逻辑，应该交给使用方。 函数式编程里，可以用很多像 reduce 这样的函数来完成更多的像 STL 里的count_if这样有具体意义的函数。 类型系统和泛型的本质我们通过 C++ 了解了底层静态类型语言的泛型编程原理。 在动态类型语言或是某些有语法糖支持的语言中，那个 swap() 或 search() 函数的泛型可以很简单地实现。 编程世界中，我们需要处理好两类事： 语言中的类型问题； 对真实世界中业务代码的抽象、重用和拼装。 类型系统一般，编程语言中会有两种类型：内建类型、抽象类型。 不同语言之间类型系统主要的差异，在于编译时期的语法，以及运行时期的操作方式。 程序语言的类型系统提供以下主要功能： 程序语言的安全性。使用类型可以让编译器侦测一些代码的错误。 利于编译器的优化。编译器可以利用类型声明的信息做很多优化工作，例如 int 类型会以 4 个字节的整数倍进行对齐。 代码的可读性。有类型，语义更清晰，代码更易读和更易维护。 抽象化。类型是对底层内存布局的一个抽象。类型允许程序员对程序以高层次的方式思考，而不是烦人的低层次实现。 类型带来的问题：我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。 对此，世界上出现了两类语言，一类是静态类型语言，如 C、C++、Java，一类是动态类型语言，如 Python、PHP、JavaScript 等。 动态类型语言中，会以类型标记维持程序所有数值的“标记”，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。 无论哪种语言，都避免不了一个特定的类型系统。哪怕是动态类型语言，我们在读代码时，也要脑补某个变量在运行时的类型。所以，每个语言都需要一个类型检查系统。动态类型语言的代码中可以看到大量类似 typeof 这样的类型检查代码。 泛型的本质类型的本质： 对内存的一种抽象。不同类型，有不同的内存分布和内存分配的策略。 对不同的类型的操作是不同的。有些类型还有特有的操作。 所以，要做到泛型，需要做以下事情： 标准化掉类型的内存分配、释放和访问。 标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作…… 标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法…… 标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作…… 所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标： 通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。 通过重载操作符，可以标准化类型的比较等操作。 通过 iostream，标准化了类型的输入、输出控制。 通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。 通过迭代器来标准化数据容器的遍历操作。 通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。 通过函数式（函数对象），来标准化对于不同类型的特定操作。 泛型的本质就是——屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。 小结在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。 但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了些负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。 我们需要清楚地明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。 所以，不同的语言在设计上都会做相应的取舍，比如 C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。C++ 则是两者都想要，导致语言在设计上非常复杂。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>C/C++</tag>
        <tag>编程范式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2019上半年的流水账生活记录整理]]></title>
    <url>%2F2019%2F07%2F22%2F2019%E4%B8%8A%E5%8D%8A%E5%B9%B4%E7%9A%84%E6%B5%81%E6%B0%B4%E8%B4%A6%E7%94%9F%E6%B4%BB%E8%AE%B0%E5%BD%95%E6%95%B4%E7%90%86%2F</url>
    <content type="text"><![CDATA[本总结的依据是我的一个本子，上面有我每天所做事情的简单记录。 1月事件： 去了中关村创业大街的车库咖啡，下午工作，晚上和 BOSS Xiang 4 个人一起吃米粉。 24日回家，近乎感冒。 输入： 看完了《高分少女》的漫画。 大量时间在看《凡人修仙传》小说。小说太长，质量也不高，占用了很多时间。 输出： 为 BOSS Xiang 写小程序。 开始写《一起学习陈海贤自我发展心理学》系列。 写《为高分少女种种草》。 在家画自画像、写春联。 娱乐： 和 Classmate Zhang 双排升到了王者段位。 在家大多时间在玩游戏。 2月事件： 经历春节。 去了几趟医院。很久没去过医院，发现挂号可以预约。 去了一趟杭州，弟弟租房。 18 号回学校。 26 号收拾、搬进实验室。 输入： 电影《流浪地球》、《雪国列车》。 重温小说《福尔摩斯探案集》中《血字的研究》。 重温动漫《端脑》第一季。 《家有女友》动漫和漫画。 娱乐： 玩荣耀，钻石段连跪。无意义。 加了推理大师群，玩了三四天。 全民K歌。 看了很多主播的游戏直播，并上车。 3月事件： 提交了 TBIS 小论文。 28日校园招聘会。投龙拳风暴，无果。 输入： 重温《监狱学园》动漫、漫画 没看完的书：《设计模式之禅》、《雪中悍刀行》、《巨婴国》、《今日简史》 岳松、李宇菲电影《街头之王》、《超级保镖》 电影《白蛇缘起》 重温《李小龙传奇》电视剧，感触颇深。 网剧《爱、死亡和机器人》 看游戏策划、游戏数值相关文章。 输出： TBIS 会议论文。 一连几晚，板绘人物头像。 边学边做 cocos creater 小游戏。 娱乐： 重温小游戏魔塔。 玩游戏，看游戏比赛、直播。 上青鸟的车、和 Zhang, Jin 开黑。 4、5月事件： 搭建了 Hexo 博客（就是本博客）。 网龙训练营。具体参考我的 GitHub项目 裸考完美世界前端线上笔试，未通过。 为 Boss Xiang 更新小程序。 听图书馆搜索技巧讲座，得知油猴插件。 输入： 得到 APP 买新课《社会网络学》、《医学通识》（我记得应该还有好多） 网龙 U3D 课程视频 美剧《sex education》 老男孩 Python 视频的 day1 至 day17 影院电影《复联4：终局之战》 soul 有人提到丁度巴拉斯，他的电影《罗马帝国艳情史》 李小龙电影《精武门》、《龙争虎斗》、《唐山大兄》 没看完王怜花写的《江湖外史》 开始重温《海边的卡夫卡》（6月继续，直至看完） 输出： “事件”中的网龙项目，包括一个 U3D 游戏。 公众号《由自杀谈起：如何面对人生的虚无与荒诞》 日志、博客《大学前三年的简短回忆》 设计和制作“计划与记录”小程序（6月继续，最终没有发布，后端 leancloud 没有配置好） 娱乐： 升至荣耀王者。 体验云中君。 看直播。 6月事件： 4号上午去植物园。 11号途游面试，感觉良好，但未果。 涉足婚恋 APP，消费千元以上；买慕课网、GitChat、极客时间、得到的课程，消费千元以上。 输入： 重温电影《教父》前2部 动漫《头文字D》1、2季 看 Alice Zheng 直播，学习 ACCA。 看完《世界正在变软》、《外婆的道歉信》，没看完《松本行弘的程序世界》、《JS 高级程序设计》 听得到大学开学典礼 输出： 高考作文 更新大量博客]]></content>
      <categories>
        <category>跬步之积</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[得到《批判性思维15讲》笔记]]></title>
    <url>%2F2019%2F07%2F19%2F%E5%BE%97%E5%88%B0%E3%80%8A%E6%89%B9%E5%88%A4%E6%80%A7%E6%80%9D%E7%BB%B415%E8%AE%B2%E3%80%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[开始训练批判性思维，审视自己的思考过程，评判自己的思考质量，从而不断优化它。 “重要但不紧急”的事：学外语、锻炼身体、训练批判性思维…… 批判的对象：不是某个人，而是一个观点背后的思考过程。去审视这个思考多缜密、多系统。 审视一段思考的信息结构本身，评判其中的关键要素是不是完整，每一个要素是不是成立和互相匹配。 跳出立场，站在更大的格局下，评判思考过程是否公允、是否有容错能力。 审视批判性思维本身，它是什么角色，它的局限性和拓展空间。 哈佛前校长德雷克·博克《回归大学之道》：无知的确定性 → 有知识的混乱 → 具有批判性思维的成熟阶段 总论你有多大的思考自由度知识面越广，思维局限和漏洞越少，思考就越自由。 完善知识面：海绵式学习 vs 淘金式学习 破除思维局限：批判性思维 如何意识到自己在思考？旁观者身份：一种更清醒、更置身局外的洞察者身份。做自己的旁观者。 如何训练这种自我分裂的能力？ 练习冥想，旁观我们内在的体验和感受。 训练批判性思维，旁观我们的思考过程。 区别：冥想要求不做评判，只是单纯地感受。而批判性思维不断检验和评判自己的思考，起源于苏格拉底的思想和他的经典问答方法（“真理的助产士”）。 批判性思维在批判什么批判性思维不依赖于任何一个专业，也不依赖于任何一个学科。它是一种超越了学科和知识而独立存在的一种思维能力，也是一种寻找、探究真相的思考本能。 美国大学学会（AAC&amp;U）的批判性思维学习评估表： 批判性思维是这样一种思维形态：他有一套成体系的练习方法，却不能独立存在，而是需要运用到各个知识领域里去。但在各个领域里，它只负责批判这些专业和知识，不直接给出思考的答案。 critical thinking 翻译为“思辨能力”、“审辨思维”等等，显得攻击性更弱一点。它批判的是一个观点背后的思考和论证过程。 批判性思维的适用场景批判性思维不适用于： 不带判断的表达。如“巨大的宁静”。 一个判断，它的依据是个人感受或个人偏好。可以概括为“我感觉”。如“巨大的宁静如你干净的布鞋”、“我不喜欢看到有人在朋友圈晒娃”、“吃得好比穿得好更重要”。不过，如果用个人感觉去为更大的群体下判断，就要注意了——比如“大家不应该在朋友圈晒娃”中，个人感受不是结论，而是作为证据来讨论“该不该在朋友圈晒娃”这个公共现象。 “我猜想”。它可能是直觉判断，也可能有一定理性依据的思考，但是理论者本身也不认为这个观点完全成立。 人们常说“我认为”，但“我认为”往往语义模糊，得先搞明白它到底是感觉、猜想，还是推断。 一个观点只有能称得上“我推断”的时候，他才带有相对充分的思考论证过程（，即具有完整性），才值得进一步用批判性思维审视和评判。 批判性思维审视的第一件事情，就是这段“思考”是不是思考、有没有完整性。 思考质量 &gt; 决策速度批判性思考的效率低、质量高，导致决策速度慢。但是思考更应该追求的是质量，决策更应该追求的是明智与否。 反复来回、追涨杀跌，散户的散并不是钱散，而是心散。 深圳的社会边缘人“三和大神”，挣一天的钱玩三天游戏，他们放弃了思考。 我们要有意识地花更多的时间、足够多的的时间进行思考。 思考框架的三要素每个人的思考框架不同，但是都具备3要素： 知识储备——局限性 思考技术——自洽性 思维倾向——公正性 最通用的思考技术是“论题、论证、结论”三步，来达到思考的自洽。在此的基础上，更高质量的追求是思考的公正和不受局限。 思考的技术我们解构了思考的各要素，审视这些要素是否成立、各要素之间是否匹配。 这一阶段，批判性思维审视的是：一段思考是否自洽。 思考的完整结构面对一段带有思考、带有判断的话，提出第一个问题：论题、结论和论证部分是什么？ 完整的思考 = 论题 + 论证 + 结论 论题：引起理论者思考的问题或分歧。 结论：立论者希望证明、也希望他人接受的观点。 论证：从论题到结论的证明过程。 如何从信息层面上，找出一段思考的几个关键要素，检查它们有没有跑偏、有没有疏漏。 我们要检查3件事： 论题、论证和结论是否存在。 三者有没有对齐，是否首位跑偏。 论题/论证/结论 是否真的是 论题/论证/结论。 论题论题的两大类： 讨论事实。它关心世界万物在过去、现在或未来是什么样的。 讨论价值主张。它关心世界应该是什么样的，包括行为的对错、好坏和情理责任等。 很多时候，思考者会直接给出结论和论证，并不会直截了当地抛出论题。 只要能明确结论，就能倒推出论题。因为它们应该是对齐的。 如果不好好审题，没有审题意识，容易答非所问。训练找出论题、结论和论证的能力，是在训练审题意识，和正面回答问题的习惯。 结论是否是结论？结论必须有论证支撑。 从逻辑学和批判性思维的视角看，结论是一种总结性的判断，是要经过推导和论证才能得出来的。 而观点和判断，却不一定有论证支撑。一个没有分析、推理过程的孤立存在的观点，不能算结论。 是否偷换结论？偷换结论：用一个相关性很强的结论来偷换掉正面回答问题的结论。 多数时候是因为立论者默认预设结论只能是二选一。如：“西医科学，说明中医不科学”，“奶茶受欢迎，说明咖啡市场要没落”。 是否结论先行？有时候，人是先有结论，再找理由把自己的结论合理化。 “天凉王破”：天要凉了，让王氏集团破产吧。天要凉了就是随口找的理由。这种情况下，可能就没有进一步批判的必要。 在做一些决定和选择的时候，搞明白：影响自己做决策的到底是理性判断，还是别的什么。 论证论证包含两部分： 前提 推理 结论 论证必须包含前提与结论的逻辑关系。所以结论是论证的一部分。 评判论证合不合理的主要原则： 前提成立与否 从前提导向结论的推理是否有效。 前提如何找出前提：“因为放置法”：试试把“因为”这个词套到每个句子的开头，如果觉得逻辑舒服，那这个句子就是论证的前提。 前提可能有好几个，每句话都可以试试加“因为”、“又因为”。 有的前提在陈述事实，有的前提是另一个观点。 前提成立的评判标准，有3个笼统的原则： 这个前提陈述跟我们的个人经验冲突吗？ 这个前提陈述跟我们的背景知识冲突吗？ 这个陈述的信息来源可靠吗？ 推理推理的两个基本类别： 演绎推理：只要前提成立，结论一定成立。 归纳推理：B和A算同类，A有某种特征，所以B可能也有这种特征。 如果推理手法是演绎的，那么结论应该用肯定的。如果推理手法是归纳的，那么结论只能说“可能”。 推理的完整性：推理过程有没有发生逻辑跳跃？比如“天凉王破”就应该补全中间的逻辑“心情不好”。 别把解释当成论证解释是指，双方已经承认事实是怎样的的，试图说明事实为什么是这样的。 论证则是一方还没有相信或认同。 解释并不证明结论确实成立，而是把结论变成了默认前提。 注意，解释特别容易和论证混淆。 概念：怎么定义这件事人跟动物最大的区别之一：会抽象总结，用概念、术语、符号去定义某些事物。 概念的一致性：思考结构和过程中，出现的概念、定义是一致的吗？ 概念定义的准确性：这些概念会误导别人吗？ 概念定义的精确性：精确程度取决于精度（精确到哪一个数量级、颗粒度）。从信息接收者角度看，精确程度反映了你对一件事的审慎和郑重。 最好直接在思考和论证的过程里，把一件事定义清楚。 假定：你有什么想当然的假设隐藏假定的类别： 事实判断型。想当然地认为“世界是怎样的”。 价值判断型。想当然地认为“世界应该怎样选择”，价值观偏好。 如何找出隐藏假定：面对一段思考，我必须得持有什么样的观念，才能把已知的前提和结论从逻辑上完成无缝衔接？ 上述问题的答案就是隐藏假定。如何回答这个问题： 假设你是观点的反对者，你会怎么反驳？ 假设你是中立的第三方，有没有其他可能性或路径，也能推导出这个结论？ 隐藏假定被找出来，就成了论证的前提。评判标准同前提的评判标准（3原则）。如果这个假定是价值判断，还要多问一句：我认同这个假定吗？ 找出隐藏假定，是对思考的洞察和穿透。我们不断洞察和穿透自己的思考，就会越来越清楚自己对世界的观察视角、自己的偏好和追求。我们可以记录自己的想法，找出背后的假定，作为一种训练。 思维的倾向信念信念是一种你信奉，并且会践行的观念，也是引导你做出选择和行动的一种精神动力。 信念是一种最为坚固的隐藏假定。既稳定，又隐秘。 信念的主要形成方式： 生物本能 不断被确认的个体经验 不断被灌输的社会共识 想象力构建起来的信念体系 在情绪上，人们常常把对信念内容的否定等同于遭到人生攻击。马克思·韦伯：“人是悬挂在自己编织的意义之网上的动物。” 信念的识别方法： “抵触情绪排查”法：当你的一个观念遭到反对时，你有没有从内心深处产生抵触和愤怒？ 你有没有意愿或冲动，要把这个观念变成所有人都认可和尊崇的原则？ 你自己在遵照这个观念行动，甚至做出重要的人生选择吗？ 信念是可以被审视的。不要把你的个人认同建立在信念内容本身上，而是建立在这个信念的推导过程上。 立场立场就是你下判断的背后，你所代表的身份和所抱持的态度。 搞清楚你和你的对手的立场和态度 思考：如果调转立场，你会接受现在的结论吗？ 换成别的人或别的事，你的态度能保持一致吗？ 立场具有一致性，代表了一个人的价值观稳定、判断公正。 情绪和欲望情绪，是我们遇到各种事情的时候，在心理和生理上的感受。欲望，是我们要达成某种目的的本能要求。它们更多会影响我们的价值判断而不是事实判断。 如果你不是被一个观点的逻辑和事实打动，而是被它的修辞所打动，那这就是情绪和欲望在思维倾向上给你带来的影响。（情绪和欲望常被用来说服别人。） 和信念和立场不同，情绪和欲望与思维质量的关系较小，是跟着具体场景、具体问题走的。 识别和审视情绪： 我对这件事的情绪是什么？ 如果一个怀有相反情绪的人来面对这件事，他的结论会不会跟我不同？ 一年后，我会不会后悔基于这个情绪做出的判断？ 识别和审视欲望： 找答案：我想通过这个观点和主张，得到什么？ 验算：如果有个平行宇宙，我在那里已经得到了我渴望的东西，我还会持有这个主张吗？ 不断识别我们的情绪和欲望是怎么思考问题的，会带来自我觉察的价值：你人生中最在意、最想追求的东西是什么。 批判性思维不评判你的目标好不好，而是帮你评判，在你的整个人生和每一个中短期阶段里，你该重点思考哪些问题，比如： 有没有一些指标，可以用来判断我遇到的新问题是否跟我的人生目标相关？ 我应该怎样面对人生主线之外的信息吸引力？ 我应该爱惜自己的思考力，提醒自己避开那些东西，还是在某些情况下，允许自己的大脑放放假？ 这些已经是人生观问题，没有标准答案。你愿意在人生主线上投入多少，在副线上投入多少，也没有标准答案。但批判性思维能让你用更明智、更开放的思考框架来思考它们，而且你能清晰意识到你进行了负责任的思考，而不只做直觉判断。这就是“思考自由度”。 思考的破局时代局限和格局局限我们思考框架中的一些信念有强烈的的时代烙印。这就是时代局限。 格局局限：世界上还存在其他你完全不知道的维度，知道了你也不关心，因为那个维度的重要问题你没概念，不在你的优先级序列里，你所能接触和感知的就是你的格局边界。“我们没法知道我们不知道什么”。 如果我站在更大的格局上，或变成更微观的当事人，我还会这么想吗？ 格局局限很难突破，最有用的办法听起来非常鸡汤：多看世界、多接收信息，保持好奇，多学东西。这也是海绵式思维最重要的正面价值。 批判性思维的不完备性批判性思维作为一种思考，也有自己的模型。该模型包含3个问题： 如何拆解一个思考过程？ 如何评估这个思考过程？ 如何从思考框架出发，重构或提升这个思考过程？ 它本身有2种局限： 批判性思维不能帮你打开视野和格局。 批判性思维作为一个思想系统，必然是不完备的。 系统的不完备：在系统之内能意识到某个问题的存在，但没有办法基于这个系统去解决它。 全能上帝举不起来的石头，即使存在，在我们的认知里也是无法理解的。 哥德尔不完备定理，不止可以用来论证数学的不完备。一句网络流行语“物理的尽头是数学，数学的尽头是哲学，哲学的尽头是神学”，说的是一个解释系统总有它自己所揭示不了的问题，需要求助于另一个系统。 世界上，不同民族的语言体系也各有各的不完备。如“K歌”、“江湖”。德语里很多描述情绪的单词，词义用中文特别一言难尽，甚至要用一本书来解释。维特根斯坦：“语言的边界就是思想的边界。”我们的思维是靠语言组织的，一个语种对世界的描述力不完备，必然导致对应的思维体系的不完备。 批判性思维不能从0到1地构建思考，它只负责评判。 成长与创造：值得拓展的思维能力我们需要其他思维来扩展现有的思考边界： 成长型思维 创造性思维 一份批判性思维的提问清单 你面对的观点是什么？这是一个推断、一个猜想还是一个感觉？ 审视这个观点，对我重要吗？（判断值不值得投入思考成本。这是一个“刹车问题”。） 这个结论是在回应论题吗？（判断有没有走题、结论是否偷换。） 这个结论是怎么得出来的？（审视论证是否严密，包括审视前提和推理。） 思考过程中，有没有什么概念的意思不够明确？ 思考过程中用到了哪些隐藏的假定？假定是可靠的吗？ 换一种信念，你的结论会不同吗？ 换一种立场，你的结论会不同吗？ 换一种情绪和欲望（或者过一段时间之后），你的结论会不同吗？ 这个结论，是不是只在某些边界内适用？（不同的格局和维度、不同的时代。）]]></content>
      <categories>
        <category>高屋建瓴</category>
      </categories>
      <tags>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【Qt】QRegExp Class 文档翻译]]></title>
    <url>%2F2019%2F07%2F17%2F%E3%80%90Qt%E3%80%91QRegExp-Class-%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91%2F</url>
    <content type="text"><![CDATA[The QRegExp class provides pattern matching using regular expressions. regular expression = regexp = 正则表达式，是一种用来匹配 substring 的 pattern 。 特性正则表达式的用途： Validation. 测试 substring 是否符合一些标准，例如一个不含 whitespace 的整数； Searching. Search and Replace. String Splitting. 标识（identify）字符串的拆分位置，例如拆分以制表符分隔的字符串。 QRegExp 模仿 Perl 的正则表达式。它完全支持 Unicode 编码。 QRegExp 也可以使用更简单的通配符模式（wildcard mode），类似 command shells 的功能。 QRegExp 使用的语法规则 syntax rules 可以使用 setPatternSyntax() 改变。 In particular, the pattern syntax can be set to QRegExp::FixedString, which means the pattern to be matched is interpreted as a plain string 被解释为“纯”字符串, i.e. 即, special characters (e.g. 例如, backslash 反斜线) are not escaped 转义. 图书推荐：《Mastering Regular Expressions (第三版)》Jeffrey E. F. Friedl, ISBN 0-596-52812-4 注意：Qt5 中新的 QRegularExpression 类提供了兼容 Perl （Perl compatible）的正则表达式实现，来代替 QRegExp 类。 工具：正则表达式在线测试 介绍基本组成Regexps are built up from: expressions 表达式 quantifiers 量词 assertions 断言 expressionThe simplest expression is a character, e.g. x or 5. An expression can also be a set of characters enclosed in square brackets.一个表达式可以是包含在方括号中的一揽子字符。[ABCD] will match an A or a B or a C or a D. We can write this same expression as [A-D], and an expression to match any capital letter in the English alphabet is written as [A-Z]. quantifierA quantifier specifies the number of occurrences of an expression that must be matched.量词指定了一个表达式必须匹配的出现次数。x{1,1} means match one and only one x.x{1,5} means match a sequence of x characters that contains at least one x but no more than five. Note that in general regexps cannot be used to check for balanced brackets or tags.注意，通常的正则表达式无法用来检查括号或标签是否配对。如果 html 的 标签有嵌套（be nested），同样的正则表达式就会匹配错误。只有当嵌套的层数固定且已知时，才可以写出正确的正则。 assertion假设我们想要一个匹配 0 到 99 的整数的正则表达式，我们写出 [0-9]{1,2} 来满足需求，但是它也会匹配一个包含整数的字符串。If we want the matched integer to be the whole string, we must use the anchor assertions, ^ (caret) and $ (dollar).如果我们只想让整个字符串是整数，我们必须使用锚定断言，正则表达式变成了 ^[0-9]{1,2}$ 。 ^ and $, do not match characters but locations in the string: When ^ is the first character in a regexp, it means the regexp must match from the beginning of the string. When $ is the last character of the regexp, it means the regexp must match to the end of the string. 特殊符号If you have seen regexps described elsewhere, they may have looked different from the ones shown here. This is because some sets of characters and some quantifiers are so common that they have been given special symbols to represent them.其他地方的正则表达式可能看起来和这里展示的不同。这是因为一些字符和量词可以表示为特殊符号。 [0-9] can be replaced with the symbol \d. The quantifier to match exactly one occurrence, {1,1}, can be replaced with the expression itself, i.e. x{1,1} is the same as x. ？ 是量词 {0,1} 的简写，即出现 0 或 1 次。? makes an expression optional. the vertical bar | 表示 or. So our 0 to 99 matcher could be written as ^\d{1,2}$. It can also be written ^\d\d{0,1}$, i.e. In practice 实践中, it would be written as ^\d\d?$. 举个例子To write a regexp that matches one of the words ‘mail’ or ‘letter’ or ‘correspondence’, start with a regexp that matches ‘mail’.Expressed fully, the regexp is m{1,1}a{1,1}i{1,1}l{1,1}, but because a character expression is automatically quantified by {1,1}, we can simplify the regexp to mail, i.e., an ‘m’ followed by an ‘a’ followed by an ‘i’ followed by an ‘l’. To include the other two words, our regexp becomes mail|letter|correspondence. While this regexp will match one of the three words we want to match, it will also match words we don’t want to match, e.g., ‘email’. To prevent the regexp from matching unwanted words, we must tell it to begin and end the match at word boundaries. 首先我们 enclose 我们的 regexp in parentheses, (mail|letter|correspondence). 圆括号 parentheses 将表达式 group together，并且在 regexp 中 indentify 我们希望 capture 的部分，我们可以将它作为 component 应用到更多复杂的 regexp 中。我们还可以用圆括号检查实际匹配到了 3 个单词中的哪一个。 To force the match to begin and end on word boundaries, we enclose the regexp in \b word boundary assertions: \b(mail|letter|correspondence)\b.Now the regexp means: Match a word boundary, followed by the regexp in parentheses, followed by a word boundary. word boundary 断言 \b 用于匹配 regexp 中的位置，而非字符。一个 word boundary 是任意的 non-word 字符，例如 space, newline, or the beginning or ending of a string. 再举一例If we want to replace ampersand characters (&amp;字符) with the HTML entity &amp;amp;, the regexp to match is simply &amp;. But this regexp will also match ampersands that have already been converted to HTML entities. We want to replace only ampersands that are not already followed by amp;. For this, we need the negative lookahead assertion, (?!__). The regexp can then be written as &amp;(?!amp;), i.e. 字符集及其缩写Characters and Abbreviations for Sets of Characters (字符集) 下表我只摘了一些常用的。 Element Meaning c A character represents itself unless it has a special regexp meaning. e.g. c matches the character c. \c A character that follows a backslash matches the character itself, except as specified below. e.g., To match a literal caret at the beginning of a string, write \^. \n Matches the ASCII line feed (LF, 0x0A, Unix newline). \r Matches the ASCII carriage return (CR, 0x0D). \t Matches the ASCII horizontal tab (HT, 0x09). \v Matches the ASCII vertical tab (VT, 0x0B). . (dot) Matches any character (including newline). \d Matches a digit (QChar::isDigit()). \D Matches a non-digit. \s Matches a whitespace character (QChar::isSpace()). \S Matches a non-whitespace character. \w Matches a word character (QChar::isLetterOrNumber(), QChar::isMark(), 或下划线) \W Matches a non-word character. \n The n-th backreference, e.g. \1, \2, etc. 第n个反向引用 Note: The C++ compiler transforms backslashes in strings. To include a \ in a regexp, enter it twice, i.e. \\. To match the backslash character itself, enter it four times, i.e. \\\\. 疑惑：什么是 newline？ 未完待续]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我在迷茫期的思考]]></title>
    <url>%2F2019%2F07%2F15%2F%E6%88%91%E5%9C%A8%E8%BF%B7%E8%8C%AB%E6%9C%9F%E7%9A%84%E6%80%9D%E8%80%83%2F</url>
    <content type="text"><![CDATA[人生难题上个月末有一段时间，我充满了焦虑。 这是一种临近毕业的大学生都会有的焦虑，就如郝景芳在《生于1984》中的表达： 焦虑、不满，想找更多东西，却又说不清不满意的东西是什么。 我没有继承爸爸的行动力，却继承了他对日常生活的不满。我没有继承妈妈融入生活的热情，只继承了她对不愿改变的保守。 感觉不到真正的自由。虚无感，无方向感。 3年前我读这本书时，知道未来3年是确定的；而现在不是。所以，我如今对于这些文字更加地感同身受。我的好奇心太盛，我拥有的选择太多了，反而不知道如何选择。 618那天，我疯狂囤积了一堆课程，明白了为什么很多人喜欢购物释压；然后我又在夜不能寐的凌晨，一遍又一遍地思考自己的未来。 纪录片《两百万分钟》记录了中、美、印3个国家中6名高中生的学习与生活。论学习的努力程度，中 &gt; 印 &gt;&gt; 美；但是若论对未来的规划和打算，确是反过来的。 在我们中学的时候，从没有人认真地问我们这些问题： 你愿意活得更长，还是宁愿活得更好？ 什么是活得更好，是指生活的密度大还是说生活的质量高？ 为什么会迷茫？为什么有焦虑？因为诸如此类的问题，每个人都只能用自己的一生去试着寻找答案。不过当终于明白时，一生也已到头了，没法再来一次。 王怜花在《江湖外史》中说：生活只有一种可能性，并且没有一种生活不需要付出代价。 我们有很多学生在学校里学的，只是怎么重复别人的想法。他们从没有想过，那些没有标准答案、但又特别重要的问题。我们的学校只灌输知识，却从不教我们怎么认知世界。 老喻说：一个人的认识半径要尽可能大，能力半径要尽可能清晰，行动半径要尽可能小。 博观而约取，厚积而薄发，这是一个辩证的命题。博与厚，约与薄，前者是开放与好奇，后者是具体、专注与坚忍。 人的一生，无非是在这两者之间不停地往返，不停地对未来做选择。人们有与生俱来的好奇心，但是又受限于生命的长度，只能选择有限的几件事去做好。 专注与坚忍6月27日，我写下了如下文字： 见识到了和高收入者之间巨大的差距，以及上升机会的渺茫，年轻人很难建立逆袭的信心。自信变得稀缺，变得就像《流浪地球》里的希望那样（page 28/71:“希望是这个时代的黄金和宝石”）。不过纵观历史，这也是一种常态，只能感慨一下。 我是那种内在追求完美、外在追求淡泊的人，不喜欢人们急功近利的姿态。我从不为了争取奖学金和荣誉而费尽心思，填志愿也不会想着拼一把。 但我的自尊在于，我有自己的想法，而且有自己擅长的领域。那些现在清华、上交、浙大的同学，高中时若论单科实力强弱，我也颇有信心（人送外号“物理帝”）。而且即使我的数学不太好，也有一次考试时某道数学难题全班只有我一个人做对（感激高三的数学老师，通过表扬和细心指导让我对数学重拾自信）。 况且，人的比较对象更应该是自己，因为与别人比，容易陷入非理性的自卑或自负中。我只能做最好的自己，日拱一卒，探寻、摸索和建立自己的增强回路系统，然后等待时间让我慢慢变强。 6月30日，我发送了朋友圈： 不要想着证明自己，而要超越过去的自己。如果我不觉得3个月前的自己是个蠢货，那我就没有学到什么。 评论里，有人说一直觉得他自己是蠢货，我怀疑他是在开玩笑——事实上，如果陷入这种绝望的情绪之中，想要提升自己、甚至是正常生活都是很难的。 有一篇研究 AI 的论文指出，机器学习效率最高的训练出错率是 15% 多一点。如果推广到人脑，那么我们在学习时，85% 的正确率让我们既不至于被打击自信心，又能最大化地提升自己的不足。 言归正传，建立一个良好的心态十分重要，想要变强，必须学会坚忍。 随着年岁渐长，我越发觉得，人生是没有捷径的。我们看到的捷径，背后不是有着巨大的风险，就是有着惨烈的竞争。 有一次，贝佐斯问巴菲特：你的投资理念非常简单，而且你是世界上第二有钱的人……为什么大家不直接复制你的方法？ 巴菲特回答：因为没有人愿意慢慢地变富。 巴菲特全部身价的 99.8% 都是在他50岁之后积累的；同样，截至2019年，马云 90% 的资产都是他坚持到50岁以后挣得的。 几十年如一日的坚忍和专注，看似简单、实则困难，因为在漫长的坚守中，存在太多诱惑，有着太多煎熬，会经受无比的寂寞。寂寞是最难忍受的，不论是做事还是做人。正如《格拉斯医生》中所说：灵魂害怕真空，不顾一些代价，它向往接触。 吴军在《见识》的“人生需要做减法”部分中说： 人的幸福感和成就的取得，不是来回去选择的结果，而是在没有多少选择时深度经营的结果。 世界上捡芝麻的人多、捡西瓜的人少，你如果致力于捡西瓜，就要耐得住寂寞。你满眼都是芝麻，天天为捡芝麻而忙碌，就没有机会练就捡西瓜的能力了。 如果一个人不能把一件事情做好，他首先想到的应该是少做事情，而不是让自己更忙碌。 换一个角度来判断一件事的重要性、敢于舍弃，这是吴军做减法的人生智慧。他不但是这么说，也是这么做的。 游戏人生（何帆）才高于志、土木形骸，这都是做减法的人生。当然，更高的境界是既能做加法，又能做减法，该做加法的时候做加法，该做减法的时候做减法。那么，我们怎样才能做到这一点呢？有一个方法，就是用做游戏的态度去度过你的一生。当我们平常讲游戏人生的时候，我们其实误读了游戏，也误读了人生。请你不妨想象一下在玩过家家游戏的孩子。孩子在做游戏的时候是非常认真，非常投入的。他们是用自己的全心去感受，去融入。可是，他们知道自己是在做游戏。当他们给布娃娃打针的时候，难道不知道布娃娃根本感觉不到疼？当他们拿玩具枪玩射击游戏的时候，难道他们不知道玩具枪里装的根本就不是弹药？孩子们都知道：去关心游戏的真假是没有意义的，真正有意义的是游戏好玩不好玩。所谓的游戏人生，就是像孩子们玩游戏一样去体验人生。很多时候，成年人干的事情也跟孩子一样，就是个游戏，看穿了都是虚假的，但这不重要。重要的是你认可不认可游戏的规则，你是不是觉得这种游戏有意思。你真正追求的东西并不在游戏里面，而在游戏之外，你要想清楚，那个在游戏之外的东西究竟是什么。 浮生若梦，为欢几何（王怜花）人生苦短，这是一个大家都认同的常识。但接下来怎么做，就千差万别了。《古诗十九首》的教导是： 人生忽如寄，寿无金石固。 万岁更相送，贤圣莫能度。 服食求神仙，多为药所误。 不如饮美酒，被服纨与素。 …… 生年不满百，常怀千岁忧。 昼短苦夜长，何不秉烛游！ 为乐当及时，何能待来兹。 …… 《古诗十九首》是绝对的诗，铿锵绝决，有白金和乌木的气概。“秉烛夜游”，多么坚决的人生态度，汉人最高蹈的精神在这里被点亮。紧接着，《世说新语》，这部记载汉人高蹈精神的沙之书，讲述了汉人中最敏感的心灵如何面对生活：穷途恸哭，土木形骸，礼法岂为我辈所设；雪夜访戴，秋风鲈鱼，人生只贵适意而已。接下来，汉人中最高洁的心灵陶渊明写下了五柳先生的生活：“造饮辄尽，期在必醉，既醉而退，曾不吝情去留。”之后，有史以来最伟大的汉语诗人李白写下了《将进酒》： 君不见高堂明镜悲白发，朝如青丝暮成雪 青丝，青丝啊，趁着暮成雪前千金散尽，所以，人生得意须尽欢，莫使金樽空对月。在《春夜宴桃李园序》中，李白发出了总结性的感慨： 夫天地者，万物之逆旅；光阴者，百代之过客。而浮生若梦，为欢几何？古人秉烛夜游，良以有也。 李白以后，汉人的精神和生活逐渐萎缩，变得猥琐。千年后，古龙无师自通地接上了这一脉。在他的笔下，又出现了倜傥不群的汉人形像。]]></content>
      <categories>
        <category>岁月如歌</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《见识》读书（纸质书）笔记]]></title>
    <url>%2F2019%2F07%2F05%2F%E3%80%8A%E8%A7%81%E8%AF%86%E3%80%8B%E8%AF%BB%E4%B9%A6%EF%BC%88%E7%BA%B8%E8%B4%A8%E4%B9%A6%EF%BC%89%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[吴军 著 本书主题：个人精进 序言 “命”和“运”决定人的一生 运气是一时的，具有很强的随机性；但命却影响人的一生，起着决定作用。 信命：知道自己有所不能。“到哪座山唱哪座山的歌。” 认命：不超越命运划给自己的线，对于得不到的坦然接受。 命取主要决于两个因素：环境，我们自己对未来走向划定的方向。 第二个因素——一个人看问题和做事情的方法。 我们在一辈子的经历中总会遇到各种麻烦和难题，它们就如同别人或者现实生活在不断地扇我们的耳光。 人对一个巴掌的反应，其实决定了其一生的命运。 读到这儿，突然想起了“宏颜获水”说的那一句“What’s your problem? ”这种不愠不怂、分析问题的态度，就是对于巴掌的好的反应。 幸福是目的，成功是手段人生是一条河 要做到更深，是靠自己的修行和对世界的理解； 做到更宽，是要和一些志同道合的人在一起共同做一些事情； 至于是否能流传得远，要靠思想的价值，这在短期内是很难知道的。 这个世界没有欠你什么 社会竞争是一种非常复杂的长期系统性的竞赛，涉及到非常多的变量。 你在努力，别人也在努力。逆袭不成功是常态，逆袭是一个漫长的过程。 不要抱怨社会不公，而要付出足够多的的努力，同时把注意力放到最该关注的事情上。 人生最重要的投资 对于年轻人，对自己的投资和在职业上的进步，远比股市投资重要。当然，还有一个相同重要甚至同等重要的投资，就是找一个好的配偶。 J.P.摩根：一个女性应有的基本素养：不搬弄是非而且性格好。 在 JDate 网站上，根本不会让70分的男生看到80分以上女生的存在！正是因为一开始就没有了不必要的幻想，JDate 网站的配对才让大家觉得满意。 找一个对自己好的人非常重要。 给男生的建议（找配偶标准）： 聪明：“聪明人会欣赏聪明人，而且只有聪明人才会欣赏聪明人”，一个漂亮的笨女生是很难喜欢上一个真正的才子的。 魅力：容貌靠遗传，而魅力则靠培养。脱不花：“想了解一个女生20年后的样子，看她的母亲就知道了。” 独立性：在婚姻中，关系的亲密程度和重要性依次是“夫妻优于子女，更优先于双方的父母”。 可塑性：一个人，特别是年轻的时候，可塑性很重要。这样的人进步会很快，磨合起来也很容易。 给女生的建议（找配偶标准）： 完美的爱情并不意味着完美的婚姻。恋爱是激情，是化学物质分泌所带来的愉悦感；婚姻则是由两个人一同构造一个舒适的共同体。 既然喜欢外表（好色）是男人的本能，就不要强行改变它，只能因势利导，找一个能够对自己好的男人。 能对自己好，不能看对方怎么说，而要看他怎么做。不仅要看他在热恋中如何对自己，也要看他如何对别人，以及能否比较长时间对自己好。 看一个人能否对自己好，首先要看他的“婚姻观”，即是否认可夫妻间关系的重要性高于其他关系的重要性。 一个男生最终能否对你好，还要看他有没有这个能力。这个能力不是指对方现在的经济实力，（那都是存量，很快就花光了，）而要看他有多少创造未来的能力。 如果一个女生有幸找到一个用行动对自己好，而且有能力在将来对自己更好的人，牢牢把握住他吧。 先让父母成熟起来 与时俱进：父母成熟，首先要自己不断地进步。 转变观念：孩子不是自己的资产，父母和子女之间要彼此尊重和理解。 孩子要主动沟通：年轻人应该把自己看成一个成年人，用一种尊敬，而且是成年人之间的沟通方式和长辈说话，要不断将自己接受的新思维方式和理念传递给父母。 那些从农村或者底层家庭的孩子，通过努力实现了社会阶层的进阶。吴军发现他们的父母有三个共同的特点： 大气、开朗，不斤斤计较，不倚老卖老； 虽然他们自己的受教育程度不高，但是学习的愿望很强烈，愿意尝试新的东西、接受新事物； 虽然那些老人在物质上不富有，但是在精神上会不断给予子女支持和鼓励。 向死而生 除死无大难。每当遇到困难、挫折和失败，我就想：没事，我还活着，活着就有希望。 一些人问我为什么离开谷歌、腾讯。其实，那些事情没有我来做，也有别人能做，但是却要占据我的时间。而有些事情，只能我来做。 那些希望我给面子的人，在他们看来那只是花费了一两个小时的时间，而在我看来，却是 被拿走了一部分生命。 人生需要做减法不做选择的幸福 通常我们认为，当有更多选择时，我们会过得更幸福，但事实并非如此。印度人对婚姻没有选择，只好更仔细地经营他们的婚姻和家庭了，反而比那些只注重选择、不注重经营家庭的美国人要幸福得多。 人的幸福感和成就的取得，却不是来回去选择的结果，而是在没有多少选择时深度经营的结果。这种现象可以称之为“不选择反而获得幸福”。 ……以至很多人想的不再是努力工作获得晋升，而是如何巧妙地用自己在美国和大公司的经历包装自己。 做人与作诗：我们需要林黛玉 一位容貌绝代的年轻女性曾经问我，如何能让自己更性感。我说你已经够让人惊艳了，但是形容之美终不如举止优雅、腹有诗书。 我们的社会有时太讲究功利，太讲究做人，纵有金山银山，也是乏味无趣的。 西瓜与芝麻 ……这些人的问题不仅在于时间利用得非常没有效率，更糟糕的是他们渐渐习惯于非常低层次的追求。人一旦心志变得非常低，就很难提升自己、让自己走到越来越高的层次上。 他们行为的对错倒在其次，这种把心思放在捡芝麻上的人，让我瞧不上，因为他们永远地远离了西瓜。糟糕的思维方式和衡量价值的标准，决定了人不幸的命运。 世界上捡芝麻的人多、捡西瓜的人少，你如果致力于捡西瓜，就要耐得住寂寞。你满眼都是芝麻，天天为捡芝麻而忙碌，就没有机会练就捡西瓜的能力了。 生也有涯，知也无涯 我虽然时间管理得还算好，但也不能同时做很多事情。我做事的诀窍（如果这也算诀窍的话）恰恰和大家想的相反，就是少做事，甚至不做事。 首先，我能够跳出思维定式，换一个角度来判断一件事情的重要性；其次，我敢于舍弃。这两点，都是从《庄子》中悟出来的。 如果一个人不能把一件事情做好，他首先想到的应该是少做事情，而不是让自己更忙碌。 要想换取更多的时间，就必须牺牲很多经济利益。 对这个大专毕业生能被录取，我感到非常惊讶，问她有什么秘诀，她说很简单，少做点事情就好，把要做的事减到最少。 小公司必须学会做减法。把做事清单减到只有一件事，这就是你们的核心价值所在。 我们一定比18世纪的人过得更好吗？ 贵族在举止上最重要的是在自然危险面前的淡定。“泰山崩于前而色不变”。 幸福生活才是根本，其他都不过是达成这个目的的手段而已。今天的人不用太担心物质的匮乏，如果我们能够在每天出门时想到“责任”“荣誉”“从容”“优雅”“镇定”这10个字，就能比18世纪的贵族过得更好。 谈谈见识我们和天才相差有多远起跑线和玻璃心 给予孩子正确的引导，培养他们在人生中长跑的意识和能力，一时的失败或者落后算不上什么大事。 很多人在年轻时养成了玻璃心，以后就无法为长跑提供动力了。（我想到“自我设限”） 论运气 人在运气不好的时候，最需要的不是盲目的努力，而是慢下来思考，有耐心地做事。 “时间是你的朋友，而时机不是。”也就是说，耐心是成功的第一要素。 其实，任何经历只要善于利用都是财富，不善于利用都是浪费时间。 在我接触到成功者中，绝大部人都会认为自己不过是交了好运气而已，不炫耀自己的能力，也不过分强调自己的努力。 比贫穷更可怕的是什么活得诸事不顺的人都有3个共同的问题： 缺乏见识。视野被局限。夏虫不可语冰，曲士不可语道； 缺乏爱。缺乏爱的人难以大气，不大气的人做不成大事； 缺乏规矩。轻则没有人愿意帮助他们，重则大家会和他作对。 对话庄子：谈谈见识 很多时候，成败与否取决于见识的高低，而不是自己简单的努力；见识的高低，则取决于我们的环境。 从细小的角度看宏大的东西是不可能全面的，但是，从宏大的角度看细小的东西也不可能真切。 阅读的意义 今天我们的阅读，很重要的目的是为了改变当下的生活方式。特别是互联网出现后，我们很容易获取知识，而对于成为一名阅读者的需要其实反而超过以往任何时候。 现在，我们每天都给自己安排非常满的日程，也一直在抱怨自己太忙，但并不清楚时间都花到哪里去了。虽然我们的收入比长辈多出很多，但钱总是不够花，很多年轻人反而要老人们补贴。我们总是在买一些并不需要的东西，然后因为它们堆满了房间、塞满了抽屉而心烦。我们有很多提高效率的工具，但是效率其实并没有提高，搞得我们难以拥有充足而优质的睡眠。我们和许许多多所谓的“熟人”加了微信，但是能说点真心话的朋友却越来越少。我们每天刷小视频、刷消息，但是半个月后那些内容我们根本记不住，也对我们没有产生任何影响。 我们总希望能经历更多有趣的事情，看到更多的好风景，品尝到更多的美食。我们把它称为快节奏，但其实回眸时，我们是没有节奏的。 我们今天有很多获取知识和资讯的渠道，但是它们不能帮助我们审视人生，因为它们不能给我们带来闲暇，而是让我们更加没有闲暇来思考。读书则不同，尤其是在读纸质书时，我必须有比较长的时间不做其他事情，这样才能入境。正因为不得不把手中的事情放在一旁，才能审视人生。因为在我看来，阅读是当下可以让我审视人生不多的方法之一。 大家智慧莎士比亚的智慧：论朋友 对创业者的评价，品德，尤其是诚信比能力更重要。 朋友的交往其实也是一种投资。150个人是你一生中在亲友方面能够投资的总额，而亲戚们可能又占掉了其中一半。 《哈姆雷特》中老臣波洛涅斯对儿子的一番忠告：不要想到什么就说什么；对人要和气，但要保持距离；相知有素的朋友，应该用钢圈箍在他的灵魂上，可是不要对每一个泛泛的新知滥施你的交情。（人遇到一个合适的伙伴并不容易，要深度经营。） 一个表面上对所有朋友一视同仁的人，实际上是很难有至交的。……这位老板是个好好先生，对所有的部下一视同仁，他自己觉得这很公平。但是不到两年，所有能干的部下都跑光了，手下剩下的都是平庸之辈。 不要给损友第二次机会，永远不要来往。我对任何人，一般都先假设他是正直、善良和诚信的……我只会上一次当，在上当之后我不会给那些人第二次机会。 拉里·佩奇的经营管理智慧 把产品做成牙刷，每天都让用户都必须用上几分钟，久而久之就养成了使用的习惯。 由于每天都要用到，产品的可靠性和稳定性非常重要；由于功能简单，每过一段时间就要给大家带来一个惊喜，提醒大家它的存在。 每周，你最好把自己的工作总结成三句话，周一早上汇报给你的领导；每半年到一年，你要有一个让他惊喜的成果。 薪尽火传：通过这种方式长期存在下去的谷歌其实和原来的公司已经是两回事了。这就犹如不死的海蜇，看上去又长出了新的细胞，却不是原来的母体，不过它们有相同的基因。 巴菲特午餐：人生的智慧 不熟悉的、不是自己核心业务的，就不能做，这是巴菲特思想的精髓。 当然，在谨慎的同时，巴菲特并非一个不求进取的人。他不做自己不熟悉的事情，只是不做自己当下不熟悉的，并非永远不打算熟悉那些事情。 再巴菲特看来，只有价值投资才算是投资，炒股不算。 如果我们把时间投入到自己的职业发展上（做自己最擅长的事），不断做出更大的贡献，不断被提升，每年的回报要远远高出炒股的那十几万元。 司马迁：东方最早的经济学综合论文《货殖列传》人天性喜欢物质享受和精神享受。如何教育和管理？善者因之，其次利道（导）之，其次教诲之，其次整齐之，最下者与之争。 销售大师的智慧持续的生意：让顾客把买的东西用光。在管理一个团队时，给员工的奖励要想办法能够很快被消耗掉，使他们能持续轻装奋斗。商品和服务要让消费者有面子，做生意就必须照顾人的面子。和人相处的技巧在于，要让对方感觉对你有所需求。 拒绝伪工作者不做伪工作者 一个人的效率是很难提高的，自己唯一能控制的就是少做一点事情，有些无关紧要的事情就不要做了，而不是挤压时间把所有事情凑合做完。 互联网的产品开发和传统软件行业不同，是一个动态迭代的过程。开发过程中，新的问题总是不断涌现、不断加进来。 一个有经验的员工，应该善于找到最重要的工作，并且优先完成它们，这恰恰是所有新员工都欠缺的技能。 那些伪工作者即使平时再忙，也会被淘汰。 伪工作的典型特征： 既不能给公司带来巨大收益，又不能给用户带来价值的改进和“升级”。 明明可以通过学习新的技能更有效地工作，却偏偏要守着过去的旧工具工作，甚至手工操作。 在做事情前不认真思考，做事时通过简单的试错方法盲目寻找答案。 做产品不讲究质量、不认真测试，上线后花费很多时间找漏洞和打补丁。 不利用有限的资源解决95%的问题，而是把大部分精力用来纠结不重要的5%问题。 总去参加不重要的会议，或者开会时找来大量不必要的人旁听。 努力10000小时真能帮你成功吗 《异类》作者格拉德维尔认为，如果智商低于120就很难成功，而高于这个值之后，智商的作用不明显。……勤能补拙并没有科学依据。 如果一定要说有什么起跑线的话，父母的见识就是起跑线。 有了智力上的、时代大环境的以及家庭和周围小环境的便利因素，接下来该怎么做呢》格拉德维尔认为要花10000小时的苦功夫。 10000小时不过是一个必要条件而已，远不充分，更重要的是，这10000小时怎么花。 误区一：简单重复，低层次的重复，做伪工作； 误区二：习惯性失败，好高骛远、不注重学习吸取经验教训，同时脸皮薄、不好意思请教，迷信失败是成功之母的说法，简单地重复失败； 误区三：在自己的世界里越精进，就对外界越排斥（当然也被外界排斥）； 误区四：狗熊掰棒子，零散、不成体系，没有累积效应，第二次的努力没有最大限度地复用第一次努力的结果。 三板斧破解四困境确立“愿景——目标——道路” 人想要进步，就必须给自己确立一个合适的愿景。 有了愿景，还要有阶段性的目标。战略的核心就是设置阶段性的目标，以便实现愿景。 有了战略，还要有战术。为了实现目标就要有通向成功的道路，这条道路可以分解成一系列可操作的步骤。 即使听到不中听的话，也要试着找出其中的合理之处 第一层意思：换位思考； 第二层意思：凡事要习惯回过头来三思，是否我错了、他对了； 第三层意思：即使对方真是胡说八道，也要思考他为什么这么说，找出其中的合理性。 凡事做记录，避免狗熊掰棒子 大部分人过分相信自己的记忆力； 在记录的过程中又思考了一遍，进步更快； 经验容易积累和传承。 OKR:谷歌的目标管理工作法Objectives and Key Results，略。 做好最后的1% 他说：“我们已经走了九十九步，为什么不把最后一步走完呢？” 这些人可能和走完一百步的人同样辛苦，但是成就想去甚远。 走完一百步的精神不仅仅体现在做东西、做事情上，还体现在交流和沟通上。……他们给我打电话也好、发邮件也好，都要让我说出“确认”两个字才算任务完成。 世界上，做得还算过得去的人与前1%相比，可能就差最后几步路，但是最后收入水平、社会地位、发展机会差别却很大。 职场的误区与破法人的第一份工作很重要，它的性质和成败决定了你此后职业发展的方向和事业起点。 年轻人第一份工作不要太在乎工资 对于非常重要的岗位，公司会开出比市场价高一倍的薪水，这样就由公司来挑选最好的人，而不是让最好的人在几家公司中做比较。 我总结谷歌在工程上成功的奥秘，其实就是一句话，“杀鸡一定要用牛刀”。 世界上人和人的差别常常是数量级的。关键岗位上，用一个一流的人和一个三流的人，结果会大不相同。 这种关键职位对一个公司来讲非常少，因此对于大多数员工，有时给的待遇可能比竞争对手还要低。因为我虽然不提供更高的薪酬，但是会给年轻人更多的成长空间，对于真正有志之人，会更看重后者。 人的第一份工作是否多挣 20% 的工资是一件毫无意义的事情，因为你在那个阶段挣多少花多少。 第一份工作必须能够让你极快速地成长，养成良好的职业习惯，在最短时间里了解全行业。而且你也要主动通过第一份工作尽可能地成长。 IT 公司对培养人的重视程度：谷歌、微软 &gt; BAT等一线公司 &gt; 其他公司 自己和自己比，和与自己同条件的人比，重要的是每过几年要能够上真正上一个台阶。（想到“如果我不觉得 3 个月前的自己是个蠢货……”） 五级工程师和职业发展 按照朗道的理论，物理学家可以分为 5 个等级，第一级最高，第五级最低，每一级之间能力和贡献相差10倍。 朗道等级最核心的思想是，人和人的差距、能力和能力的差距，是数量级的差别，而不是通常人们想象中的差一点点。 很多搞 IT 的人，常常会把海湾大桥修成浮桥，也会把浮桥按照海湾大桥来慢慢修。 第四级工程师能最好地解决这样一个有规模的实际问题。从管理者的角度看，中国 IT 公司里非常缺乏这样有头脑的工程师。 第三级工程师，能独立带领其他人做出一个为公司挣得利润的产品，他本身必须是非常好的产品经理。 职场上的四个误区和四个破法先排除一种情况，就是一种根本不值得为之工作的单位。这种单位的领导只喜欢溜须拍马的下属，只提拔自己的亲戚。 误区1.工作和职业分不清如果当下的工作是为了一辈子的职业发展，首先就要有选择地做事情，凡是对将来职业有利的事情，不论是否有报酬，也不管报酬是高是低，都要做。反之，只能带来收入的提高，和职业发展没有必然联系甚至矛盾的事情，则尽可能不做或少做。 误区2.把自己当成过客，而不是主人人一旦觉得自己是过客，常常就对很多该完成的工作视而不见，也懒得建立和维护与同事的关系。虽然想利用这个工作做跳板，但是过客心态不能有，容易不求上进，既浪费了时间又丧失了锻炼的机会，还给同事留下坏印象。 误区3.被语言暴力激怒后就乱了章法一旦判断清楚对方无理取闹，我们要不为所动，一方面继续工作，一方面要让对方有个交代。 误区4.疏于沟通大部分时候，提前打个招呼是一个良好的、职业的做事方式。 四个办法来破局 任何时候为人都要谦卑。这样能更有效地沟通。一个既谦卑又能把事情分析得入木三分的人，最让人钦佩。 对待语言暴力和其他故意伤害：首先反省，在确认不是自己的问题后，把周围同事分为 3 类，针对对我们施暴的一类，搞清楚他们的目的，主动沟通。沟通的目的不完全是为了达成一致，更重要的是发出自己的声音。我们的大度应该表现在指出施暴者错误之后的宽容，而不是在是非问题上没有原则。 永远明确工作的目的是为了自己，为了自己的职业发展这个既定的大方向。主动多做事，多帮助和支持老板和团队。 注重长期效益，把一件事放到两三年的周期来看待。（Think Bigger) 职业员工和管理者要注意的两件事 如果一个开发人员不清楚自己所做的产品赢利能力如何，是非常危险的。 最有效的沟通是在第一时间直接给出答案，然后补充解释。 善于沟通的人会理解对方提问的目的，然后提供有用的信息，而不是按照自己的意思解释字面上的问题。 许多管理者也缺乏沟通能力，他们的问题可能不在回答问题上，而是在讲清楚一件事，说服别人相信自己的想法方面。 大部分人在介绍自己的项目时都存在这样一个问题：为了强调他们所做的事情很重要，先要做较长时间的背景介绍，最后自己要做的事情反而没有讲清楚。……到了第10个项目，当主讲人还要介绍背景时，我马上打断了他，让他简简单单地告诉我们要解决什么问题、他们是怎么做的。 为了让对方重视而夸大其词，这种做法常常适得其反。……为了夸大自己的工作，把一些无关紧要的事情也拿出来讲，这样反而将自己真正贡献比较大的工作淹没在泛泛而谈之中。 很多管理者工作中的第二个问题是不了解细节，和前面讲的很多专业员工缺乏大局观恰好对应。 在一个大公司，一个总监为了自己的提升，扩张队伍，把一件小事往大了做，是公开的秘密；一个行政单位更是如此。……作为领导，如果不了解细节，整个部门就不可能有高效率。 职业中的帝道、王道与霸道如何突破职业天花板？一个人能够走多远和很多因素有关，其中有一些是自身可控的因素。在这些因素中，一个人的立意至关重要，目标设置错了，结果肯定好不到哪里去。 错误的立意给秦国带来的悲剧……第一次商鞅讲尧舜禹汤的帝道，讲了半天，秦孝公都听得睡着了……这一次商鞅讲文王、武王的王道，秦孝公听了有点兴趣，说这个人可以在一起聊聊天……第三次，商鞅以霸道游说孝公，和孝公聊了五霸之事，孝公听得津津有味……“既然你知道大王的心思是富国强兵、称霸诸侯，为什么前两次还要和他谈帝道、王道？”商鞅说：“我是怕如果他真是一个有大志向的人，我一开始就说那些低层面的事情，把他看低了。”……“这样一来（急功近利），国运终究不可能超过商朝和周朝。” 拿破仑总结自己一生的成就，最为自豪的却是这部法典。……他一开始就把立意定在确立一个资本主义的现代国家上，而不只是军功和征服，他追求的是帝道而不是霸道。 秦孝公想用短期的方法达到长期的目标，这是不可能的。……并不存在一种不需要投入就能获得很高回报的行业，否则，这个行业一定太挤，以至一段时间后行业的回报肯定会急剧下降。 ……这些人追求的，只能算是低层次的“术”，甚至连霸道都算不上。 有道是，求其上者得其中，求其中者得其下。一个人如果本身追求的层次就在中下，是不可能靠运气不断进步的。 有后劲儿的人有着更广的视野，而这种视野常常来自良好的博雅教育。……这些人在学校追求的是类似于帝道和王道的大道（具体的数字对比，可以翻看《大学之路》）；相反，那些学习了一个好专业的人，不过是掌握了一些霸道而已。 职业完美进阶：常识、科技和艺术 所有智者都强调常识的重要性。……衡量一个专家水平最可靠的方法，就是看他们是将复杂的问题简单化，让每一个人都能理解，还是故作高深，将简单的问题复杂化。 今天，很多事情要做到极致，最后靠的是艺术，而不仅仅是技术。 简单讲，任何事情从 0 分做到 50 分靠的就是常识……真理被大多数人认识之后，也就成了常识。 如果我们做事情想从 50 分的水平提高到 90 分，仅靠常识或常识性的知识就不够了，需要靠先进的科学和技术。……科学和技术的一个特点是具有可重复性。 技术的另一个特点是，几乎每个人遵循一定的步骤都能学习和掌握，但是艺术则要靠天赋。……有的单位非常注重对人的培养，其实就是将那些不断重复的、属于技术范畴的做事方法和管理方法教给大家。 商业的本质让人多花钱而不是省钱 互联网帮我们节省了时间和金钱，我们多出来的时间和金钱应该拿来干什么？多数人做不到学习和投资，这不是志向的问题，而是人性使然。 随着经济水平提高，人们对娱乐和享受的需求越来越强烈。 在互联网时代，购物、看影视剧这类事情可以在网上完成，有很多平台来承载，它们彼此竞争非常激烈。但是线下生活的平台反而没有人投资去做。（以增田宗昭的茑屋成功为例，我这里想到了一个和养老产业结合的机会。） 商业的本质是让人多花钱，而不是省钱。如何让人们愿意花钱，这是艺术。 从事物的本质出发，找到那些随大溜的人忽视的机会。 互联网（这样的新技术）只是手段，而不是目的。 不给选择：经营和管理的秘诀 不给用户太多的选择，销售和服务才能让客户满意。（我的理解是，人面对太大的不确定性会恐惧。） 林璎将乔布斯的设计理念概括成一句话：少就是多。 对内管理上，不给太多选择也有利于提高管理的效率和员工的幸福感。 我们不是神，没有能力让所有人都满意。 适度的选择给我们自由，过多的选择会适得其反。 “第三眼美女新产品”在市场上成功的三个阶段 正因为她们可能没有光鲜的外表，如果依然吸引人，那么必定有某种美德或者价值。而对于欣赏这种美德或者价值的人来说，他们对第三眼美女的细化会持续很久，除非这种美德或价值不再存在或者过时了。 理性的投资观金钱观一、钱是上帝存在你那里的，不是给你的，回头你要还给他。 做任何事都是有代价的，挣钱也是如此。 爱惜身体，多享受生活，多陪伴孩子。否则这些会成为挣钱所付的的代价。 超过自己的能力去挣钱，即使有所收获，各种成本也会太高，并不合算。 二、钱只有花出去才是你的。 三、钱和任何东西，都是为了让你生活得更好，而不是给你带来麻烦。 四、钱是挣出来，不是省出来的，而挣钱的效率取决于一个人的气度。 好好说话讲话做事都要达到目的我们在做报告或演讲时，目的是让听众接受我们要传递的所有信息。不会演讲的人除了忘掉讲话的根本目的，还常常会犯3个毛病： 缺乏对听众的针对性（听众是谁、背景知识如何）； 试图在有限的时间里讲完更多的内容，而不顾及听众的接受速度与专注程度； 哗众取宠，危言耸听，却不在内容的质量上下功夫。 不仅讲话、沟通要达到目的，做什么事都应该如此。如果做事只看辛劳和苦劳，不仅上级不会满意，周围的人也会觉得我们不靠谱。 谈谈讲理的方法赵小兰采访中的技巧： 观点鲜明，没有那种“既要……又要……”和稀泥的废话逻辑。 肯定和认同对方的观点，但是用事实说明他们的行为违背了自己的观点。 批评别人非常委婉，从没有使用“unfair”这个词，或者其他表示愤怒的词。 赞扬亚裔时理直气壮。 我们很多人讲话的一个毛病是，夸自己时不好意思，批评别人时说得难听而且缺乏根据；赵小兰则相反。 我们靠什么说服人 事实比口才更重要。布鲁诺（无意中）采取了下策（具体在 p330-331）。在职场上，像布鲁诺那样掌握了真理而敢于直言的挑战者固然可敬，但像伽利略那样拿出证据的建设者却更加有用。 很多时候，宣传新思维的人比提出新思维的人作用更大。我们在寻找合作伙伴时，常常想找到一个想法和我们完全一致、我们认为非常完美的人，但是这种人可能并不存在。为了宣传（布道）我们的想法，我们更需要像赫胥黎这样的人，他们不完美，甚至看法并不和我们完全一致，却能坚持不懈地帮我们传播想法。 如果一件好事得不到支持，我们常常需要两类同盟军。一类是像赫胥黎那样捍卫我们思想的人，另一类是理性地帮我们找到证据的人。聪明人总是善于借力的。 不要报喜不报忧。好的体制，要让动力来自底层，而刹车和制动系统掌握在高层手里。]]></content>
      <categories>
        <category>书中所得</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[珍爱 APP 直播间见闻录]]></title>
    <url>%2F2019%2F07%2F03%2F%E7%8F%8D%E7%88%B1-APP-%E7%9B%B4%E6%92%AD%E9%97%B4%E8%A7%81%E9%97%BB%E5%BD%95%2F</url>
    <content type="text"><![CDATA[什么妖魔鬼怪都有夜半语音中专女：怼天怼地怼空气专注变美20年：谈变得更优秀的方式我在等我大哥，我后备箱有枪职场失意，何不调戏小女生两个销售一台戏，编故事不打草稿窥视人生百态剩女的深夜高级茶话会高素质的夕阳红奶奶群体集万千宠爱，但仍在等待慧极必伤，情深不寿找对象的正确方式明确你的目标和择偶目标发现目标以后，你要专注不忘初心，不离不弃寂寞人生要耐得住寂寞]]></content>
      <categories>
        <category>岁月如歌</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《外婆的道歉信》微信读书笔记]]></title>
    <url>%2F2019%2F06%2F30%2F%E3%80%8A%E5%A4%96%E5%A9%86%E7%9A%84%E9%81%93%E6%AD%89%E4%BF%A1%E3%80%8B%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[外婆的道歉信弗雷德里克•巴克曼 加的一个读书会 QQ 群推荐阅读的，跑步的时候听了前几章，意料之外的好。阅读总共花了8小时。 点评★★★★★ 每个七岁的小孩都该拥有一位超级英雄罗辑思维有一期节目《父亲悖论》里讲到过，“父亲”这个身份包括了五个成分，分别是：供养、护佑、规训、传道、胜利。 五条标准，其实割裂成了两部分。前三条，和妈妈承担的责任类似，其实指的是要当“好妈妈式的爸爸”。而后两条，就是传道和胜利功能，也就是我们希望的那种“坚强、胜利的父亲”。 我想，“坚强、胜利”这样的品质是孩子所崇拜的吧，就像崇拜一个英雄。 这本书中，扮演“超级英雄”角色的是外婆。人们都爱她，唯独她自己的女儿恨她，这也是因为“英雄”心中总会先考虑多数人，所以无法兼顾做一个“好妈妈”。 守护与救赎，魔法与童真这是一个有关守护与救赎的故事。 “超级英雄”外婆守护着 Elsa 以及房子里的人们，之后又将“守护”的使命传承了下去。新的守护者促成了人们相互原谅，人们获得救赎。 我对这本书的评价很高，主要有以下两个原因： 语言风格像极了J.K.罗琳，字里行间透露出无厘头的幽默感，充满了魔力。人物刻画也因此有血有肉，充满个性（当然，大量细节描写和作者的精巧构思也功不可没）。书中 Elsa 对于《哈利波特》如数家珍，当然还有漫威系列……作者本人也是个老顽童吧。 以 Elsa 这个聪明的女孩为主角，然后以纯洁天真的口吻道出许多哲理。不禁令人联想起圣埃克絮佩里的神作《小王子》——它们都是必须抱着哪怕仅剩的一点童真去认真体会的故事，体会那治愈心灵的温情。 以上两个特点结合在了一起，给人一种独特的体验。 笔记这本书因为有 1/3 左右是听的，而且读得比较快，所以笔记不多。不过认真做笔记的话真的会太多了，而且说不定会剧透。 1．烟草 只因为爱莎这个七岁小孩没有表现得特别蠢，就好像她有什么精神问题，或是在故意卖弄。 我的心得是，人得学会装傻。引用网络上的一段话：孔子发现了糊涂，取名中庸；老子发现了糊涂，取名无为；庄子发现了糊涂，取名逍遥；墨子发现了糊涂，取名非攻；如来发现了糊涂，取名忘我。 3．咖啡 这些会议显然非常无聊。首先，每个人会就上一次会议时争论的东西再吵一遍，然后大家查看各自的日程，就下一次会议何时召开争执一番，之后会议就结束了。 这大概就是民主的弊端了。 5．百合花 老师们错了，爱莎没有注意力问题。她只是将注意力集中到了正确的事情上。外婆说，脑子迟钝的人总是说脑子灵敏的人有注意力问题。“蠢货们不明白，在他们想清楚一件事之前，聪明人早就想明白并开始想下一件事了。所以蠢货总是感到害怕，有攻击性。没有什么比一个聪明姑娘更让他们害怕的了。” 7．皮革 因为所有事物都将失去魔力。 13．红酒 不是所有的怪物一开始都是怪物。有些因为悲伤才变成了怪物。 也不是所有的怪物看起来都像怪物。想起了《爱，死亡，机器人》里的某一集。其实很早之前，手冢治虫的漫画《火鸟》中就有一个故事：一个人受重伤康复后，把怪物看成美丽的女孩、把人看成怪物。《沙耶之歌》游戏也是从这里得到的灵感。 14．轮胎 在太平的日子里，其他医生就算死都不想被人看见他们和外婆待在一块儿，但当世界分崩离析时，他们会像一支军队般追随她。因为超乎寻常的悲剧造就非同一般的英雄。 20．服装店 童年的时候所有事情都呈现最好的模样，然后就开始走下坡路…… 但她不想让他失望，所以保持了安静。因为保持安静的时候，你基本上不会让人失望。所有即将八岁的孩子都知道。 那个时候，亲戚们对我的评价就是“文静”。尴尬。 32．玻璃 生命真正的陷阱在于几乎没有人是彻头彻尾的混蛋，也几乎没有人从未做过混蛋事。生命的难处就在于尽可能多地待在“不是混蛋”这一侧。 “人希望被爱，”布里特-玛丽引用道，“若没有，那么被崇拜，没有被崇拜，那么被畏惧，没有被畏惧，那么被仇恨和蔑视。人想给他人注入某种感情。灵魂害怕真空，不顾一切代价，它向往接触。” 这里是引用《格拉斯医生》，呼应前文“不是所有的怪物一开始都是怪物，有些是因为悲伤才变成了怪物”。之前为了说明同一个道理，也引用过尼采的那句“与恶龙缠斗过久，自身亦成为恶龙。凝视深渊过久，深渊将回以凝视。”书中还引用过许多其他书、电影中的台词，Elsa 是喜欢看书的孩子。 布里特-玛丽还在候诊室中。一个人。如果她现在离开，也许没人会记得她曾经来过。她就这件事思索了片刻，然后掸去桌沿上看不见的什么东西，拉直裙子上的一条皱褶，站起身，离开了。 为了对抗孤独倾尽全力，却还是以离去收场。在这本书中是个悲剧人物，后来作者的第三部作品是以她为主角写的。 33．婴儿 有些人不需要说话也能成为朋友。 《高分少女》里面的女主角就是，从头到尾没有一句台词，但男主却能懂她的意思，还喜欢和她一起玩游戏。 马塞尔合手，难过并快乐地点点头，就好像吃了一个很大的冰激凌但同时意识到已经吃完了。 幸福容易消逝，珍惜时光吧。 34．外婆 “那你们为什么在一起？”“因为我们接受彼此本来的样子，大概吧？”“而你和妈妈想要改变对方？”他靠近，亲了一下她的前额。“我有时候担心你太聪明了，亲爱的。” 父亲与 Elsa 的对话，第一句中的“你们”指父亲与他现在的妻子。爱是克制，不是控制。求偶不是找一个最爱的人，而是找一个让自己变得更好的人。]]></content>
      <categories>
        <category>书中所得</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[许岑：如何有效训练你的研究能力？]]></title>
    <url>%2F2019%2F06%2F26%2F%E8%AE%B8%E5%B2%91%EF%BC%9A%E5%A6%82%E4%BD%95%E6%9C%89%E6%95%88%E8%AE%AD%E7%BB%83%E4%BD%A0%E7%9A%84%E7%A0%94%E7%A9%B6%E8%83%BD%E5%8A%9B%EF%BC%9F%2F</url>
    <content type="text"><![CDATA[许岑对于提升研究能力的建议如下。 训练研究能力，须要具备3个意识： 作品意识，是研究的驱动和起点； 目标意识，防止研究过程跑偏； 局外意识，跃于研究文本之外，探寻事物本质与规律。 为研究付出的成本往往是巨大的，它包括财务、时间、精力，还有试错。有时候你的研究能力差，只是因为你付出的成本还远远不够。 搜集资料既要足量，又要节制。 足量需要做到： 主动性：超强的主动性是资料搜集做到足量的保证； 宽泛性：评判足量要足到什么程度。 节制需要做到： 第一不能过度沉溺于研究文本，以至于偏离原始的研究方向； 第二是去粉丝化； 第三是去情绪化（尤其在研究艺术时）。 用批判性思维去处理资料，把握两个方向： 抓本质（做对比，找不同）； 找规律（做类比，求相似）。 研究结论成果化，最好的形式是写作。用相对学术的标准要求自己，具备学术性的三个基本特征： 系统性，有合理的结构和维度，最好做到MECE法则（完全穷尽、互相独立），足量的信息是保障； 文本支持，在研究过程中的判断不能凭想象； 要基于严密的逻辑论证。 学术论文的写作要点有： Validity 正确性 Reliability 可靠性 Continuity 可持续性 Universality 普适性 掌握英文才能做深入研究。硬着头皮去看跟你的研究领域密切相关的英文资料，边看边学习其中的陌生词汇。]]></content>
      <categories>
        <category>高屋建瓴</category>
      </categories>
      <tags>
        <tag>科研</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS 中的 apply, call, bind]]></title>
    <url>%2F2019%2F06%2F25%2FJS-%E4%B8%AD%E7%9A%84-apply-call-bind%2F</url>
    <content type="text"><![CDATA[目标： 理解 JS 中 apply, call, bind 特点 了解 JS 中 apply, call, bind 运用案例 apply, call目的：对象冒充，改变函数运行时的上下文（context），即改变函数体内 this 的指向。 apply, call 的作用完全一样，只是接收参数的方式不一样。 12fn.apply(this, [a1,a2]);fn.call(this, a1, a2); 使用场景数组之间追加1234var arr1 = [22, 23, 25];var arr2 = [45, 128, 600];Array.prototype.push.apply(arr1, arr2); // 相当于 arr1.push(45,128,600)console.log(arr1); // [22, 23, 25, 45, 128, 600] 如果使用 arr1.push(arr2) ，输出结果为 [22, 23, 25, Array(3)] 。 获取数组中的最大值和最小值1234var arr1 = [22, 23, 25];var maxNum = Math.max.apply(null, arr1);// BOM 环境下 null 相当于 window ； Node 环境下 null 相当于 global 。当然这里写 Math 也是一样的。console.log(maxNum); 数组是没有 max 方法的，通过 apply 能够让数组使用 Math 的 max 静态方法。 验证是否为数组1Object.prototype.toString.call(obj) === &apos;[object Array]&apos; 类数组使用数组方法函数中的 arguments 就是类数组。1var args = Array.prototype.slice.call(arguments, 1); 扩展：什么是类数组？比如下面的对象。属性要为索引属性，必须要有length属性，最好加上push1234567var obj = &#123; &quot;0&quot;:&quot;a&quot;, &quot;1&quot;:&quot;b&quot;, &quot;length&quot;:2, &quot;push&quot;:Array.prototype.push, &quot;splice&quot;:Array.prototype.splice&#125; bindbind() 方法会创建一个新函数。当这个函数被调用时，bind() 的第一个参数将作为它运行时的 this。（详见MDN web docs） 典型使用场景123456789101112this.num = 1; // this 指向 windowvar mymodule = &#123; num: 2, getNum: function() &#123; console.log(this.num); &#125;&#125;mymodule.getNum(); // 输出2var a = mymodule.getNum;a(); // 输出1 需求：我们希望 a() 输出的也是 2。虽然可以用 a.call(mymodule)，但是这里希望还是使用 a()，于是可以使用 bind：1var a = a.bind(mymodule); 串联 bind 会发生什么？123456789101112131415161718192021var bar = function() &#123; console.log(this.x);&#125;var foo = &#123; x: 1&#125;var foo1 = &#123; x: 2&#125;var foo2 = &#123; x: 3&#125;var func = bar.bind(foo);func(); // 1var func1 = bar.bind(foo).bind(foo1);func1(); // 1var func2 = bar.bind(foo).bind(foo1).bind(foo2);func2(); // 1 bar 函数执行离 foo 对象最近。（须要分析 bind 的源码） 三者的比较 apply, call, bind 都是用来改变函数的 this 的指向的； apply, call, bind 的第一个参数都是 this 要指向的对象，也就是指定的上下文； apply, call, bind 都可以传参； bind 是返回对应函数，便于稍后调用；apply, call 则是立即调用。 参考：Javascript 中 call、apply 和 bind 的区别以及源码解析]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我与健身——大学生活回忆系列]]></title>
    <url>%2F2019%2F06%2F23%2F%E6%88%91%E4%B8%8E%E5%81%A5%E8%BA%AB%E2%80%94%E2%80%94%E5%A4%A7%E5%AD%A6%E7%94%9F%E6%B4%BB%E5%9B%9E%E5%BF%86%E7%B3%BB%E5%88%97%2F</url>
    <content type="text"><![CDATA[以下内容修改自2016年5月24日（大三下）我在公众号发表的文章《身体革命》 健身缘起大一时突然写了句QQ动态： 想要健身的念头源于村上的小说《海边的卡夫卡》，健身花去的时间却让我无暇阅读小说。 看那本书时我正上高二，常去图书馆借阅书籍。那时我住在学校且有一堆热爱篮球的同学作伴。平日里三天两头抱着球奔向操场抢占火爆的篮球场，所以虽然在寝室也弄弄哑铃、腹肌轮，但并不热衷于此。 小说中的主角田村卡夫卡也是一个内向的15岁少年，几乎没什么朋友。他只身来到另一座城市，书中有段描述是讲他在入住旅店时，由于平时有健身的爱好，所以体格比同龄人壮实一些，倒也没有人怀疑他的年纪。健身使人成熟、自信，这便是我的第一印象。 除了受这本小说的影响之外，有一次我偶然目睹健身房里刚出来的中年大叔露出长袖下粗大而结实的前臂，也被小小得震撼了一下。当时我的体重只有60kg，虽然体育课长跑还不错，但是自知上半身实在过于瘦弱，与常年磨炼的下肢不成比例，必须加强。于是就在高考前计划着暑假要去练练了。 不得不提的还有我班上的“丁哥”和“豪哥”两个大肌霸。后者崇尚徒手健身，天赋身板厚实；前者身为企业家之后，家里就有健身房，父亲本身就是个练得不错的健身爱好者。 相关阅读：《海边的卡夫卡》微信读书笔记 从兴趣到乐趣高考结束后，我定的三个计划其中之一是健身，另外还有一次打工。结果证明，去酒店底层打工真是累死人，想要抽出时间和体力健身几乎不可能了。 那次暑假我只在自家边上的“洲际”健身房摸了一次哑铃还有器械，之后便再没去过那家店。不过混迹百度贴吧健美吧，倒也学习了不少理论知识，还渐渐接触到了《施瓦辛格健身全书》、《囚徒健身》这样的健身入门经典书籍。 上了大学之后我便买了一对重量尚可的哑铃摆在寝室，大一那会儿没事就练练卧推飞鸟和弯举什么的，还常去户外练习单双杠。收获便是报名参加校园体能明星大赛得了个奖状；体育课测双杠曲臂撑做了42个，超越了满分标准15个。 大二上我在学校健身协会混迹了一个学期，认识了一个学校贴吧里的学长。拜他所赐，我关注了几个高质量健身公众号，还认识了几个健美明星，罗尼、西斯…… 由于10月份报名了越野比赛，之前那段暑假本就因学车而时间不多的我在健身房一跑就是5公里（不过也就20分钟不到）。开学后在操场不停刷圈，十几二十圈地跑……但到比赛当日还是因为复杂的路况（这越野跑简直就是在爬山）和超长的距离，两个半小时之后到达终点便无法站立成为半残废状态。 由于我是外胚（瘦）体质，想要塑造健壮的身材，之后我便不怎么练习有氧运动了。每次去健身都是直接做力量训练，做完走人。 寒假回家后，我无语地发现健身房在装修，只能在家里研究研究徒手健身，在小区的健身设施处装逼。 从乐趣到志趣大二下半学期4月份时，我来到了学校东南的仙河苑，拜访了“雪浪”健身房。这是我个人最赞的一家健身房了，里面基本都是真正热爱健身的中年大叔，破旧的质感仿佛经历了好多年的样子，桌面上扔了好多往年的《健与美》杂志。虽然离学校远了点，但是不能阻挡我连刮风下雨时都骑车去锻炼的美好心情。那段时间频繁骑自行车十几分钟去健身，然后因为除了我就没什么人了，可以肆无忌惮地自拍、发微博打卡： 不过5、6月份我又干起了兼职，在一个不到一平米的低矮房间里洗碗。每天工作时长6到7小时，加上一边上课、一边去 5km 外仙河苑的健身，睡眠也不够，体重不增反降。 再后来的暑假，两个月的时间我做了两份实习。前一个月干的是体力活，时间占用也多，我只有偶尔在晚上回到宿舍做做囚徒健身。第二个月我去了深圳的一个小服装作坊做设计师助理，平时只是采采样，也没多少工作量。一番考察之后，我干脆在我住的小区找了一家健身房，办月卡，下班之后的晚上来练。 之后便是大三上学期了，我10月份办了博大假日广场“半球”健身房的健身卡，然而这边迟迟不开业，害我每晚6点坐公交车去阳光广场的老店，花费不少时间在路上，回学校就9点多了，自习只能在偶尔没课的时候抽出一个半小时。这段时期，我的身体接近巅峰状态，从当时的体脂测试表中可以看到，我的体脂率只有12%、脂肪成分很低、肌肉量足。 大三下学期，学校旁边的健身房才终于开业。这段时间我的体重稳定在67~68kg，基本就是标准体重。身材可以，但是肌肉量并不够多，体重还是过轻了。Y型的胸腰差也买不到合适版型的衣服，平时也没什么浪骚的机会。 上次去“半球”健身房，一教练对我说：“小半年了，你这肌肉也没怎么长呀。”我笑笑：“我一直就这样，随便练练而已。” 在我而言，健身的意义不一定是练成大肌霸。更重要的是，用健身带来的自律感，对抗大学时光中找不到意义所产生的焦虑感。坚持健身，其实是培养一种自律的生活态度、一种良好习惯。如果我的大学生活中少了健身，将成为一种遗憾。 结尾奉上 gif 三连（15年左右用笔记本摄像头拍的）： 相关阅读：大学前三年的简短回忆]]></content>
      <categories>
        <category>岁月如歌</category>
      </categories>
      <tags>
        <tag>生活</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[入行 AI，怎么选择有效的技术培训]]></title>
    <url>%2F2019%2F06%2F22%2F%E5%85%A5%E8%A1%8C-AI%EF%BC%8C%E6%80%8E%E4%B9%88%E9%80%89%E6%8B%A9%E6%9C%89%E6%95%88%E7%9A%84%E6%8A%80%E6%9C%AF%E5%9F%B9%E8%AE%AD%2F</url>
    <content type="text"><![CDATA[自学的困境： 精力分散，不够专注，书读不下去，代码看不下去。 深层原因：驱动力不足以让自己专注。 根本原因：没有足够渴望的目标，无法调动自身能量形成驱动力。 归根结底：学不下去是因为不知道学习是为什么、学了到底有什么用。 漫无目的的学习 = 浪费时间 什么是有效学习？有效学习 3 要点： 目标明确 系统性强 足够深入 什么样的目标才算明确？真正的目标必须有可实施性，并最终体现为具体实施计划。 如何明确目标？想入行 AI ，先搞清楚： 目前真正落地的 AI 领域有哪些？ 每个领域有什么样的代表企业？ 这些企业中，有什么样的技术岗位？ 每种岗位都需要什么入门条件？ 定位到目标岗位，明确这类岗位的技术要求，才有可能确定需要学习的内容有哪些。 如何划定明确的计划？推荐如下的调研步骤： 确定一个领域（图象、语音、NLP 等）。如果了解不多，多爬一些招聘网站、职场社交媒体的招聘信息，做一下数据分析。 了解本领域当前的科研状况。最简单的方法：找十篇本领域核心期刊或会议的论文，读一遍。 了解本领域理论的落地技术以及相关企业。普遍来说，进大公司是为了公司，而进小公司是为了跟人。如果有感兴趣的小公司，不妨先评估一下技术合伙人的学术水平。 了解具体岗位（同一类型公司的同一技术角色）的招聘需求。AI行业的技术岗位分为3类：科学家、工程师、工程辅助。 很多人直接从 Step1 调到 Step4，不看论文，不学理论，直接报个班学习 Python, TensorFlow ，这属于典型的被“捷径”误导。哪怕是工程辅助，如果想要做得长久、有所发展，理论学习是必不可少的。 制定学习计划：先把知识结构的骨干勾勒出来，再在其中填注知识点。这里的关键一点是，计划中最小粒度的“知识点”到底有多大。 个人意见，学习计划中的最小单位，如果不脱产学习，掌握它的时间不应该超过一周；如果全脱产，最好不要超过2天。 如果你自己都不知道想要学习什么东西，又怎么能够正确判断一门培训课程的质量呢？毕竟，培训（不止是培训，其实所有教学都是如此）要有效，一定是教师和学生双方配合的结果。 培训课程的作用，无外乎两点： 讲解细致，合格的课堂丰富、细腻、包容性强 和老师直接交流，反馈及时（有答疑） 搜寻有效培训的途径先从免费资源开始。 AI 领域有少量非常经典的线上培训课，是完全免费的。Andrew Ng 的 Machine Learning 是一定要从头到尾学一遍的。 通过书籍、社群等，去搜集大家的学习经验和各种培训班的信息。 在尽量广泛地收集了大量培训信息后，对照课程大纲和自己的学习计划进行选择。 按优先级裁剪个人计划。确保核心知识和大体结构，在细节上做出妥协。 有效学习的几点提示 关联——理论结合实际； 记录发现、感想、经验、疑问，隔段时间整理笔记； 分享——倒逼自己整理体系、记忆要点； 定制知识速查手册，AI 涉及到的数学特别多，符号系统复杂。]]></content>
      <categories>
        <category>高屋建瓴</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>方法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解 JS 异步]]></title>
    <url>%2F2019%2F06%2F21%2F%E7%90%86%E8%A7%A3-JS-%E5%BC%82%E6%AD%A5%2F</url>
    <content type="text"><![CDATA[总结一下当前 JS 异步解决方案 jQuery Deferred, 解决 callback 问题的原始方法 Promise, 许多浏览器已经原生支持 async/await, 使用了同步的写法 Generator, ES6 标准中的模块 不讲 Generator 的原因： 原理复杂，学习成本高 不是异步的直接替代方案（它的提出是为了解决其他问题） 有更好的更简洁的解决方案 async/await KOA 也早已“弃暗投明” 单线程是什么，和异步有什么关系？单线程JS 只有一个线程，只能同时做一件事。比如只要循环在运行或者 alert 不处理， JS 执行和 DOM 渲染就会暂时卡顿。 JS 执行时，浏览器 DOM 渲染要暂停 两段 JS 也不能同时执行 原因：避免与 DOM 渲染的冲突。 webworker 支持多线程，但是不能访问 DOM。 异步是一种“无奈”的解决方案。先执行其他 JS 代码，再回过头执行异步的代码。 问题： 没按照书写顺序执行，可读性差 callback 中不容易模块化 什么是 event-loop 事件轮询？event-loop 是 JS 异步的 实现方式/解决方案。 同步代码，直接执行 异步函数，先放到异步队列中 如果延时，就等计时结束后再放入队列 如果 ajax ，就等 ajax 加载完成后再放入队列 待同步函数执行完毕，轮询执行异步队列的函数 轮询：定时发出询问，并不断循环。 是否用过 jQuery 中的 Deferred？并不是所有网站都是用到 前端框架，仍然有很多在使用 jQuery。 列举 jQuery 1.5 对 ajax 的改变； 说明如何简单地封装、使用 deferred （defer 意为“推迟”）； 说明 deferred 和 promise 的区别： promise 不允许对 deferred 对象进行主动修改。 jQuery 1.5 的变化 从写法上杜绝 callback 这种形式 是一种语法糖，但是解耦了代码 体现了开放封闭原则 jQuery 1.5 之前只支持这种写法：123456789101112var ajax = $.ajax(&#123; url: &apos;data.json&apos;, success: function() &#123; console.log(&apos;success1&apos;) console.log(&apos;success2&apos;) console.log(&apos;success3&apos;) &#125;, error: function() &#123; console.log(&apos;error&apos;) &#125;&#125;)console.log(ajax) //返回一个 XHR (XMLHttpRequest) 对象 jQuery 1.5 之后可以这样写：1234567891011var ajax = $.ajax(&apos;data.json&apos;)ajax.done(function() &#123; console.log(&apos;success1&apos;) &#125;) .fail(function() &#123; console.log(&apos;error&apos;) &#125;) .done(function() &#123; console.log(&apos;success2&apos;) &#125;)console.log(ajax) //返回一个 defferred 对象 也可以这样写：1234567891011var ajax = $.ajax(&apos;data.json&apos;)ajax.then(function() &#123; console.log(&apos;success1&apos;) &#125;, function() &#123; console.log(&apos;error1&apos;) &#125;)ajax.then(function() &#123; console.log(&apos;success2&apos;) &#125;, function() &#123; console.log(&apos;error2&apos;) &#125;) 使用 jQuery Defferred给出一段非常简单的异步操作代码：12345678910var wait = function() &#123; var task = function() &#123; console.log(&apos;执行完成&apos;) // 复杂操作 &#125; setTimeOut(task, 2000)&#125;wait() 需求：要在执行完成之后进行某些特别复杂的操作，代码可能很多，而且要分成好几个步骤。 1234567891011121314151617181920212223242526function waitHandle() &#123; var dtd = $.Deferred() //创建一个 deferred 对象 var wait = function(dtd) &#123; //传入一个 deferred 对象 var task = function() &#123; console.log(&apos;执行完成&apos;) dtd.resolve() // 表示异步任务已经完成 &#125; setTimeOut(task, 2000) // 要求返回一个 deferred 对象 #1 return dtd &#125; // 注意，一定要有返回值 return wait(dtd)&#125;var w = waitHandle()w.then(function() &#123; console.log(&apos;success1&apos;) &#125;, function() &#123; console.log(&apos;error1&apos;) &#125;)w.then(function() &#123; console.log(&apos;success2&apos;) &#125;, function() &#123; console.log(&apos;error2&apos;) &#125;) deferred 对象的 API 可以分为两类： 主动触发： reslove reject 被动监听： then done fail 由于两类 API 混在一起，w.resolve() 和w.reject() 可以被主动使用，容易造成错误。 将上面代码 #1 那句改为 return dtd.promise()，不直接返回 deferred 对象，而是返回一个 promise 对象。这时再执行 w.reject() 会报错。调用者只能监听。 Promise 的基本使用和原理基本语法12345678910111213141516171819202122232425function loadImg(src) &#123; var promise = new Promise (function (resolve, reject) &#123; var img = document.createElement(&apos;img&apos;) img.onload = function () &#123; resolve(img) //将 img 返回给成功的回调函数 &#125; img.onerror = function() &#123; reject() &#125; img.src = src &#125;) return promise&#125;var src = &apos;http://www.imooc.com/static/img/index/logo_new.png&apos;var result = loadImg(src)result.then(function(img) &#123; console.log(1, img.width) return img //否则链式操作的下一个成功回调函数接收的 img 是 undefined&#125;, function() &#123; console.log(&apos;erorr 1&apos;)&#125;).then(function(img) &#123; console.log(2, img.height)&#125;) 低版本浏览器可能不支持 Promise 语法，这时需要在 HTML 的 script 标签中引入 bluebird 脚本（在 BootCDN 上面查找）。 异常捕获123456789// 规定： then 只接受一个成功的回调函数，最后统一用 catch 捕获异常result.then(function (img) &#123; console.log() return img&#125;).then(function (img) &#123; console.log()&#125;).catch(function (ex) &#123; console.log(ex)&#125;) 当使用 catch 时，reject() 中要传入参数，比如改为 reject(&#39;图片加载失败&#39;)。这样逻辑错误（非语法错误）才能被 catch 捕获到。 多个串联链式执行12345678910111213var src1 = &apos;http://www.imooc.com/static/img/index/logo_new.png&apos;var result1 = loadImg(src1)var src2 = &apos;http://www.imooc.com/static/img/index/logo_new.png&apos;var result2 = loadImg(src2)result1.then(function (img) &#123; console.log(1, img.width) return result2 //重要！否则下一个 then 仍然是 result1 的回调&#125;).then(function (img) &#123; console.log(2, img.width)&#125;).catch(function (ex) &#123; console.log(ex)&#125;) Promise.all, .race12345678910111213141516171819var src1 = &apos;http://www.imooc.com/static/img/index/logo_new.png&apos;var result1 = loadImg(src1)var src2 = &apos;http://www.imooc.com/static/img/index/logo_new.png&apos;var result2 = loadImg(src2)// Promise.all 接收一个 Promise 对象的数组// 待全部完成之后，统一执行 successPromise.all([result1,result2]).then(datas =&gt; &#123; // 接收到的 datas 是一个数组，依次包含了多个 promise 返回的内容 console.log(datas[0]) console.log(datas[1]) //打印出&lt;img src=...&gt;，即 img 变量&#125;)// Promise.race 接收一个包含多个 Promise 对象的数组// 只要有一个完成，就执行 successPromise.race([result1,result2]).then(data =&gt; &#123; // data 即最先完成的 promise 的返回值 console.log(data)&#125;) Promise标准 任何技术推广都需要一套标准来支撑。无规矩不成方圆 任何不符合标准的东西，终将会被用户抛弃 不要挑战标准，不要自造标准 状态变化三种状态：pending, fulfilled, rejected 初始状态是 pending （pend 意为悬而未决） pending 变为 fulfilled，或者 pending 变为 rejected 状态变化不可逆 then Promise 实例必须实现 then 这个方法 then() 必须可以接收两个函数作为参数 then() 返回的必须是一个 Promise 实例 如果没有明文返回 Promise 实例，默认返回调用该 then() 的 Promise 实例 介绍 async/await ES7 提案中的语法（ES7 还不能称之为标准） Babel 已经开始支持，开发中已经在广泛使用 nodejs 中的 KOA 框架 2.0 使用 async/await 实现 没有改变 JS 单线程、异步的本质 和 Promise 的区别、联系： async/await 是 Promise 的封装，没有和 Promise 冲突。 then 只是将 callback 拆分了，传的还是回调函数；而 async/await 完全是同步的写法，如下：1234567const load = async function () &#123; const result1 = await loadImg(src1) console.log(result1) const result2 = await loadImg(src2) console.log(result2)&#125;load() 用法： 函数内要使用 await ，函数前必须加 async 标识 await 后面跟的是一个 Promise 实例 需要引入 ‘babel-polyfill’ 转译（polyfill 是兼容的意思），见 ES6 笔记]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《构建之法》笔记（三）软件工程师的成长]]></title>
    <url>%2F2019%2F06%2F20%2F%E3%80%8A%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%B3%95%E3%80%8B%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%89%EF%BC%89%E8%BD%AF%E4%BB%B6%E5%B7%A5%E7%A8%8B%E5%B8%88%E7%9A%84%E6%88%90%E9%95%BF%2F</url>
    <content type="text"><![CDATA[误区技能的反面 The Opposite of Skill我真实的“技能”值得写进简历吗？什么才是“技能”呢？技能的反面是什么？ 计算机人机交互领域科学家比尔·巴克斯顿说技能的反面是 Problem Solving ——“解决问题”。 一个IT专业的大学生来面试，简历上写“技能：精通 Visual Studio C# 编程”，于是面试官请他用 Visual Studio IDE 写一段程序。一个“不精通”的面试者的编程过程实际上就是一个“解决问题”的过程。例如： 嗯，怎么开始一个C#的命令行程序呢？ 定义数组怎么弄的？哦，我平时都是上网查的，还有MSDN网站。 嗯，为什么编译没过呢？哦，这里少一个分号。 嗯，怎么设断点？怎么定义命令行参数？呃，我要查一查…… 你发现他把时间都花在“解决（低层次）问题”上了，你想考察的“算法技能”、“C#程序设计技能”都无暇顾及。注意，这是在他认为非常精通的编程工具和编程语言中出现这样的问题。你要这样的员工吗？ 那怎么提高技能呢？很简单，通过不断的练习，把那些低层次的问题都解决了，变成不用经过大脑的自动操作，然后才有时间和脑力解决高层次的问题。在舒适区、学习区、恐慌区中，我们要在学习区中尝试、失败、学习、再尝试。 软件工程师的思维误区 分析麻痹：想弄清楚所有细节、所有依赖关系后再动手，心理上过于悲观，不想修复问题。 不分主次地想解决所有依赖问题：过于积极，想马上动手“完美地”达到目标，而不是根据现有条件找到一个“足够好”的方案。 过早优化：在某一个局部问题上陷进去，花大量时间对其优化，无视全局。 过早扩大化/泛化（Premature Generalization）：程序虽然可扩展，但是要了解必要性和难度。把小问题真正解决好，也不容易。 如何成长软件开发的工作量和质量怎么衡量呢？ 项目/任务有多大？ 花了多少时间？ 质量如何？交付的代码有多少缺陷（两个交付）？ 是否按时交付？ 初级软件工程师如何成长呢？作者认为有下面几种： 积累软件开发相关的知识，提升技术技能（如对具体技术的掌握，动手能力）。 积累问题领域的知识和经验（例如对游戏、医疗或金融行业的了解）。 对通用的软件设计思想和软件工程思想的理解。这一方面就比较虚，怎样算是好的软件设计思想？ 提升职业技能（区别于技术技能），包括：自我管理的能力，表达和交流的能力，与人合作的能力，按质按量完成任务的能力。 实际成果。 软件工程师的职业发展： 对待职业的态度 考级之路 大公司职业发展 自我评估]]></content>
      <categories>
        <category>书中所得</category>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>阅读</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《构建之法》读书笔记（一）概论]]></title>
    <url>%2F2019%2F06%2F20%2F%E3%80%8A%E6%9E%84%E5%BB%BA%E4%B9%8B%E6%B3%95%E3%80%8B%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%EF%BC%88%E4%B8%80%EF%BC%89%E6%A6%82%E8%AE%BA%2F</url>
    <content type="text"><![CDATA[《构建之法》所有参考书和链接链接汇总 知识点： 软件工程与计算机科学的关系 软件的特性 软件工程的特性与组成部分 软件=程序+软件工程例子中，我们看到客户们对阿超的需求从一个简单的程序，扩展到一个满足各种功能的应用软件，再扩展到一个能保证服务质量的软件服务。 源程序，就是一行行的代码，是建立在数据结构上的一些算法。一个复杂的软件不但要有合理的软件架构（Software Architecture）、软件设计与实现（Software Design, Implementation and Debug），还要有各种文件和数据来描述各个程序文件之间的依赖关系、编译参数、链接参数，等等。这些都是软件构建的过程。 软件 = 程序 + 软件工程软件企业 = 软件 + 商业模式 软件开发的不同阶段： 纸飞机/航模 写程序练习数据结构/算法 影响只限于自己，如果尝试失败，人们的兴趣会减弱。 爱好者的尝试 用JavaScript、ASP.NET、Ruby写写网站 程序能跑起来，自己的博客也会吸引一些读者。 先行者的探索 钻研新技术，应用新技术在软件行业创新 很多软件的原型虽然失败了，但是它们给后续的创新奠定了基础。 成熟的工业 银行软件系统，互联网搜索行业，Windows操作系统 影响一个公司、一个行业，波及相关行业和人员。 软件工程是什么软件工程是把系统的、有序的、可量化的方法应用到软件的开发、运营和维护上的过程。 包括下列领域：软件需求分析、软件设计、软件构建、软件测试、软件维护。 相关学科：计算机科学、计算机工程、管理学、数学、项目管理学、质量管理、软件人体工学、系统工程、工业设计、用户体验设计。 软件的特殊性软件和人类制造出的其他产品相比，有许多共性，也有一些特殊性。它们都解决某种需求。 许多计算机硬件的能力大致以每两年提高一倍的速度发展，而软件开发的流程却没有这样的提速过程，开发成本也没有下降，为什么？ 复杂性（Complexity）：可以说是人类创造的最复杂的系统类型。大型软件有超过百万行的源代码，上万个不同的文件。 不可见性（Invisibility）：源代码不是软件本身，工程师是看不到源代码如何具体地在用户的机器上被执行的，只能看到程序出错瞬间留下的一些痕迹。 易变性（Changeability）：软件看上去很容易修改，但正确地修改很困难。 服从性（Conformity）：软件不能独立存在，总是要运行在硬件上面，还要服从用户、行业系统的要求。 非连续性（Discontinuity）：有时输入上很小的变化，会引起 输出上极大的变化。 以上特性是由软件的本质所决定的。 软件工程与计算机科学的关系人们把下面的活动称之为工程：创造性地运用科学原理，设计和实现建筑、机器、装置或生产过程；或者是在实践中使用一个或多个上述实体；或者是实现这些实体的过程。 计算机科学（Computer Science）中的理论研究部分，大多可以从形式上证明，与数学、离散数学、数理逻辑密切相关；计算机科学中与实践相关的部分，都和数据以及其他学科发生关系；软件工程则和人的行为、现实社会的需求息息相关。这些“人”可以是项目需求的提供者，可以是软件的开发人员，还可以是软件的用户。这一特征与其他计算机科学子领域明显不同。 软件工程的知识领域软件工程这门学科到底包含了什么样的知识，这些知识又是在什么基础上建立的呢？2014年，IEEE 发布了 SWEBOK V3.0 （Software Engineering Body of Knowledge），完整回答了这一问题，下面是其中提到的15个知识领域（Knowledge Area, KA）： 生命周期：软件需求、软件设计、软件构建、软件测试、软件维护 专门领域：软件配置管理、软件工程管理、软件工程过程、软件工程模型和方法、软件质量 理论基础：计算基础、数学基础、工程基础 物理学家费曼谈论学习方法的时候说过：“你可以知道一种鸟的名字在全世界各种语言中怎么说，但是说完之后，你还是不了解这个鸟。所以我们要观察这个鸟的行动——这才是最重要的。”我们还要在实践中学习。人们整理了许多原则和规律。有些规律是定性的，有些规律指明了变化的趋势。 软件工程的目标——创建“足够好”的软件市面上有这么多不完美的产品，软件团队为什么还要把这些不完美的软件发布出来呢？软件工程的一个重要任务，就是要在时间、成本等多种约束条件下决定一个软件在什么时候能“足够好”，可以发布。 本书的目标是，让读者通过理论学习和具体项目的练习，做到下面三点： 研发出符合用户需求的软件 通过一定的软件流程，在预计的时间内发布“足够好”的软件 能证明所开发的软件是可以维护和继续发展的]]></content>
      <categories>
        <category>软件工程</category>
        <category>书中所得</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS ES6 注意要点]]></title>
    <url>%2F2019%2F06%2F20%2FJS-ES6-%E6%B3%A8%E6%84%8F%E8%A6%81%E7%82%B9%2F</url>
    <content type="text"><![CDATA[ES6 现状与学习要点： 开发环境已经普及 浏览器环境却支持不好（需要开发环境编译） 语法内容非常多，重点了解常用语法 面试考察：开发环境的使用 + 重点语法 ES6 模块化如何使用，开发环境如何打包？模块化的基本语法export 语法（注意有无 default）12345678910/* util1.js */export default &#123; a: 100&#125;/* util2.js */export function fn1() &#123;&#125;export function fn2() &#123;&#125; import 语法123456import util1 from &apos;./util1.js&apos;import &#123; fn1, fn2 &#125; from &apos;./util2.js&apos;console.log(util1)fn1()fn2() 开发环境配置BabelBabel is a JavaScript compiler use next generation JavaScript. Babel 可以编译 ES6 语法。 配置、安装： 电脑有 node 环境，运行 npm init npm install --save-dev babel-core babel-preset-es2015 babel-preset-latest 创建 .babelrc 文件，内容 { &quot;presets&quot;: [&quot;es2015&quot;, &quot;latest&quot;], &quot;plugins&quot;: [] } npm install --global babel-cli 验证是否生效： babel --version 创建 .index.js，内容 [1, 2, 3].map(item =&gt; item + 1); babel index.js 可以看到箭头函数被转换成了 function 语法 WebpackWebpack 可以解决 Babel 无法解决的模块引入问题（，实现模块化）。 npm install webpack babel-loader --save-dev 配置 webpack.config.js 配置 package.json 中的 scripts npm start （配置的意思是编写文件，具体内容可以搜索，也可以照着视频 2-5 写） 具体应用（验证），看视频。 rolluphttp://rollupjs.org/guide/en/ 许多流行的框架都是用 rollup 来打包的。 rollup 功能单一（把模块化做到了极致），Webpack 功能强大（也导致它的学习成本高）。 关于 JS 众多模块化标准 没有模块化（蛮荒时代）。 AMD 成为标准，require.js （也有国内的 CMD 标准），参考 前端打包工具，使得 nodejs 的模块化方法可以被前端使用。 ES6 出现，想统一所有模块化标准。 服务端 nodejs 积极支持，浏览器尚未统一。 你可以自造 lib，但是不要自造标准！ Class 和普通构造函数有何区别？JS 构造函数123456789101112131415161718// 构造函数，包含2个属性function MathHandle(x,y) &#123; this.x = x this.y = y&#125;// 原型的扩展MathHandle.prototype.add = function()&#123; return this.x + this.y&#125;// 实例化，调用方法var m = new MathHandle(1,2)console.log(m.add())typeof MathHandle // &quot;function&quot;MathHandle === MathHandle.prototype.constructor //truem.__proto__ === MathHandle.prototype //true Class 基本语法1234567891011121314151617class MathHandle &#123; constructor(x, y) &#123; this.x = x this.y = y &#125; add() &#123; return this.x + this.y &#125;&#125;const m = new MathHandle(1, 2)console.log(m.add())typeof MathHandle // &quot;function&quot;MathHandle === MathHandle.prototype.constructor //truem.__proto__ === MathHandle.prototype //true 它本质与 JS 构造函数一样，是 ES6 新增的语法糖。 继承ES6 之前的 JS 继承： 1234567891011121314151617function Animal() &#123; this.eat = function() &#123; console.log(&apos;Animal eat&apos;) &#125;&#125;function Dog() &#123; this.bark = function() &#123; console.log(&apos;Dog bark&apos;) &#125;&#125;// 实现继承Dog.prototype = new Animal()// 实例化var hashiqi = new Dog() ES6 使用 class 实现继承： 1234567891011121314151617181920class Animal &#123; constructor(name) &#123; this.name = name &#125; eat() &#123; console.log(`$&#123;this.name&#125; eat`) &#125;&#125;class Dog extends Animal &#123; constructor(name) &#123; super(name) //只要有 extends 就要有 super this.name = name &#125; bark() &#123; console.log(&apos;this.name + &apos;bark&apos;) &#125;&#125;const dog = new Dog(&apos;哈士奇&apos;) Promise 的基本使用和原理在 ES6 这一章，只介绍 Promise 最基本的东西。 Promise 出现目的：解决 Callback Hell Callback 写法：12345678910function loadImg(src, callback, fail) &#123; var img = document.createElement(&apos;img&apos;) img.onload = function() &#123; callback(img) &#125; img.onerror = function() &#123; fail() &#125; img.src = src&#125; Promise 语法12345678910111213141516171819202122232425262728function loadImg(src) &#123; const promise = new Promise(function(resolve, reject) &#123; var img = document.createElement(&apos;img&apos;) img.onload = function() &#123; resolve(img) &#125; img.onerror = function() &#123; reject() &#125; img.src = src &#125;) // 返回Promise的实例 return promise&#125;var src = &apos;http://www.imooc.com/static/img/index/logo_new.png&apos;var result = loadImg(src)result.then(function(img) &#123; console.log(img.width)&#125;, function() &#123; console.log(&apos;failed&apos;)&#125;)// 可以进行无限扩展（便于分批处理）result.then(function(img) &#123; console.log(img.height)&#125;) 要点： new Promise 实例，而且要 return。 new Promise 时要传入函数，函数有 resolve, reject 两个参数，成功时执行 resolve() 失败时执行 reject()。 用 .then 监听结果。 总结 ES6 其他常用功能let, const修改用 const 定义的常量，会报错。 多行字符串，模板变量使用反引号（键盘上数字键1左边的键），可以写多长字符串，并嵌入模板变量（Class 继承的示例代码中用到了）。 解构赋值12345678const obj = &#123; a: 10, b: 20, c: 30 &#125;const &#123; a, c &#125; = obj// 相当于// var a = obj.a// var c = obj.cconst arr = [&apos;xxx&apos;, &apos;yyy&apos;, &apos;zzz&apos;]const [x, y] = arr 其实还有许多注意点。更详细的参考 块级作用域ES5 中是没有块级作用域的，块级作用域中 var 定义的变量会外泄。 而 ES6 用 const 或 let 定义的变量有块级作用域，外部无法访问。 函数默认参数12345678function(a, b=0) &#123;&#125;// 相当于function(a, b) &#123; if(b == null) b = 0&#125; 箭头函数12345678910const arr = [1, 2, 3]arr.map(item =&gt; item + 1);// 2 个或 2 个以上的参数，要加小括号// 函数体语句大于 1 条，要加大括号，要自己写 returnarr.map((item, index) =&gt; &#123; console.log(index) return item + 1&#125;) 注意： 箭头函数只能用赋值式写法，不能用声明式写法。 箭头函数不会创建自己的 this,它只会从自己的作用域链的上一层继承 this。]]></content>
      <categories>
        <category>编程艺术</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《海边的卡夫卡》微信读书笔记]]></title>
    <url>%2F2019%2F06%2F20%2F%E3%80%8A%E6%B5%B7%E8%BE%B9%E7%9A%84%E5%8D%A1%E5%A4%AB%E5%8D%A1%E3%80%8B%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[海边的卡夫卡 村上春树著 林少华译 读完用时15小时7分钟。以下是我阅读过程中的笔记以及点评。 笔记译序:另一种精神救赎之旅《海边的卡夫卡》的力量——使心灵或灵魂获得救赎的力量。 村上这个人没有堂堂的仪表，没有挺拔的身材，没有洒脱的举止，没有风趣的谈吐，衣着也十分随便，即使走在中国的乡间小镇上也不会引起任何人的注意。但就是这样一个人在这个文学趋向衰微的时代守护着文学故土并创造了一代文学神话，在声像信息铺天盖地的多媒体社会执着地张扬着语言文字的魅力，在人们为物质生活的光环所陶醉所迷惑的时候独自发掘心灵世界的宝藏，在大家步履匆匆急于向前赶路的时候不声不响地拾起路旁遗弃的记忆，不时把我们的情思拉回某个夕阳满树的黄昏，某场灯光斜映的细雨，某片晨雾迷蒙的草地和树林……这样的人多了怕也麻烦，而若没有，无疑是一个群体的悲哀。 他回答说：“我已经写了二十多年了。写的时候我始终有一个想使自己变得自由的念头。在社会上我们都不是自由的，背负种种样样的责任和义务，受到这个必须那个不许等各种限制。但同时又想方设法争取自由。即使身体自由不了，也想让灵魂获得自由——这是贯穿我整个写作过程的念头 村上应道：“是的。我是认为人生基本是孤独的。人们总是进入自己一个人的世界，进得很深很深。而在进得最深的地方就会产生‘连带感’。就是说，在人人都是孤独的这一层面产生人人相连的‘连带感’。只要明确认识到自己是孤独的，那么就能与别人分享这一认识。也就是说，只要我把它作为故事完整地写出来，就能在自己和读者之间产生‘连带感’。其实这也就是所谓创作欲。 正文部分1 展开那圆鼓鼓隆起的部位随着呼吸如波纹缓缓起伏，令人联想到静静的雨幕下无边无际的大海。我是孑然独立在甲板上的航海者，她是大海。 周遭的现实世界如电影场景淡出一样渐渐消失，我孤身一人深入字里行间。我比什么都喜欢这一感觉。 电话另一头沉默有顷。她似乎在捕捉我语声的尾音，测量其重量。 我的整条阳物像感受某种思想似的感受着她柔软的手心。 这是世界上最孤独的运动。（这里写的是卡夫卡在人迹罕至的小木屋中进行“囚徒”健身） 同她交谈的人很多时候都会在某一点上倏然怀有朦胧的不安，怀疑自己无谓地消耗她宁静的时光、将一双泥脚踏入她井然有序的小天地，而这种感觉大多是正确的。（想法：常有这种感觉。） 硬邦邦的声调，令人联想到忘在餐橱尽头的面包。（想法：这是一个令人感到不舒服的、呆板的“外来者”——村上通过描写她的声调传达出的感觉。） “那样一来，我……”声音缺少必要的重量。我出口的话语尚未找到去向，便被虚无的空间吞没了。 不是人选择命运，而是命运选择人。这是希腊悲剧根本的世界观。（想法：本书的主要情节，都在讲述和证明这句话。） 正文部分2你想和她痛痛快快抱在一起，一次又一次交合。你想用手指上上下下摸遍她的全身，也希望被她上上下下把全身摸遍，纵然死了也想作为一个故事一个图像印在她的心间，想在回忆中夜夜得到她的爱。 “跑去谁也够不到的地方，没有时光流动的地方。” 佐伯浅浅地一笑，笑意在她嘴角停留片刻，令人联想起夏日清晨洒在小坑坑里尚未蒸发的水。 佐伯注视了一会儿我的脸。她已经没了笑意。“假定一只鸟落在细树枝上，”佐伯说，“树枝被风吹得剧烈摇摆。那一来，鸟的视野也将跟着剧烈摇摆，是吧？”我点头。“那种时候鸟是怎样稳定视觉信息的呢？”我摇头：“不知道。”“让脑袋随着树枝的摇摆上上下下，一下一下的。下次风大的日子你好好观察一下鸟，我时常从这窗口往外看。你不认为这样的人生很累——随着自己所落的树枝一次次摇头晃脑的人生？”“我想是的。”“可是鸟对此已经习惯了，对它们来说那是非常自然的，它们没法意识到，所以不像我们想像的那么累。但我是人，有时候就觉得累。”“您落在哪里的树枝上呢？”“看怎么想。”她说，“不时有大风吹来。”她把杯子放回托盘，拧开自来水笔帽。该告辞了。我从椅子上立起。 她吸一口气，停顿不语。表情从她脸上缓缓远离，又重新返回，就好像游行队伍沿同一条路走过去又折回来。 她的梦转眼之间将你的意识包拢起来，如羊水一样软乎乎暖融融地包拢起来。 她像描绘图形一样扭动腰肢。直线型泻下的长发在你肩头宛如柳枝轻轻摇曳。你一点点被吞入柔软的泥沼。世界上的一切无不暖融融湿漉漉迷濛濛，惟独你的阳物坚挺而鲜明。你闭目做你自身的梦。时间的流移变得扑朔迷离。潮满，月升。你很快射出。你当然无法遏止。在她体内一次接一次猛射。她在收缩，温柔地收集你的精液。 她像从海底浮上来的人那样长长吸一口气，寻找语句，但找不到。 心想必须说点什么，但不知道说什么好，话语已在时光的凹坑中死去，无声地沉积在火山口湖黑暗的湖底。 任何城市的街道都有这种远离恩宠的建筑物。（文中有很多这种生动的拟人，对象有“建筑物”、“沉寂”等等。） 卢梭有个定义——文明诞生于人类开始建造樊篱之时。堪称独具慧眼之见。的确，大凡文明都是囿于樊篱的不自由的产物。 “在健身房做什么运动？”“机械和举重。”“此外？”我摇头。“孤独的运动。”我点头。“你肯定想变得强壮。”“不强壮生存不下去，尤其是我这种情况。”“因为你孤身一人。”“谁也不肯帮我，至少迄今为止谁也不肯帮我，只能靠自己的力量干下去。为此必须变得强壮，如同失群的乌鸦。所以我给自己取名卡夫卡。卡夫卡在捷克语里是乌鸦的意思。”“噢——”她语气里不无佩服的意味，“那么，你是乌鸦了？”“是的。”是的，叫乌鸦的少年说。“不过那样的生存方式恐怕也还是有其局限的。不可能以强壮为墙壁将自己围起来。强壮终究将被更强壮的击败，在原理上。”“因为强壮本身成为了道德。”佐伯微微一笑：“你理解力非常好。”我说：“我追求的、我所追求的强壮不是一争胜负的强壮。我不希求用于反击外力的墙壁。我希求的是接受外力、忍耐外力的强壮，是能够静静地忍受不公平不走运不理解误解和悲伤等种种情况的强壮。”“那恐怕是最难得到的一类强壮。”“知道。”她的微笑进一步加深：“你肯定什么都知道。”我摇头：“那不是的。” “您想做的，大约是填埋已然失去的时光。” 那天夜里，你们再次抱在一起。你倾听她体内空白被填埋的声音。声音微乎其微，如海岸细沙在月光下滑坡。 月升，潮满。海水涌入河床。 短运动裤前面高高支起。看上去它好像是和我有不同的意识、依据别的系统运作的生灵。 我把耳朵贴在她如画纸一般扁平的腹部，细听位于其下的迷宫中的梦的回声。 我下床脱去内裤，用厨房的水冲洗上面粘的精液，它犹如黑暗产下的私生子，白白的重重的，黏黏糊糊的。 她在我怀中，我在她体内。 正文部分3 赎罪说到这里，她停顿下来，拿起自来水笔，合上眼睛。“对我来说，人生在二十岁时就已经终止了。后面的人生不过是绵延不断的后日谈而已，好比哪里也通不出去的弯弯曲曲若明若暗的长廊。然而我必须延续那样的人生。无非日复一日接受空虚的每一天又把它原封不动地送出去。在那样的日子里，我做过许多错事。有时候我把自己封闭在内心，就像活在深深的井底。我诅咒外面的一切，憎恶一切。有时也去外面苟且偷欢。我不加区别地接受一切，麻木不仁地穿行于世界。也曾和不少男人睡过，有时甚至结了婚。可是，一切都毫无意义，一切都稍纵即逝，什么也没留下，留下的惟有我所贬损的事物的几处伤痕。” “回忆会从内侧温暖你的身体，同时又从内侧剧烈切割你的身体。” “无论怀抱着它 生活有多么痛苦，我也——只要我活着——不想放弃那个记忆。那是我活下来的惟一意义和证明。” 此人即使在死时也不失端庄。 我行进在意识的岸边，那里有意识的拍岸白浪，有意识的离岸碎涛。它们涌来，留下文字，又马上卷回，把文字抹消。 为什么深爱一个人必然导致深深伤害一个人呢？就是说，果真如此，深爱一个人意义何在呢？ 烟笔直地爬上天空，无声无息地融入低垂的灰云。 世上有形的东西又减少一点儿，无又增多一点儿。（想法：又是隐喻吗……？“无”这个概念怎么说？暗物质是不是“无”？） 正文部分4 成长是因为我很中意你观察世界的态度。正因如此，我这星野君才一直跟你跟到这里。（想法：想起了李小龙的终生追随者木村武之。这种人，一生能有一个足矣） 同死者同处一室，星野发觉其他声音一点点消失，周围的现实声响逐渐失去了其现实性。有意义的声音很快归于沉默，沉默如海底淤泥一般越积越深——及脚、及腰、及胸。 看见我，少女淡淡地暖暖地一笑，笑得让我感觉周围世界在剧烈摇颤，仿佛被悄然置换成另一世界。有形的东西一度分崩离析，又重新恢复原形。 她胸部微微隆起，脖颈如刚出窑的瓷器一样荧白。 她凝眸看我的脸，并不回答。我的问话就像弄错了线路似的，被吞入哪里一方无名的空间，就此消失不见。 我夹在空白与空白之间，分不出何为正确何为不正确，甚至自己希求什么都浑浑噩噩。我独自站在呼啸而来的沙尘暴中，自己伸出的指尖都已看不见。我哪里也去不成，碎骨般的白沙将我重重包围。 雪白的沙子从少女纤细的指间滑落。海浪轻轻四溅的声音传来了。腾起，下落，溅开。腾起，下落，溅开。我的意识被昏暗的走廊般的场所吸了进去。 点评★★★★☆ 读这本小说，不要过分关注逻辑，而应该把注意力放在“观赏”上面。比起讲好一个故事，村上更像是在炫技，是在展示不俗的想象、高雅的情趣，是在传达人生感悟、哲学思考。 整本书用魔幻现实的情节，双线叙事手法，讲述了主角田村卡夫卡的俄狄浦斯式的悲剧，以及其他人物的一些故事。 不是人选择命运，而是命运选择人。这是希腊悲剧根本的世界观。 悲剧避无可避。然而结局却是，主角成长了，他得到了爱和勇气，重返现实世界。 村上传达了这样一种想法：世界凶顽异常，但一个人还是可以凭借爱与勇气脱困。 最初读这本书是在高中时期，当时痴迷卡夫卡的小说，在图书馆偶然看见一本《海边的卡夫卡》，就借来看了。当时读这本书只花了很少几天，体育课看、晚自习看、睡觉的时候熬夜看……感觉良好，手不释卷。想来大约有这么几点原因： 书中人物有一种独特的气质，很有吸引力。人物大多孤独，理性。主角敏感的内心描写得很细腻，且和我本人相似度高，代入感强。 书中的性爱描写，对未成年人很有吸引力。这次重读，划线的好多处都是性爱描写，大师级，档次和官能小说不是一个级别。 林少华的翻译，加上村上的比喻和句式，使得书中很多段文字的描写十分生动或唯美，文采斐然。 后来我大一时又读了村上的《世界尽头与冷酷仙境》，发现和本书风格十分接近。但还是喜欢海卡多一些，仅次于《挪威的森林》。]]></content>
      <categories>
        <category>书中所得</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>小说</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Zotero文献管理软件的基本使用]]></title>
    <url>%2F2019%2F06%2F19%2FZotero%E6%96%87%E7%8C%AE%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[介绍与安装我曾经在微信公号中比较过几款主流的文献管理工具。其中 Zotero 作为开源软件，功能扩展性极强。 我一开始了解到 Zotero 是因为看了阳志平的入门六篇，里面不但介绍了Zotero 的使用，还介绍了很多配套工具。 如何安装无须多讲，直接上官网传送门。 此外，使用之前还须要注册一个账号，用来在不同设备之间同步你的文献库（另外还可以创建 group 进行团队协作，可以关注其他用户）。 在浏览器中使用 Zotero选择 Zotero 菜单栏中的工具 &gt; 安装浏览器插件，会打开浏览器（Firefox, Chrome 等）并进入插件浏览器下载页面。 打开本地的 Zotero 软件，再配合 Zotero 的浏览器插件，你可以直接从你打开的网页上爬取文献资料的信息（标题、作者、摘要等）。 阳志平入门六篇的第一篇就介绍了6种向 Zotero 导入文献的方法。不过我最常用的还是下图这种： 注： 先打开浏览器再打开 Zotero 的情况下，导入文献会出错，须要重启浏览器。 Zotero 无法识别万方数据库的文献元数据（可能因为网页改版了），国内的文献还是去 CNKI 搜索吧，而且在 CNKI 还能支持批量导入。 有时明明在浏览器导入了A文献，再去导入B文献，却发现 Zotero 导入的还是A文献。解决办法是重启浏览器，或者换个浏览器。 顺带一提，Chrome 浏览器拥有丰富的插件，其中我经常使用的有： TamperMonkey，允许用户自己编写、共享插件脚本，不少 geek 写了许多很实用的脚本，比如解析网上的 VIP 视频、免费下载百度文库等； 谷歌访问助手，允许浏览器直接访问 Google 主页以及 Google scholar 等网站； （由于 QQ 浏览器使用 Chrome 内核，我个人体验是：以上插件在 QQ 浏览器基本上也可以使用。我用 QQ 主要是因为一直在用 QQ 账号同步网页收藏夹。） 在 Word 中使用 Zotero在 Word 中使用 Zotero 可以方便地插入参考文献的引用。（我在 Win7 下的盗版 Word 2013 用了文献管理插件插入文献，然后 Word 变得很卡，原因不明。） 只要你想引用的文献已经添加到 Zotero 文库中，就可以直接插入 Word 文档的任意位置，并在指定位置、按指定样式，自动生成该参考文献的信息。即使引文插入的位置有先后变化，只要刷新一下就会自动调整。 是不是很激动人心？如果你的 Windows 系统安装了 Zotero 和 Word，只需要再按下面2个步骤操作，就可以做到上述神奇的功能。 安装 Zotero Word 插件如果你在你的 Word 中找不到 ZOTERO 插件，可以参考官方文档进行手动安装。 Windows 用户的插件安装步骤如下： 打开 Zotero 的安装文件夹（默认路径为C:\Program Files (x86)\Zotero） 在安装文件夹中，依次打开extensions\zoteroWinWordIntegration@zotero.org\install，里面有2个文件 Zotero.dotm (用于 Word 2007 及以上版本) 以及 Zotero.dot (用于旧版本的 Word) 找到 Word 的 startup 文件夹（对于 XP 以后的操作系统，路径为 C:\Users\你的系统用户名\AppData\Roaming\Microsoft\Word\STARTUP，如果没有 STARTUP 文件夹的话自己创建一个） 复制一份 Zotero.dotm 或 Zotero.dot 文件（取决于你的 Word 版本）到 Word 的 Startup 文件夹 打开或重启 Word，你会发现工具面板多了一块内容，如图： 如果你的 Word 中使用了 Zotero 之后变得特别卡，可以尝试关闭 Word 的自动校对（自动更正与拼写检查），亲测有用。 添加中文文献引用样式Zotero 默认的引文格式中找不到中文标准 GB 样式，如何添加呢？ 在 Word 插件的 Document Preference 中，有“添加引文样式…”字样，点它就相当于打开了 Zotero 软件的首选项设置，如下图： 点“获取其他样式…”，然后搜索Chinese Std GB/T 7714-2005 (numeric, Chinese)，将它添加到样式管理器中，就可以选用中文标准的引文格式了。 标注文献重要性Zotero 中，可以给一条文献条目创建文件链接（比如 pdf 全文）、关联文献、笔记、标签等。 看完一篇文献后，觉得它比较重要，怎么才能给这篇文献的条目添加标记呢？利用标签。 比如，给一篇文献创造一个名为“重要文献”的标签。接着在界面的左下角，找到该标签，然后右键，对该标签指派颜色。如下图。 给标签指派颜色的同时，也会设置快捷键（从1到9）。以后，给其他文献条目添加相同的标签时，只需要按快捷键就行了。]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
        <tag>科研</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习】许世伟的架构课（极客时间）]]></title>
    <url>%2F2019%2F06%2F17%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%B8%E4%B8%96%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89%2F</url>
    <content type="text"><![CDATA[开篇词 | 怎样成长为优秀的软件架构师？许世伟2000年开始工作，曾是WPS首席架构师，在盛大做过，2011年创立了七牛云，现在是一名创业者、CEO。 把程序员类比成建筑师，按能力来分有三个层次：搬砖师、工程师、架构师。 软件诞生后，需要花费大量代价维护。程序员更多的时间是用来维护代码。 代码质量的评判有这样一些基本维度：可阅读性、可扩展性/可维护性、可测试性、可复用性。 阅读和维护软件工程师写的代码会有一种赏心悦目的感觉。 软件工程是一项非常复杂的系统工程，它需要依赖一个能掌控全局的团队，来规划和引导整个系统的演变过程。这个团队就是架构师团队。 掌控全局的前提是：在自己心中去重新构筑出整个世界。 课程脉络：首先，我们通过还原信息世界的构建过程，剥离出了整个信息世界的核心骨架，这也是最真实、最宏大的架构实践案例。其次，我们结合这个宏大的架构实践来谈架构思维，避免因对架构思维的阐述过于理论化而让人难以理解。 01架构设计的宏观视角课程内容从基础架构讲起，慢慢过渡到业务架构。 应用程序的基础架构电脑的构成：中央处理器+存储+一系列的输入输出设备 如此简单，电脑却能完成复杂和多样化的功能。主要依赖两点： 可编程性。虽然CPU指令是一个有限的指令集，但是CPI执行的指令序列并不固定，而是依赖存储中的数据（程序）来决定。 开放设计的外部设备支持。CPU并不理解外部设备具有什么样的能力，只和它们交换数据。 CPU是一个非常简洁的模型，它只读写数据，对数据进行计算。 机器指令编写软件太累——编程语言+编译器出现 多个软件写数据、传指令冲突怎么办——操作系统出现，解决软件治理和基础编程接口问题 完整的程序架构是怎么样的？业务架构（应用架构），只须关心应用程序的本身的业务问题如何构建。 不同的业务架构之间，不止遵循相同的架构原则，还可以遵循相同的的设计范式。例如，在用户交互领域有著名的 MVC 框架（如 JavaScript 语言的 Angular，PHP 语言的 Zend，Python 语言的 Django），在游戏开发领域有各种游戏引擎（如 JavaScript 语言的 Phaser，C# 语言的 Unity3D），等等。 对于一个服务端应用程序来说，其完整的架构体系大体如下图： 客户端应用程序和服务端有很大差别，首先面临多样性的挑战（操作系统、设备种类）。 浏览器是第一个想要消除客户端的多样性，跨平台提供统一接口的，地位非常特殊，可以看做是操作系统之上的操作系统。对于一个客户端应用程序来说，其完整的架构体系大体如下： 02解剖冯·诺依曼体系结构解剖架构的关键点当我们设计或分析架构设计中涉及的每一个零部件时，我们关心哪些问题？ 需求。这个零部件的作用是什么？它被用来做哪些事？不会被用来做哪些事？为什么不会？ 规格。这个零部件的接口是什么样的？它如何与其他零件连接在一起？ 解决一切可“计算”问题，这是冯·诺依曼的需求。 冯·诺依曼体系的规格为了实现需求，冯·诺依曼引入了三类基础零部件： 中央处理器，负责程序（指令序列）的执行； 存储（中央处理器内置支持的存储）； 输入输出设备。 为什么这么简洁的规格设计，可以解决这么复杂的需求？ 需求是怎么被满足的？一方面，需求的变化点在于，要解决的问题是五花八门包罗万象的。如何以某种稳定但可扩展的架构来支持这样的变化？而另一方面，需求的稳定之处在于，电脑的核心能力是固定的。 电脑的核心能力是“计算”。就是对一个数据（输入）进行变换，变为另一个数据（输出）。在数学中我们把它叫做“函数”。 y = F(x) 这里x、y是数据。无论它们的逻辑含义为何，物理上都可以用一段连续的字节内容来表达。那么x、y物理上在哪里？得有一个“存储”用来存放操作的数据。 而函数 F，对于架构师来说也是未知的。怎样设计一种架构让用户可以表达任意复杂度的函数（计算）？逻辑上，无论多复杂的自定义函数，都可以用一组指令序列来表达。这些指令包括： 执行最小计算单元，如数字的加减乘除（也就是内置函数）； 执行顺序，包括条件分支、循环； 执行其他自定义的函数（子函数）。 F 物理上在哪里？以指令序列（程序）形式存放在存储里。存储不仅存放数据，也存放“计算”本身。 有了负责计算的中央处理器，以及存储，就可以进行任意复杂的“计算”了。但是它无法和现实世界发生交互，即输入和输出。 对于电脑来说，输入输出的需求就更多了。但不管是什么样交互用途的设备，我们要做的只是定义好统一的数据交换协议。 除了纯正的“计算”能力外，中央处理器还要有“数据交换”能力（或者叫 IO 能力）。 最终，电脑可以被看做由 “中央处理器 + 存储 + 一系列的输入输出设备” 构成。 （以上内容仅仅是说明，具体细节参考学科：计算机组成原理、汇编语言等） 架构思维总结架构的第一步是需求分析。需求分析的关键是抓住需求的稳定点和变化点。架构目标是剥离变化的部分，将其抽象到接口层去实现（做成开放性设计），让系统的核心价值（功能）保持稳定。 对于“电脑”这个产品而言，需求的稳定点是电脑的“计算”能力。需求的变化点，一是用户“计算”需求的多样性，二是用户交互方式的多样性。 电脑的“计算”能力，最终体现为中央处理器的指令集，这是需求相对稳定的部分。 用户“计算”需求的多样性，最终是通过在存储中的指令序列实现。计算机加电启动后，中央处理器并不是按自己固有的“计算”过程进行，而是从一个固定的存储地址加载指令序列执行。 扩展阅读： 电脑结构和CPU、内存、硬盘三者之间的关系 计算机发展史 03汇编语言的诞生对于现代计算机来说，虽然 CPU 指令是一个很有限的指令集，但是 CPU 执行的指令序列（或者叫“程序”）并不是固定的，它依赖于保存在存储中的数据，由软件工程师（或者叫“程序员”）编写的软件决定。 在第一门面向程序员的编程语言出现前，人们只能通过理解 CPU 指令的二进制表示，将程序以二进制数据方式刻录到存储（比如 ROM 或硬盘）上。 这个时候软件和硬件的边界还非常模糊，并不存在所谓软件工程师（或者叫“程序员”）这样的职业。写程序也并不是一个纯软件的行为，把程序刻录到存储上往往还涉及了硬件的电气操作。 为了解决编程效率的问题，汇编语言（和解释它的编译器）诞生了。汇编语言的编译器将汇编语言写的程序编译成为 CPU 指令序列，并将其保存到外置的存储设备（比如硬盘）上。 汇编语言的出现，让写程序（编程）成为一个纯软件行为（出现“程序员”这个分工的标志），人们可以专注于程序逻辑的表达、反复修改程序，然后通过汇编编译器将其翻译成机器语言，并写入到外置的存储设备（比如硬盘）。 这一步所解放的生产力是惊人的。程序的源代码可以进行迭代演进了。软件程序不断被传承，并最终演进出今天的信息世界。 04编程语言的进化软件是活的书籍，是人类知识传承能力的一次伟大进化。它比书籍更好： 表达方式多样 对技术的现场还原 编程范式的进化 过程式。最核心的概念是结构体（自定义的类型）和过程（也叫函数）。 函数式。本质上是过程式编程的一种约束，核心主张是变量不可变、函数尽可能没有副作用。学习成本高，代表语言有 Haskell, Erlang。 面向对象。在过程式的基础上，主张尽可能把方法（即过程）归纳到合适的对象中。 面向对象的核心思想是引入契约，基于对象这个概念对代码的使用界面进行抽象和封装。有两个显著优点： 清晰的使用界面。数据结构和过程的关系不再松散。 信息的封装。提高了可复用性，通过接口优雅地实现多态的能力。 对于继承，褒贬不一。本来复合对象的唯一构造方法是组合，现在多了一个选择，令人纠结。 Go 语言给出了答案：放弃继承，全面强化组合能力。 一些语言明确主张自己是多范式的，比如 C++。 Go 保留了每一种编程范式的精华部分，但是 Go 官方认为 Go 是一门面向连接的语言。体现了朴素的组合思想。 Go 语言设计的方方面面都需要契约，直接消灭了那些代码写法容易产生区别的地方，让大家专注于意图的表达。 其他方面的进化除了编程范式，编程语言的工程能力也越来越完善，体现在： 包（package），即代码的发布单元。 版本（version），即包的依赖管理。 文档生成（doc）。 单元测试（test）。 从语言的执行器行为看，出现了这样三种分类的语言： 编译的目标文件为可执行程序。典型代表有 Fortran, C/C++, Go 等。 生成跨平台的虚拟机字节码，有独立的执行器（虚拟机）执行字节码。典型代表 Java, Erlang。 直接解释执行。典型代表是 JavaScript。当然现在纯解释执行的语言已经不多了，大多数直接执行的语言内部还是会有虚拟机的。 语言对架构的影响之前的架构图中，三种不同的颜色表示不同层次的依赖。 无论是服务端还是客户端，可以同意将其架构图简化为： 业务架构——源代码层次的依赖，程序本身的组成部分 应用程序框架及各类基础库——库层次的依赖，程序本身的组成部分，但与业务无关 基础软件（操作系统、编程语言及各种中间件）——软件层次的依赖，程序工作的生态环境 冯·诺依曼体系架构——硬件层次的依赖，程序工作的物理基础 从软件的业务架构来说，怎么拆分模块（确定业务边界）是业务需求本身决定的，与编程语言无关。但是在描述每个模块的规格时，采用的规格描述语言会面临如下两种选择： 选择某种语言无关的接口表示； 选择团队开发时采用的编程语言来描述接口。 两者无本质差异，但语言的选择在实践中对业务架构的决策的影响仍然及其关键。原因： 开发效率有差异。抛开语言本身的开发效率不谈，不同语言会有不同的社区资源，还有企业发展形成的框架和基础库； 后期维护。语言有生命周期，会走向衰弱。 06操作系统进场操作系统就是软件之间的协调方，制定规则并约束这些软件的行为。 操作系统的执行权，是计算机主板 ROM 上的启动程序（BIOS）交给它的。 操作系统的需求演进编程语言出现后，软件生产效率得到了大幅度提升。软件越来越多，多个软件如何和谐共处？这就诞生了软件治理的需求： 多个软件如何同时运行（多任务的需求）？ 多个软件如何共同使用计算机上的存储空间（内存管理、文件系统的需求）？ 多个软件如何共同使用同一个外部设备（设备管理的需求）？ 多个软件如何相互通讯，如何进行数据交换（进程间通讯、共享内存的需求）？ 病毒、恶意软件如何治理（安全管理的需求）？ 客户价值维度 首先要解决的是软件治理问题。大体分为以下6个子系统：进程管理、存储管理、输入设备管理、输出设备管理、网络管理、安全管理。 其次解决的是基础编程接口问题。这些编程接口一方面简化了软件开发，另一方面提供了多软件共同运行的环境，实现了软件治理。 商业价值维度 操作系统是基础的刚需软件，计算机离不开操作系统。 操作系统也是核心的流量入口。占领了操作系统，就占有了用户。 无论是本地操作系统 iOS 和 Android，还是 Web 操作系统（浏览器）如微信小程序，都实现了“帐号 - 支付 - 应用市场”这样的商业闭环。这类操作系统，我们不妨把它叫做现代操作系统。 操作系统的边界架构的第一步是需求分析。在架构设计过程中，需求分析至少应该花费三分之一的精力。 当我们说要做一个操作系统的时候，我们的自己对这句话的理解也是非常模糊的。尤其当我们正准备做的事情是一个新生事物的时候。 架构也关乎用户需求，我们不止要知道用户当前的需求，还要预测需求未来可能的变化，预判什么会发生、而什么不一定会发生。 我是否能预料到，有一天支付（Pay）系统会成为操作系统的核心子系统？如果不能，那怎么才能做到？ 操作系统的边界到底在哪里？ 看清楚这样三个角色的关系： 硬件（个人计算机、手机或其他） 操作系统 浏览器 小结从客户需求来说，操作系统的核心价值在于： 实现软件治理，让多个软件和谐共处； 提供基础的编程接口，降低软件开发难度。 从商业价值来说，操作系统是刚性需求，核心的流量入口，兵家必争之地。 我们把引入了“账号 - 支付 - 应用市场”商业闭环的税收模式的操作系统，称为现代操作系统。 通过对硬件、操作系统、浏览器三者的关系分析，有助于对需求发展做出预判。 07软件运行机制及内存管理软件治理的一个重要部分，就是让多个软件可以共同使用计算机的资源，不至于出现争抢的场面。 CPU 可以直接访问的存储资源非常少，只有：寄存器、内存（RAM）、主板上的 ROM。 寄存器访问速度非常非常快，但是数量很少，大部分程序员不直接打交道。 ROM 是非易失的、只读的，所以它非常适合存储计算机的启动程序（BIOS）。 所以，内存的地位非常特殊，它是唯一的 CPU 内置支持，且会和程序员直接打交道的基础资源。 计算机的运行全过程从时序来说，计算机从开机到关机的完整“计算”过程如下： 首先，BIOS 程序没有固化在 CPU 中，而是独立放到主板的 ROM 上，是因为不同历史时期的计算机输入输出设备很不一样（有键盘 + 鼠标 + 显示器的，有触摸屏的，也有纯语音交互的；外置存储则有软盘、硬盘、闪存），这些变化我们通过调整 BIOS 程序就可以应对，而不需要修改 CPU。 引导区引导程序，是程序从内置存储（ROM）转到外置存储的边界。它很短，BIOS 只需要把它加载到内存执行就可以。这样系统的控制权就转到外置存储了。引导区引导程序不固化在 BIOS 中，而是写在外置存储的引导区。毕竟 BIOS 还是硬件，而引导区引导程序已经属于软件范畴了，修改起来会方便很多。 OS 引导程序，是外置存储接手计算机控制权的真正开始。操作系统从这里开始干活了。最终所有的初始化工作完成后，操作系统会把执行权交给 OS Shell 程序。 OS Shell 程序负责操作系统与用户的交互。最早的时候，OS Shell 程序是一个命令行程序，DOS 中叫 command.com，而在 Linux 下则叫 sh 或者 bash 之类。这个时期启动一个软件的方式就是在 Shell 程序中输入一个命令行。到了图形界面时期，在 Shell 中启动软件就变成点点鼠标，或者动动手指。 关键细节：计算机是如何运行外置存储上的软件的？ 通过内存管理。涉及两个问题： 如何分配内存； 如何运行外置存储上的软件。 CPU 对内存的操作方式有两个不同模式： 在实模式下，CPU 直接通过物理地址访问内存。 在保护模式下，CPU 通过一个地址映射表把虚拟的内存地址转为物理的内存地址，然后再去读取数据。 实模式下的内存管理在实模式操作系统下，所有软件包括操作系统本身，都在同一个物理地址空间下。在 CPU 看来，它们是同一个程序。 操作系统如何分配内存？至少有两种可行的方法： 把操作系统内存管理相关的函数地址，放到一个大家公认的地方（比如 0x10000 处），每个软件要想申请内存就到这个地方取得内存管理函数并调用它。 把内存管理功能设计为一个中断请求。 所谓中断，是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断。内存的全局有一个中断向量表，本质上就是在一个大家公认的地方放了一堆函数地址。比如键盘按了一个键，它会触发 9 号中断。在 CPU 收到中断请求时，它会先停下手头的活来响应中断请求（到中断向量表找到第 9 项对应的函数地址并去执行它），完成后再回去干原来的活。中断机制设计之初本来为响应硬件事件之用，但是 CPU 也提供了指令允许软件触发一个中断，我们把它叫软中断。比如我们约定 77 号中断为内存管理中断，操作系统在初始化时把自己的内存管理函数写到中断向量表的第 77 项。 上面两种方法实质上是同一个方法，只是机制细节有所不同而已。中断机制远不止是函数向量表那么简单。比如中断会有优先级，高优先级中断可以打断低优先级中断，反之则不能。 在实模式下，操作系统如何运行外置存储（比如硬盘）上的软件？ 把软件完整从外置存储读入到内存然后执行它。不过在执行前，先把浮动地址固定下来。为什么会有浮动地址？因为软件还没有加载到内存的时候并不知道自己会在哪里，所以有很多涉及数据的地址、函数的地址都没法固定下来，要在操作系统把它加载到内存时来确定。 整体来说，实模式内存管理的机制是非常容易理解的。因为它毕竟实质上是一个程序被拆分为很多个软件（程序代码片段），实现了程序代码片段的动态加载而已。 实模式的问题： 安全性。操作系统及所有软件都运行在一起，相互之间可以随意修改对方的数据甚至程序指令。 支持的软件复杂性低，同可运行的软件数量少。 保护模式下的内存管理保护模式下，内存访问不再是直接通过物理内存，而是基于虚拟内存。虚拟内存模式下，整个内存空间被分成很多个连续的内存页。每个内存页大小是固定的，比如 64K。 这样，每次 CPU 访问某个虚拟内存地址中的数据，它都会先计算出这是要访问哪个内存页，然后 CPU 再通过一个地址映射表，把虚拟的内存地址转为物理的内存地址，然后到这个物理内存地址去读取数据。地址映射表是一个数组，下标是内存页页号，值是该内存页对应的物理内存首地址。 有可能某一个内存页对应的物理内存地址不存在，这种情况叫缺页，没法读取数据，这时 CPU 就会发起一个缺页的中断请求。这个缺页的中断请求会被操作系统接管。发生缺页时，操作系统会为这个内存页分配物理的内存，并恢复这个内存页的数据。如果没有空闲的物理内存可以分配，它就会选择一个最久没有被访问的内存页进行淘汰。当然，淘汰前会把这个内存页的数据保存起来，因为下次 CPU 访问这个被淘汰的内存页时一样会发生缺页中断请求，那时操作系统还要去恢复数据。 通过虚拟内存的机制，操作系统并不需要一上来就把整个软件装进内存中，而是通过缺页中断按需加载对应的程序代码片段。内存不够用的时候，就把最久没有用过的内存页淘汰掉，腾出物理内存。 反正内存地址空间是虚拟的，操作系统可以一上来就给要运行的软件分配超级大的内存。软件如果不用某个内存页，什么都不发生。软件一旦用了某个内存页，通过缺页中断，操作系统就分配真正的物理内存给它。 通过引入虚拟内存及其缺页机制，CPU 很好地解决了操作系统和软件的配合关系。 虚拟地址并不是全局的，而是每个进程有一个自己独立的虚拟地址空间。 在保护模式下，每个软件“感觉”自己在独占整个计算机的资源。独立的虚拟地址空间很好地伪装了这一点：看起来我独自在享用所有内存资源。在实模式下的浮动地址的问题也解决了，软件可以假设自己代码加载的绝对地址是什么，不需要在加载的时候重新调整 CPU 指令操作的地址。 内存是进程运行的基础资源，保持进程基础资源的独立性，是软件治理的最基础的要求。这也是保护模式之所以叫“保护”模式的原因。 对架构思维的启示虚拟内存本质上要解决这样两个核心需求： 软件越来越大，我们需要考虑在外置存储上执行指令，而不是完整加载到内存中。但是外置存储一方面它的数据 CPU 并不知道怎么读；另一方面就算知道怎么读，也不知道它的数据格式是什么样的，这依赖文件系统的设计。让 CPU 理解外置存储的实现细节？这并不是一个好的设计。 要同时运行的软件越来越多，计算机内存的供给与软件运行的内存需求相比，捉襟见肘。怎么才能把有限的内存的使用效率最大化？一个很容易想到的思路是把不经常使用的内存数据交换到外置存储。但是问题仍然是，CPU 并不了解外置存储的实现细节，怎么才能把内存按需交换出去？ 通过把虚拟内存地址分页，引入缺页中断，我们非常巧妙地解决了这个问题。缺页中断很像是 CPU 留给操作系统的回调函数，通过它对变化点实现了很好的开放性设计。 08操作系统内核与编程接口软件如何利用它所依赖的基础架构？ 首先是冯·诺依曼计算机体系，它由 “中央处理器 + 存储 + 一系列的输入输出设备” 构成。这一层，提供编程接口的是 CPU，编程接口是 CPU 指令。 其次是编程语言。编程语言面向人类，CPU 指令面向机器，编译器负责将编程语言的程序，翻译成机器能够理解的 CPU 指令序列。编程语言的自然演化越来越脱离 CPU 所限制的条条框框，大部分语言都演化出很多基础的算法库。 最后是操作系统。软件怎样才能使用操作系统的能力呢？大部分情况下，操作系统的能力通过软中断向软件开放，为此还专门引入了一个术语叫 “系统调用（syscall）”。 系统调用中断的设计初衷是 CPU 响应硬件设备事件的一个机制。当某个输入输出设备发生了一件需要 CPU 来处理的事情，它就会触发一个中断；但是 CPU 也提供了指令允许软件触发一个中断，我们把它叫软中断。 系统调用所基于的软中断，它很像一次间接的“函数调用”，但是又颇有不同。在实模式下，这种区别并不强烈。但是在保护模式下，这种差异会十分明显。 根据与应用的关系，我们可以把操作系统分为内核与外围。所谓操作系统内核，其实就是指那些会向应用程序提供系统服务的子系统的集合，它们管理着计算机的所有硬件资源，也管理着所有运行中的应用软件（进程）。 操作系统内核的执行权限等级，和我们常规的软件进程不同。像 Intel CPU 通常把代码执行权限分为 Ring 0-3 四个等级。 我们的应用程序运行在 Ring 3（我们通常叫用户态），而操作系统内核运行在 Ring 0（我们通常叫内核态）。所以一次中断调用，不只是“函数调用”，更重要的是改变了执行权限，从用户态跃迁到了内核态。 操作系统与我们编写的软件并不同属一个进程，两边的内存地址空间都是独立的。我们系统调用请求是过去了，但是我们传给操作系统的内存地址，对它真的有意义吗？ 答案在于，从虚拟内存机制的视角，操作系统内核和所有进程都在同一个地址空间，也就是，操作系统内核的内存是所有进程共享的。示意如下： 操作系统内核的代码和数据，不只为所有进程所共享，而且在所有进程中拥有相同的地址。这样无论哪个进程请求过来，对内核来说看起来都是一次本进程内的请求。 内存页可以设置 “可读、可写、可执行” 三个标记位。操作系统内核虽然和用户进程同属一个地址空间，但是被设置为“不可读、不可写、不可执行”。虽然这段地址空间是有内容的，但是对于用户来说是个黑洞。 操作系统的编程接口最原始的调用方式是用软中断指令。在汇编语言里通常是：1int &lt; 中断号 &gt; ; // 对每个操作系统来说中断号是固定的，比如 Linux 是 0x80 int 是 interrupt 的缩写。 大部分高级语言都实现了操作系统编程接口的封装。 前面我们说，操作系统（内核）有六大子系统：存储管理、输入设备管理、输出设备管理、进程管理、网络管理、安全管理。除了安全管理是一个“润物细无声”的能力外，其他子系统都会有所包装。 我们以 C 语言和 Go 语言为例给一个简表，方便大家索引： 动态库从操作系统的角度来说，它仅仅提供最原始的系统调用是不够的，有很多业务逻辑的封装，在用户态来做更合适。但是，它也无法去穷举所有的编程语言，然后开发各种语言的基础库。那怎么办？ 使用动态库。几乎所有主流操作系统都有自己的动态库设计，包括： Windows 的 dll（Dynamic Link Library）； Linux/Android 的 so（shared object）； Mac/iOS 的 dylib（Mach-O Dynamic Library）。 动态库本质上是实现了一个语言无关的代码复用机制。它是二进制级别的复用，而不是代码级别的。这大大降低了编程语言标准库的工作量。 动态库的原理其实很简单，核心考虑两个东西： 浮动地址。动态库本质上是在一个进程地址空间中动态加载程序片段，这个程序片段的地址显然没法在编译阶段确定，要在加载动态库的过程中固定住浮动地址。 导出函数表。动态库需要记录有哪些函数被导出（export），这样用户就可以通过函数的名字来取得对应的函数地址。 编程语言标准库的实现，多了一个选择：直接调用动态库的函数并进行适度的语义包装。大部分语言会选择这条路，而不是直接用系统调用。 操作系统与编程语言编程语言和操作系统是两个非常独立的演化方向，却又彼此交融，它们有点像是某种“孪生关系”。虽然操作系统的诞生离不开编程语言，但是操作系统和 CPU 一样，是编程语言背后所依赖的基础设施。 和这个话题相关的，有这么一些有趣的问题： 先有编程语言，还是先有操作系统； 编程语言怎么做到自举的（比如用 C 语言来实现 C 语言编译器）； 操作系统开发的环境是什么样的，能够做到操作系统自身迭代本操作系统（自举）么？ 先有编程语言，还是先有操作系统？这个问题的答案比较简单——先有编程语言。 之所以有这个疑问，是因为两点： 大部分人习惯认为运行软件是操作系统的责任。但实际上软件跑起来是很容易的，看 BIOS 程序把控制权交给哪个软件。 大部分常见的应用程序都直接或间接依赖操作系统的系统调用。这样来看，编程语言编译出来的程序是无法脱离操作系统而存在的。但是实际上常见的系统级语言（比如 C 语言）都是可以编写出不依赖任何内核的程序的。 编程语言怎么做到自举的？从鸡生蛋的角度，编译器的进化史应该是这样的：先用机器码直接写第一个汇编语言的编译器，然后汇编语言编译器编出第一个 C 语言编译器。有了 C 语言编译器后，可以反过来用 C 语言重写汇编语言编译器和 C 语言编译器，做更多的功能增强。 这个过程理论上每出现一种新 CPU 指令集、新操作系统，就需要重新来一遍。但是人是聪明的。所以交叉编译这样的东西产生了。所谓交叉编译就是在一种 “CPU + 操作系统” 架构下，生成另一种 “CPU + 操作系统” 架构下的软件。这就避免了需要把整个编译器进化史重新演绎一遍。 操作系统能够自举么？当然可以。通常一门新的操作系统开发之初，会用上面提到的交叉编译技术先干出来，然后等到新操作系统稳定到一定程度后再实现自举，也就是用本操作系统自己来做操作系统的后续迭代开发。 小结这一节我们介绍了基础架构——中央处理器（CPU）、编程语言、操作系统，这三者对应用软件开放的编程接口。总结来看就是下面这样一幅图： 其中，我们着重介绍的是操作系统的系统调用背后的实现机理。通过系统调用这个机制，我们很好地实现了操作系统和应用软件的隔离性和安全性，同时仍然保证了极好的执行性能。 09外存管理与文件系统外存的分类随着科技的发展，新的外置存储设备不断涌现，它们有着更低的单位能耗（存储量/每日能源消耗成本）、更低的单位存储成本（存储量/可存储的时间/设备价格）、更高的访问性能。 不管这些存储设备的原理怎么变，它们的功能是不变的。对操作系统来说，管理它们的方式非常一致。 按照这些外置存储设备的功能特性不同，可以分为三类： 顺序读写型。如：磁带。 随机只读型（单次完整写入，多次读取）。如：光盘（含可擦写光盘）。 随机读写型。如：软盘、硬盘、U 盘、SSD 等。 外存的数据格式如何让很多软件进程同时使用外存设备，而不会混乱呢？ 直接基于物理的存储地址进行读写，肯定行不通。你不会记得上次的数据写到哪里去了。 和内存管理不同，我们希望写到外部存储中的数据是“自描述”的某种数据格式，可以随时查看之前写了哪些内容、都是什么时候写的。这就是文件系统的来源。 文件系统文件系统把存储设备中的数据组织成为了一棵树。节点可以是目录（也叫“文件夹”），也可以是文件。每个节点，无论是目录还是文件，都有自己的名字、创建时间、最后编辑时间、最后访问时间等信息。有些文件系统还会提供最近一段时间的操作日志。 尽管几乎所有文件系统的接口是非常一致的，但文件系统的实现却有很多。 对于随机只读型的外置存储（如光盘），常见的文件系统有 ISO-9660, UDF, Joliet 等。它的数据格式偏向“读优化”，数据非常紧凑，不必支持分块。 对于随机读写型的存储（如硬盘），常见的文件系统有如下这些： 文件系统格式的设计，和架构关联性不大，更多的是数据结构与算法的问题。 文件系统的设计思路基本相似。大部分现代文件系统都基于日志（journal）来改善文件系统的防灾难能力（比如突然断电），基于 B 树或 B+ 树组织元数据。 古老的 DOS 引入的 FAT 文件系统（典型代表为 FAT32）是个例外，它直接把目录当作一个特殊的文件，里面依次列出了这个目录里的所有子节点的元信息。这个结构虽然简单，但是如果目录树深、目录里的子节点数量多，都会大幅降低文件系统的性能。 对外存的处理对于随机读写型的存储设备，操作系统往往还支持对其进行分区，尤其是在这个存储设备的容量非常大的情况下。 拿到一块存储设备，第一步往往是对其进行分区（当然也可以省略这一步，把整个设备看做一个分区）。分区本质上只是把一个存储设备模拟成多个存储设备来使用而已。 第二步是对每个分区进行格式化。所谓格式化就是给这个分区生成文件系统的初始状态。格式化最重要的是标记分区的文件系统格式（用来告诉别人这个分区是数据是怎么组织的），并且生成文件系统的根目录。 第三步是把该分区挂载（mount）到操作系统管理的文件系统名字空间中。完成挂载后，该分区的文件系统管理程序就工作起来了，我们可以对这个文件系统进行目录和文件的读取、创建、删除、修改等操作。 外存的使用接口最简单的方式是使用操作系统提供的命令行工具。 最原始的方式是上一讲介绍的“系统调用”。不过大部分的编程语言对此都有相应的封装。 有意思的是，在早期，操作系统试图将所有的输入输出设备的接口都统一以 “文件” 来抽象它。最典型的代表就是标准输入（stdin）和标准输出（stdout）这两个虚拟的文件，分别代表了键盘和显示器。在 UNIX 系里面有个 “一切皆文件” 的口号，便由此而来。但事实证明 UNIX 错了。输入输出设备太多样化了，所谓的 “一切皆文件” 不过是象牙塔式的理想。就拿键盘和显示器来说，图形界面时代到来，所谓标准输入和标准输出就被推翻了，编程接口产生颠覆性的变化。 有了文件系统的使用接口，进程就可以互不影响地去使用这些外置存储设备。除非这些进程要操作的文件或目录的路径产生冲突（所谓路径，是指从根目录到该节点的访问序列。例如路径 /a/b/c 是从根目录访问子目录 a，再访问子子目录 b，最后访问节点 c），一般情况下它们并不需要感知到其他进程的存在。 路径冲突是可以避免的，只要我们对路径取名进行一些基础的名字空间约定，但有时候也会故意利用这种路径的冲突，来实现进程间的通讯。 操作系统提供了一些冲突检查的机制。例如 “检查文件是否存在，不存在就创建它”，这个语义在保证原子性的前提下，就可以用于做进程间的互斥。例如，我们希望一个软件不要运行多个进程实例，就可以基于这个机制来实现。 虚拟内存的支持前面我们在 07 讲中提到，在物理内存不足的时候，操作系统会利用外存把一些很久没有使用的内存页的数据，保存到外存以进行淘汰。 在 UNIX 系的操作系统中，操作系统为此分配了一个磁盘分区叫 swap 分区，专门用于内存页的保存和恢复。在 Windows 操作系统中则通过一个具有隐藏属性的 .swp 文件来实现。 在缺页发生比较频繁时，内存页的数据经常性发生保存和恢复，这会发生大量的磁盘 IO 操作，非常占用 CPU 时间，这时候我们通常能够明显感觉到计算机变得很慢。 在计算机变慢，并且计算机的硬盘灯不停闪烁的时候，我们基本可以确定是物理内存严重不足，不能满足运行中的软件的内存需要。 小结整体来说，外存管理从架构角度来说比较简单，复杂性主要集中在外存数据格式，也就是文件系统的设计上。 如果你希望进一步研究某个文件系统的具体实现细节，我这里推荐一个由七牛云开源的 BPL 语言（Binary Processing Language，二进制处理语言）。顾名思义，BPL 语言主要用于分析二进制数据格式。应用场景包括：文件格式分析（含磁盘分区格式，因为一个磁盘分区可以把它理解为一个大文件）、网络协议分析。 后面介绍文本处理相关的章节，还会专门拿出 BPL 语言进行讨论。 10输入和输出设备 时期 输入设备 输出设备 早期 打孔卡 打印机 字符界面时期 键盘 显示器 图形界面时期 键盘+鼠标 显示器+音箱 移动时期 触摸屏+麦克风 触摸屏+内置扬声器 IoT 萌芽时期 麦克风 内置扬声器 拟真交互（可能的未来） 摄像头+麦克风 VR 输入设备键盘大部分情况下，键盘输入的事件会先发给焦点窗口，焦点窗口不处理则发给其父窗口，按此传递，直到有人处理了该按键事件，或者直到顶层窗口。 键盘从功能上来说，有两个不同的能力：其一是输入文本，其二是触发命令。 从输入文本的角度来说，要有一个输入光标（在 Windows 里面叫 Caret）来指示输入的目的窗口。目的窗口也是焦点窗口。这个交互的呈现方式非常稳定，从 DOS 到 Windows/Mac，到 iOS/Android 都是如此。 但是从触发命令的角度来说，命令的响应并不一定是在焦点窗口，甚至不一定在活跃窗口。比如 Windows 下就有热键（HotKey）的概念，能够让非活跃窗口（Inactive Window）也获得响应键盘命令的机会。移动时代的热键被设计为系统功能保留了下来。 鼠标麦克风交互方式不管怎么变化，其核心需要实现的都是这样的两大能力：输入文本和触发命令，这一点是不变的。 语音交互在 IoT 领域还停留在触发命令为主，而且这一件事情也还有许多关卡需要突破。 摄像头技术所限，还在萌芽阶段。微软的 Kinect 是一个经典案例。 输出设备显示器在逻辑上，通过引入窗口（window，也有叫 view），操作系统把显示器屏幕这个有限的设备资源，分配给了多个软件。和 PC 不同的是，移动设备由于屏幕过小，所以操作系统选择了让软件的顶层窗口全屏占据整个屏幕。这让显示器屏幕的管理变得更为简单。 除了窗口系统，显示设备管理的另一大挑战是绘制子系统。窗口里面的内容是什么、呈现成什么样子，完全是软件来决定的，这就意味着软件需要绘制能力。 绘制能力牵涉面非常之广，在操作系统里面，往往有一个独立的子系统（通常叫 GDI）与之对应。这里简单罗列一下 GDI 子系统会涉及哪些东西： 2D 图形相关。包含 Path(路径)、Brush(画刷)、Pen(画笔) 等概念。 3D 图形相关。包含 Model(模型)、Material(材质)、Lighting(光照) 等概念。 文本相关。包含 Font(字体) 等概念。而字体又分点阵字体和 TrueType 字体。TrueType 字体的优势是可以自由缩放。今天我们见到的大部分字体都是 TrueType 字体。 图像处理相关。包含 Bitmap(位图) 对象及常见图像格式的编解码器 (Encoder/Decoder)。 窗口系统结合输入设备对应的事件管理系统、绘制 (GDI) 系统，我们就可以随心所欲地实现各类用户体验非常友好的视窗软件了。 为了进一步简化开发过程，操作系统往往还提供了一些通用的界面元素，即控件 (Control)。不同操作系统提供的基础控件大同小异，不过一些处理细节上的差异往往会成为跨平台开发的坑。 音箱打印机软件使用打印机的过程基本上是互斥的。互斥的单位是文档。为了避免软件之间出现长时间的相互等待，操作系统往往在打印机的管理程序中引入很大的打印缓冲。软件操作打印机的时候，把文档打印到打印缓冲中就算完成打印。这样就避免了大多数情况下软件相互等待的问题。 小结尽管对 CPU 而言，所有外部设备有着相同的抽象，但这些设备的业务逻辑却如此不同，并不能统一抽象它们。正是因为有了操作系统这样的基础软件，这些设备业务逻辑的复杂性才从我们的软件开发过程中解放出来。 人机交互演化的核心变化是输入设备的变化。我们看到，输入手段的变化是非常剧烈的，且每一次演变都是颠覆性的变化。 事实上输入意图的理解越来越难了，因为交互在朝着自然（Nature）和智能（Intelligence）的方向发展。我们不可能让每一个软件都自己去做输入意图的理解（今天的现状是每个软件自己做），在未来，必然将由操作系统来实现智能交互的基础架构。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【学习】领域驱动设计实践（GitChat课程）]]></title>
    <url>%2F2019%2F06%2F17%2F%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E9%A2%86%E5%9F%9F%E9%A9%B1%E5%8A%A8%E8%AE%BE%E8%AE%A1%E5%AE%9E%E8%B7%B5%EF%BC%88GitChat%E8%AF%BE%E7%A8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[“战略”开篇微服务架构大行其道的当今，我们面临的一个棘手问题是：如何识别和设计微服务？领域驱动的战略设计恰好可以在一定程度上解决此问题。 第一部分：软件复杂度领域驱动设计概览领域驱动设计（Domain Driven Design，DDD）是由 Eric Evans 最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展成为了一种针对大型复杂系统的领域建模与分析方法。它完全改变了传统软件开发工程师针对数据库进行的建模方法，从而将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承和多态等设计要素，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。 领域驱动设计的开放性DDD是一种方法论，是设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程。 演进的领域驱动设计过程战略设计会控制和分解战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性与一致性，进而以演进的方式对之前的战略设计阶段进行迭代，从而形成一种螺旋式上升的迭代设计过程。如图： 深入分析领域的复杂度什么是复杂？Jurgen Appelo 从理解力与预测能力两个维度分析了复杂系统理论，这两个维度又各自分为不同的复杂层次，其中，理解力维度分为 Simple 与 Comlicated 两个层次，预测能力维度则分为Ordered、Complex 与 Chaotic 三个层次。 理解力影响理解力的第一要素是规模。 无论是优雅的设计，还是拙劣的设计，都可能因为某种设计权衡而导致系统结构变得复杂。唯一的区别在于前者是主动地控制结构的复杂度，而后者带来的复杂度是偶发的，是错误的滋生，是一种技术债，它可能会随着系统规模的增大而导致一种无序设计。 预测能力未来总会出现不可预测的变化。 控制软件复杂度的原则针对影响复杂度的3要素（规模、结构、变化），有： 分而治之，控制规模 保持结构的清晰与一致 拥抱变化 除了在开发过程中，我们应尽可能做到敏捷与快速迭代，以此来抵消变化带来的影响；在架构设计层面，我们还可以分析哪些架构质量属性与变化有关，这些质量属性包括： 可进化性（Evolvability） 可扩展性（Extensibility） 可定制性（Customizability） 领域驱动设计对软件复杂度的应对需求引起的软件复杂度需求分为业务需求和质量属性需求，引起的复杂度也分为两方面：业务复杂度和技术复杂度，两者并非完全独立。 当我们面对一个相对复杂的软件系统时，通常面临的问题在于： 问题域过于庞大而复杂，使得从问题域中寻求解决方案的挑战增加，该问题与软件系统的规模有关。 开发人员将业务逻辑的复杂度与技术实现的复杂度混淆在一起，该问题与软件系统的结构有关。 随着需求的增长和变化，无法控制业务复杂度和技术复杂度，该问题与软件系统的变化有关。 针对这三个问题，领域驱动设计都给出了自己的应对措施。 隔离业务复杂度与技术复杂度要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，首要任务就是确定业务逻辑与技术实现的边界，从而隔离各自的复杂度。毕竟技术与业务的关注点完全不同。 业务逻辑并不关心技术是如何实现的，无论采用何种技术，只要业务需求不变，业务规则就不会发生变化。换言之，在理想状态下，我们应该保证业务规则与技术实现是正交的。 分层架构的关注点分离 分层架构遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer），应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。 六边形架构的内外分离 体现业务逻辑的应用层与领域层处于六边形架构的内核，并通过内部的六边形边界与基础设施的模块隔离开。 案例：隔离数据库与缓存的访问 限界上下文针对前述案例，我们可以将缓存视为一个独立的子系统，它同样拥有自己的业务逻辑和技术实现，因而也可以为其建立属于缓存领域的分层架构。在架构的宏观视角，这个缓存子系统与订单子系统处于同一个抽象层次。这一概念在领域驱动设计中，被称之为限界上下文（Bounded Context）。 针对庞大而复杂的问题域，限界上下文采用了“分而治之”的思想对问题域进行了分解，有效地控制了问题域的规模，进而控制了整个系统的规模。一旦规模减小，无论业务复杂度还是技术复杂度，都会得到显著的降低，在对领域进行分析以及建模时，也能变得更加容易。 限界上下文对整个系统进行了划分，在将一个大系统拆分为一个个小系统后，我们再利用分层架构与六边形架构思想对其进行逻辑分层，以确保业务逻辑与技术实现的隔离，其设计会变得更易于把控，系统的架构也会变得更加清晰。 案例略 领域模型领域模型是对业务需求的一种抽象，其表达了领域概念、领域规则以及领域概念之间的关系。 一个好的领域模型是对统一语言的可视化表示，通过它可以减少需求沟通可能出现的歧义；通过提炼领域知识，并运用抽象的领域模型去表达，就可以达到对领域逻辑的化繁为简。 模型是封装，实现了对业务细节的隐藏；模型是抽象，提取了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性。 案例略 第二部分：领域知识组建好团队后做的第一件事：识别问题域，进而提炼达成共识的领域知识。在先启阶段、迭代开发阶段，都有相应的沟通和协作。 领域场景分析领域专家或业务分析师从领域中提炼出“场景”。组成场景的要素常常被称为 6W 模型，如图： 其中，业务价值、业务功能和业务实现，是领域功能的三个“职责”层次。 在电商系统中，买家要购买商品，因而“下订单”这一职责具有业务价值。通过领域分析，得到如下的分层结构： 下订单 验证订单是否有效 验证订单是否为空 验证订单信息是否完整 验证订单当前状态是否处于“待提交”状态 验证订单提交者是否为合法用户 验证商品库存量是否大于等于订单中的数量 基于业务规则计算订单总价、优惠与配送费 获取用户信息 获取当前促销规则 计算订单总价 计算订单优惠 计算商品配送费 提交订单 将订单项插入到数据表中 将订单插入到数据表中 更新订单状态为“待付款” 更新购物车 删除购物车中对应的商品 发送通知 给买家发送电子邮件，通知订单提交成功，等待付款 利用场景进行建模时，还要充分考虑场景的边界，即 Where。例如，“下订单”案例中，验证商品库存量的业务实现须要调用库存提供的接口，该功能处于下单场景的边界之外。 按照场景分析的 6W 模型去分析领域逻辑，提炼领域知识，可以在一定程度上保证领域模型的完整性。 领域场景分析的方法，包括但不限于： 用例（Use Case） 用户故事（Use Story） 测试驱动开发（TDD） 这三个方法都是领域场景分析的具体实现，但在运用层次上各有优势。 用例尤其是用例图的抽象能力更强，更擅长于对系统整体需求进行场景分析； 用户故事提供了场景分析的固定模式，善于表达具体场景的业务细节； 测试驱动开发则强调对业务的分解，利用编写测试用例的形式驱动领域建模，让开发者从调用者角度去思考领域对象及行为。 提炼领域知识需要贯穿整个领域驱动设计全过程，无论何时，都必须重视领域知识，并时刻维护统一语言。在进行领域场景分析时，这是一个双向指导与更新的过程。 建立统一语言统一语言是提炼领域知识的产出物，获得统一语言就是需求分析的过程，也是团队中各个角色就系统目标、范围与具体功能达成一致的过程。 统一语言体现在两个方面： 统一的领域术语 领域行为描述 在领域建模过程中，往往需要在文档中建立一个大家一致认可的术语表。包括术语概念，以及对该术语的清晰明白的解释。要给出对应的英文术语，否则可能直接影响到代码实现。 领域行为体现了更加完整的业务需求以及复杂的业务规则。描述领域行为的要求： 从领域角度，而非实现角度，描述领域行为 若涉及到领域术语，必须遵循术语表的规范 强调动词的精准性 突出与领域行为有关的领域概念 领域行为是一种契约，明确表达了业务关系，即前置条件、执行主语和宾语、执行结果。直接影响了API的设计。 第三部分：限界上下文理解限界上下文 上下文（Context）表现了业务流程的场景片段。它其实是动态的业务流程被边界（Bound）静态切分的产物。 Bounded Context 用一个清晰可见的边界将上下文勾勒出来，以便维持领域模型的一致性与完整性，避免业务目标的不单一而带来的混乱与概念的不一致。 理解限界上下文的关键点： 知识：不同限界上下文需要的领域知识是不相同的。这体现了业务相关性。 角色：参与这个上下文的对象扮演了什么角色，角色之间是如何协作的。 边界：限界上下文按照不同的关注点进行分离，各自的边界根据耦合关系的强弱来确定。 观察角度不同，边界也会有所不同，大体分为三个方面： 领域逻辑层面：确定领域模型的业务边界，降低系统的业务复杂度。 团队合作层面：确定开发团队的工作边界，降低系统的管理复杂度。 技术实现层面：确定系统架构的应用边界，降低系统的技术复杂度。 三种边界体现了限界上下文对不同边界的控制力。引入限界上下文的目的，其实不在于如何划分边界，而在于如何控制边界。 限界上下文并不是像大多数程序员理解的那样，是模块、服务、组件或者子系统，而是你对领域模型、团队合作以及技术风险的控制。 单元“自治”4要素：最小完备、自我履行、稳定空间、独立进化。 稳定空间要求符合开放封闭原则（OCP），体现为一个单元的封闭空间（封装隐藏）与开放空间（抽象统一）；独立进化则相反，意思要减少单元的变化对外界的影响，保证对外公开接口的稳定性。 对于统一语言，限界上下文是语言的边界；对于领域模型，限界上下文是模型的边界。二者可以帮助我们界定问题域（Problem Space）。限界上下文是连接问题域与解决方案域的重要桥梁。 限界上下文 分离了业务边界 明确了工作边界 封装了应用边界 应对高并发 功能重用 保证实时性 第三方服务集成 遗留系统 以上三条各有案例，略。 识别限界上下文限界上下文的识别并不是一蹴而就的，需要演化和迭代，结合着我对限界上下文的理解，我认为通过从业务边界到工作边界再到应用边界这三个层次抽丝剥茧，分别以不同的视角、不同的角色协作来运用对应的设计原则，会是一个可行的识别限界上下文的过程方法。 用统一语言描述出业务活动，然后参考如下两个方面识别业务边界： 语义相关性：将相同的语义作为归类的特征。 功能相关性：分析业务活动之间的关联和依赖，以此作为归类的特征。 我们需要对划定的业务边界进行命名，命名过程中可以识别业务活动的共同特征，用准确的名词表达该特征。 如果说为限界上下文划分业务边界，更多的是从业务相关性（内聚）判断业务的归属，那么基于团队合作划分工作边界可以帮助我们确定限界上下文合理的工作粒度。 从工作边界识别限界上下文，要考虑的几点： 保证质量属性 重用和变化 运用重用原则分离出的限界上下文往往对应子领域（Sub Domain） 封装变化，是“单一职责”原则的体现，即一个限界上下文不应该存在两个引起它变化的原因 遗留系统（一个还在运行和使用，但已步入软件生命衰老期的缺乏足够知识的软件系统）应该被视为一个限界上下文 理解上下文映射通过以上过程去识别限界上下文，仅仅是一种对领域问题域的静态划分，我们还缺少另外一个重要的关注点，即：限界上下文之间是如何协作的？倘若限界上下文识别不合理，协作就会变得更加困难，尤其当一个限界上下文对应一个微服务时，协作成本更会显著增加。反过来，当我们发现彼此协作存在问题时，说明限界上下文的划分出现了问题，这算是对识别限界上下文的一种验证方法。Eric Evans 将体现限界上下文协作方式的要素称之为“上下文映射（Context Map）”。 一个软件系统通常被分为多个限界上下文，这是运用“分而治之”思想来降低业务复杂度的有效手段，设计的难题往往会停留在“如何分”。然而限界上下文之间的“怎么合”问题同样值得关注，分与合遵循的还是软件设计的最高原则——高内聚、松耦合。 分是合的基础，基于内聚相关度进行合理的分配，可以在一定程度减少限界上下文之间不必要的关联。假设分配是合理的，则接下来的“合”就是要尽可能地降低彼此之间的耦合。]]></content>
      <categories>
        <category>软件工程</category>
      </categories>
      <tags>
        <tag>学习</tag>
        <tag>软件</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[【转】时装类网红模式的现状分析]]></title>
    <url>%2F2019%2F06%2F16%2F%E3%80%90%E8%BD%AC%E3%80%91%E6%97%B6%E8%A3%85%E7%B1%BB%E7%BD%91%E7%BA%A2%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%8E%B0%E7%8A%B6%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[本文是冷芸时尚圈企业主与高管俱乐部的圆桌讨论会议总结。参与讨论者嘉宾主要由私营企业主（包括设计师）与中大型企业高管组成。 （转自“冷芸时尚”公众号） 主题简介时间：2019年5月23日 主题：时装类网红模式的现状分析，以及未来一年内容营销的方向在哪里？ 主持人简介： Annie，资深的服装爱好者，建筑设计专业出身、后从事互联网，随着产业互联网的发展在这两个行业中找到了结合点。 参与嘉宾Annie-上海-企业主/高管俱乐部副部长 资深的服装爱好者，建筑设计专业出身、后从事互联网，随着产业互联网的发展在这两个行业中找到了结合点。 冷芸老师 冷芸，博士，时尚撰稿人、评论人、商业顾问、培训导师（买手、企业管理、创业课等）。 Cherie-上海-企业主/高管俱乐部副部长 企业高管俱乐部副部长，同时也是19届服装工程毕业生，能参加本次圆桌会议感到很荣幸。因为之前在潮流平台做过实习生，也接触到很多kol，对本方面也较为了解，作为95后阐述一下目前我们对网红经济的一些想法，谢谢大家。 赵莉-上海-电商 淘宝女装品类卖家，07年读大学的时候创业至今。经历过流量红利期、网红崛起期，对淘宝女装类目有较深的了解。 讨论大纲一、时装类网红的定义？ 二、该类网红现阶段的状况及瓶颈。 三、时尚类的内容营销是什么样的？ 四、未来一年时装类内容营销的方向。 引言“网红”即网络红人，随着互联网发展，越来越多的网络红人出现在各类平台，占据了我们的眼球。在这各类网红之中，有一类被行业内称之为时装类网红，这类网红为什么能够具备超强的带货能力？未来TA们会有怎样的发展？这些都是今天在今天的讨论之中。 以下讨论仅代表讨论者个人观点，并不代表本公众号及冷芸的观点。 一、时装类网红的定义？Annie-上海-企业主/高管俱乐部副部长: 大家好，我是一名资深的服装爱好者，在十几年前互联网还不发达的时候，就能讲出很多设计师的名字。建筑设计专业出身，后从事互联网，随着产业互联网的发展竟然在这两个行业中找到了结合点。今天的圆桌会议马上开始啦，这次圆桌的主题是“时装类网红模式的现状分析，以及未来一年内容营销的方向在哪里？” 既然说到产业互联网，衣、食、住、行皆乃人类生存之本，任何一项产业加上互联网都是产业互联网，正如我们今天主题中提到的“时装”、“网红”，细究起来也算是“衣+互联网”的一个分支。 互联网发展到现在，网红的力量的确不容小觑，掀起了无数“风浪”。网红发张图，一款衣服就可以卖脱销，所以相关的从业者都很关心，这个群体为什么这么厉害？又如何利用这个趋势呢？考虑到我们的行业，我们今天只讨论时装类网红，所以我们今天的第一个话题就是：时装类网红的定义是什么？ 赵莉-上海-电商： 我觉得，服装类网红根据平台主要分成三类：淘宝、公众号、直播。现在来看，三者主攻的方向各有不同，淘宝更适合个人品牌型的网红，比如说从最早的雪梨、VCRUAN，当然还有张大奕这种等等。 Cherie-上海-企业主/高管俱乐部副部长: 是的，这类网红都是标准的美女脸，大部分都是从微博火起来的。在我看来，时装类网红可以说是最早掀起波浪的网红，一般分为穿搭分享和生活方式分享。穿搭分享类是为了教学，教给观众一些实用的搭配技巧。而生活方式分享则更多一种理念的传达，在传达的过程中体现时尚感觉。 Annie-上海-企业主/高管俱乐部副部长: 公众号、直播类的网红有什么代表人物吗？ 赵莉-上海-电商： 公众号类有晚晚学姐、包先生、GOGOBOI、黎贝卡等代表人物。直播类型有最近很火的李佳琦、薇娅等，带货能力都超强。 Annie-上海-企业主/高管俱乐部副部长: 关于这类网红，大家还有其他要分享的吗？ 赵莉-上海-电商： 再补充一点，公众号倾向于与新锐设计师合作或者代理品牌，比如刚刚上面提到的那几位。而直播/抖音类则更倾向于代理各种线上线下品牌，比如现在很火的李佳琦。 冷芸-上海-群主： 淘宝通常是个人自有品牌。公众号代表中前面几位主要还是靠品牌广告/商业合作。直播/抖音就是纯粹销售。事实上所谓的网红评估标准从表象上看就是用户量。虽然现在这个用户量造假很严重。我听说基本上真实粉丝量是显示的8-30%之间。所以很多大品牌现在也学聪明了，开发了自己的数据监控软件来判断网红用户数据的真实性。 Cherie-上海-企业主/高管俱乐部副部长: 有的网红虽然粉丝量不大，但是基本为真粉丝，这样的宣传带货能力就更强。 赵莉-上海-电商： 是的，如涵旗下的网红，6万粉丝量的比30多万粉丝量的带货能力要强。 小结： 时尚类网红主要靠分享服装搭配和生活方式来吸引粉丝。 宣传渠道主要是淘宝、公众号和直播平台。 粉丝量看上去多，实际上未必，面临很大的考验。 二、该类网红现阶段的状况及瓶颈Annie-上海-企业主/高管俱乐部副部长: 大家已经提到我们接下来要讨论的内容了，分析一下这类网红阶段的状况及瓶颈，大家认为他们的现状如何？ 赵莉-上海-电商： 先从淘宝网红开始，我先引用网红小王的一段分析，相信大家也都有看到过。 以如涵为例，虽然旗下网红累计已经拥有1.484亿粉丝，但其中绝大部分来自微博（1.111亿）和微淘（3000万），而微信仅有670万，抖音则几乎可以忽略不计。即使是在电商网红领域已经走到顶级的张大奕，在微博拥有超过1000万的粉丝，在抖音的粉丝却只有15万，基本处于失语状态。 “代际更替。新渠道催生新品牌，新平台催生新内容，网红界也在发生代际更替。张大奕这代网红在微博上成名和变现，但现在年轻人更喜欢的是抖音、小红书、淘宝直播，最热门的玩法是短视频、直播，最带货的主播是薇娅、李佳琦。如涵需要复制这个时代的张大奕，而这种难度可能不亚于华谊复制一个范冰冰。”——摘自36氪《这就是商业｜如涵为张大奕“打工”》 冷芸-上海-群主： 这个现象很有趣。其实不仅仅是张大奕，几乎每个平台都有自己的头部KOL，但是这些头部KOL去到其他平台，就不一定火。不知道大家是否研究过这是为什么？ Annie-上海-企业主/高管俱乐部副部长: 每个平台的特性不同，核心用户也不一样。 Cherie-上海-企业主/高管俱乐部副部长: 因为受众群体的不同，其次是其他平台的网红也处于快饱和的状态。 赵莉-上海-电商： 我认为一方面就像老师讲的流量造假；另一方面是因为各平台有自己的定位，属性也都不一样。 冷芸-上海-群主： 仅仅是因为定位属性不匹配吗？我感觉造成这种现象的原因还有传播形式的不同。微博上基本以晒照片为主，微信需要图文并茂，直播主要看场控及应变，而视频主要看故事策划与剪辑能力，这种差异性也应该是原因之一。 Cherie-上海-企业主/高管俱乐部副部长: 是的，能拍照片的不一定能拍视频。 赵莉-上海-电商： 还有一点，和他们内部的工作人员也有关，会给流量。 冷芸-上海-群主： 指平台支持吗？这个是互惠互利的。 Cherie-上海-企业主/高管俱乐部副部长: 网红和平台共生吧，好的网红平台也会扶持，但在新平台基本算新人，从头做不简单。 Annie-上海-企业主/高管俱乐部副部长: 所以大家是否认同这样的观点“很多网红在新渠道上难以打开局面，而旧的渠道又无法做到不流失老粉丝，因此他们都面临增长乏力的瓶颈。” 赵莉-上海-电商： 我同意这个观点，还有流量红利的消失。 冷芸-上海-群主： 如果是这个问题，还有一个原因是，互联网时代所有事务的生命周期都变得更短了。大家的关注度时间段很短。喜新厌旧很快。新人出来的快，消失的也快。这属于社会因素。如果网红不能不断地保持一种高度创新的能力，基本上很快就被淘汰了。 Cherie-上海-企业主/高管俱乐部副部长: 是的，此外还有其他原因就是新一代年轻人喜欢的类型产生了不同。 Annie-上海-企业主/高管俱乐部副部长: 是的。从粉丝的角度去分析，人总会审美疲劳，PAPI酱刚出道时那么火，后来的视频大家也觉得乏味了。 赵莉-上海-电商： 对，再加上微博还限流。既然刷不到，久而久之就会忘记。 Cherie-上海-企业主/高管俱乐部副部长: 现在很多平台都会有限流的问题。 Annie-上海-企业主/高管俱乐部副部长: 我认同这一点，这跟平台政策很相关。 冷芸-上海-群主： 限流本质上是为什么？对平台发展有什么好处呢？ 赵莉-上海-电商： 这些靠微博起来的网红需要花很多的推广费用在微博上，因此能给平台带来盈利。 Annie-上海-企业主/高管俱乐部副部长: 微博的限流规则已经成谜了，用户和大V都搞不懂。我猜测是有商业变现的KPI。微博股价一度低迷，后来改变了变现规则又反弹回来的。 赵莉-上海-电商： 这也是如涵的推广费用高的原因之一。 Cherie-上海-企业主/高管俱乐部副部长: 我到现在都没有弄明白为什么要限流，是为了让红人花钱做推广吗？ Annie-上海-企业主/高管俱乐部副部长: 大体上可以这么理解，让大家都买推广、买会员。还有知乎、抖音等对于他们认为符合调性或者可能火起来的内容也会用算法去干预，这么一来，不合他们调性的内容也就变相被限流了。 Cherie-上海-企业主/高管俱乐部副部长: 我知道现在美拍为了拿推广提成，只让红人从平台接推广。 冷芸-上海-群主： 那就是平台都在寻找收费模式。这发展到最后就会和现在的淘宝一样，流量成本极高，以至于现在有些本末倒置。企业把更多的钱花在了流量上，而不是去做好品质。反正我至今没有花一分钱做推广买流量，不值得。 赵莉-上海-电商： 限流其实等于说，虽然粉丝是你的，但是如果你想让你的粉丝都能看到你，请付钱我再开门，更别提新流量了。据消息称，很多网红店的流量70-80%是靠微博带流量进来的。我们之前也有做过微博推广，推广时还可以选择你需要推送给谁的粉丝。 冷芸-上海-群主： 这个确实是问题。不公平。盈利肯定要互惠互利的，既然已经是自己的粉丝了，为什么还要限流。 赵莉-上海-电商： 等于微博掌握了所有的客户，同时还能把别家的客户卖来卖去，这在线下店铺是做不到的吧？ 冷芸-上海-群主： 这个就是靠用户数据赚钱，算是互联网特征吧。 小结：网红们普遍到了增长乏力的瓶颈期，主要原因有以下三点： 创新能力遇到了瓶颈（这个现象很好理解，一个人的创新能力毕竟有限）； 同质化严重，网友大众也觉得审美疲劳； 社交平台的限流现象（未必合理，但确实存在）。 三、时尚类的内容营销是什么样的？Annie-上海-企业主/高管俱乐部副部长: “网红的故事”我们聊得差不多了，现况就是营销越来越难做，粉丝越来越挑剔，但生意还得继续。下面我们来谈谈一种被广泛运用的营销方式——内容营销，看看能不能找到突破点。请两位先说一下对内容营销的看法吧，先不用切入服装这个细分领域。 赵莉-上海-电商： 我来分析一下几类网红的内容营销方式： 1、张大奕/雪梨这类微博为主的内容，卖的是生活状态、人设。有点类似于经纪公司操作明星的办法； 2、李子柒这一类通过视频，传达观点或者用户向往的生活方式； 3、公众号通过文字表达观点； 4、直播，主要传达对产品的个人理解+才艺等等。 冷芸-上海-群主： 内容营销的质量最主要取决于几个要素： 1、主题策划。我个人观察是这个因素比传统出版时代时的主题策划显得更为重要。几乎占50%以上因素； 2、其次，标题； 3、具体呈现形式。无论是什么形式的主题。 不过这也要看客群。有些看似很无聊的内容居然也很吸粉。有的在我看来是低智商内容但是却很受欢迎，所以我预估未来人群在智商上会有更大的分层。 赵莉-上海-电商： 人以群分，还是很有道理的。 Annie-上海-企业主/高管俱乐部副部长: 我想分享一下我对内容营销的定义。内容营销即靠内容去吸引粉丝，获得粉丝黏性之后再做变现。这里的内容通常是大家说的“干货”，形式可以是文字、语言、视频等等，但不是广告或者软文，因为在内容营销在初始阶段就发广告的话，是无法积累粉丝和口碑的。 Cherie-上海-企业主/高管俱乐部副部长: 内容营销就是思想的传达，从微博早期的图片到后期的一条、梨视频、公众号的图文、视频的拍摄等等，一切可以通过公众平台阐述的安利，我认为都属于内容营销。 赵莉-上海-电商： 比方说通过小红书的红人或者公众号等等一些相关账号推荐，主要还是看对方的受众。 Annie-上海-企业主/高管俱乐部副部长: 谢谢大家的分享，那时装或服装的内容营销，一般具有什么样的特点呢？我举个例子，彩妆类的内容营销一般是靠测评，比如粉底测评、口红试色等等。服装类也有服装类的特点，做内容营销的一般从哪几个方面下手？有什么案例和数据？ Cherie-上海-企业主/高管俱乐部副部长: 服装类的内容营销目前最多的就是微博带路，淘宝购买。其次还有公众号自己的小程序，以及小红书的安利。最近听说抖音接入微信，打算做视频产品识别。一些小众的平台，比如我喜欢看的NOTHING，也是穿搭分享可以直接链接购买地址的程序。服装营销更多的就是模特穿着好看或者一些博主买手的穿搭推荐。 冷芸-上海-群主： “服装”与“时尚”是有区别的。我刚做的调研显示，服装类的内容消费者主要看几个方面：最主要是搭配、流行趋势；其次是新品上市；最后是产品知识还有促销打折。这些都是比较实惠、务实的信息。 Annie-上海-企业主/高管俱乐部副部长: 谢谢冷芸老师指正，可否简单粗暴地理解为“服装类”内容更偏向研究型，“时尚类”内容更偏向资讯型？ 冷芸-上海-群主： 服装类更偏向资讯与销售，而时尚更偏向于造梦。 赵莉-上海-电商： 女装类我个人认为主要还是看搭配带动比较多。虽然做服装测评的公众号现在也不少，不过都是在头部女装卖家的测评，比如是看起来类似的产品做对比。 Annie-上海-企业主/高管俱乐部副部长: 产品对比、测评也算是内容营销。我关注服装类网红比较多，总的来看我认为他们有这么几个特点： 1、自身具备一定的说服力，身材一般不错，靠搭配能力和识货能力说话； 2、少部分靠广告，大部分靠自创品牌来变现，两者结合的也常见。 关于当前的内容营销，在内容上、形式上、卖点打造上大家还有什么要补充的吗？ 赵莉-上海-电商： 如果是淘宝上的话，图片、口碑最重要，所以现在充斥了各种付费买家秀。我觉得这个是淘宝上很重要的内容营销。 Annie-上海-企业主/高管俱乐部副部长: 付费买家秀，原来如此，怪不得我看有些买家秀质量很高。 冷芸-上海-群主： 买家相信买家秀吗？ Annie-上海-企业主/高管俱乐部副部长: 不完全信，“真的觉得好”和“硬要说他好”的评价还是不太一样的。 冷芸-上海-群主： 互联网一个很大问题是数据造假成本太低。 Cherie-上海-企业主/高管俱乐部副部长: 付费的挺多的，很多都是找的学生兼职。 赵莉-上海-电商： 其实很多人知道，也有很多人不知道。不过很多人抱有的心态是：就是想看看普通人穿什么样，总之是这家的衣服就行。 冷芸-上海-群主： 这么说也有买家相信？不然何必花大价钱！还有，用户知道这些人是付费买家吗？ 赵莉-上海-电商： 我倾向于大部分的人不知道，或者说也许知道，不过也无所谓，默认了这种情况。 Cherie-上海-企业主/高管俱乐部副部长: 很难分辨，大部分人都不会刻意考虑是付费买的。 冷芸-上海-群主： 这种现况让我不得不认为互联网在培育了一批高智商用户的同时，也培养了一批低智商用户。有的人靠互联网越来越聪明，有的靠着它却越来越没有判断力，流失自我。 Annie-上海-企业主/高管俱乐部副部长: 我觉得这些人本来就存在，只是借着互联网被大众看到了。 小结：时尚类内容营销的形式和侧重点，因平台的不同而不同，比如： 微博为主的内容，卖的是生活状态、人设，有点类似于经纪公司操作明星的办法； 视频，往往传达观点或者向往的生活方式； 公众号通过文字表达观点； 直播，主要传达对产品的个人理解+才艺，等等； 内容营销的质量最主要取决于主题策划、标题和呈现形式这几个方面。 四、未来一年时装类内容营销的方向。Annie-上海-企业主/高管俱乐部副部长: 接下来我们要讨论最后一个问题了：未来一年时装类内容营销的方向。大家觉得会和现在的内容营销有什么不同吗？ 赵莉-上海-电商： “进入2019年以来，以卖货为导向的电商直播正在逐渐取代秀场直播在陈鹏博心中的位置：’每一场直播的内容和打赏都是不可控的，但是电商直播的每个环节都是更容易被量化的，是一个可持续的商业模式，直播会成为电商的重要场景之一。’ 根据淘宝公布的数据显示，2018年，淘宝81名主播年引导销售额过亿元，进入淘宝直播亿元俱乐部。淘宝直播方面更是宣布，未来淘宝直播将带动5000亿的成交规模。在淘宝总裁蒋凡看来“直播已经不是点缀，而是未来商业模式的主流。”——摘自《36氪专访 | 愿景娱乐创始人陈鹏博：我是如何做成抖音第一大直播公会？》 Annie-上海-企业主/高管俱乐部副部长: 这段主要在讲直播将变得更重要。为何会这样呢？除了网速越来越快以外，还有别的原因吗？ Cherie-上海-企业主/高管俱乐部副部长: 因为没有和视频图片制作者互动的照片、视频等内容已经满足不了消费者了。 冷芸-上海-群主： 直播是所有这些渠道里会发展最好的，相对难以造假且现场互动效果好。但直播不是一般人能做的。 赵莉-上海-电商： 是的，这也代表了我的观点，为什么主题是讲未来一年可能的营销方向，但不是十年八年，因为就如老师所讲，互联网加速了所有的事情，之后还会出来什么？很难推测。未来一年里，我认为直播是一个很重要的内容营销方式。 Cherie-上海-企业主/高管俱乐部副部长: 对我来说，我是一个只会看游戏直播的人，不知道淘宝直播的主要客户群体是哪一类人群？ 赵莉-上海-电商： “2018年，通过淘宝直播带货成交超过 5000 万的店铺有 84 家。不只是淘品牌注重直播，像欧莱雅、宝洁这样的大公司也来了。2018 年双 11，淘宝主播薇娅还接下了‘宝洁全球好物推荐官’的头衔。一周前，汰渍将明星海清和薇娅请来，当天薇娅的直播间累计超过 550 万观看人次，活动上线半小时成交额便打破品牌淘宝直播单场销售记录。”——摘自好奇心日报《电视购物升级网红直播，背后还有什么变化》 冷芸-上海-群主： 直播主播过的日子不是一般人能挺住的，一年365天，每天只睡四五小时，剩下时间都在直播，这种生活方式严重有害健康啊！ Annie-上海-企业主/高管俱乐部副部长: 原来这么辛苦，休息两天会很影响业绩吗？ 冷芸-上海-群主： 休息了流量立刻去到别家了，平台会不给支持的。 Annie-上海-企业主/高管俱乐部副部长: 真不容易，没有一份工作是容易的。大家都认同直播是未来一年的趋势，需要重点关注。那么我们拆分几个细节问题来讨论。首先大家认为直播平台最值得关注的是哪个？是淘宝吗？ 赵莉-上海-电商： 其实看直播的人还是占小部分的，我个人估计是三四线城市的人应该更多。就像是上一次我们圆桌会议所讨论的，三四线人群的可支配收入比一二线的人多，现在发展向下沉更有潜力。直播的平台有很多，如果是卖衣服的话，还是淘宝。 冷芸-上海-群主： 是的。 Annie-上海-企业主/高管俱乐部副部长: 大概三四线人们真的有钱有闲吧，主要是有闲，他们电影票房增长也很可观。 赵莉-上海-电商： 看到这样一个数据： “根据淘宝方面透露的信息，淘宝用户里只有比较小一部分会看直播，但看了直播的人，平均每次停留超过半个小时，许多用户在直播间会下单两件以上的商品。从另一个方向，做短视频的快手、抖音也从 2018 年开始接入电商，因为带货快，“抖商”这样的词也被创造出来。”——摘自好奇心日报《电商直播从“网红”开始，但网红已不是曾经的网红》 Cherie-上海-企业主/高管俱乐部副部长: 那频率算很高的了。 Annie-上海-企业主/高管俱乐部副部长: 淘宝直播的特点：用户基数不大，但转化率高。 赵莉-上海-电商： 甚至微信也在做直播内测了，据说效果很不错。我是指微信卖货。 Cherie-上海-企业主/高管俱乐部副部长: 因为看直播大概率都有购买欲望。 Annie-上海-企业主/高管俱乐部副部长: 微信要开放直播功能吗？ 赵莉-上海-电商： “时尚自媒体‘她读’在微信生态内利用腾讯直播打造了一场直播电商首秀。这款腾讯于3月推出直播工具，专门服务于微信公众号对直播能力的诉求，支持音频和视频两种直播形式。 在4月22日的2小时直播中，在线观看人数达11951次，订单数1228笔，转化率达18.32%。通常，内容驱动平台的电商转化率做到5%已属不易。”——摘自36氪《最前线 | 微信公众号又多了一个赚钱之道，直播电商会成为主力吗？》 Annie-上海-企业主/高管俱乐部副部长: 非常有用的信息，那我们讨论完渠道，再来聊聊内容吧，什么形式的内容未来会比较受欢迎呢？比如是测评类的内容，还是什么类型的内容最受欢迎？以及他们会在直播中讲什么、聊什么？ 赵莉-上海-电商： 有趣是必须得有的，就跟综艺类节目一样。 Annie-上海-企业主/高管俱乐部副部长: 同意，抓住用户的注意力，调性轻松愉快的。 Cherie-上海-企业主/高管俱乐部副部长: 能调节气氛的、需要对每件衣服拿捏得很好、口才等等，很考验综合能力。 Annie-上海-企业主/高管俱乐部副部长: 这还是很考验主播的综合能力的。这么多主播，他们肯定也存在差异、各有派别。大家可以多聊聊吗？我淘宝关注了一个买化妆品的店，他们就靠老板和客服出镜来给顾客做演示，还会发一些直播优惠券，画风还是挺朴实的，但销量不错。 赵莉-上海-电商： 其实派别一般无非这几种： 1、上新前详细面料搭配介绍以及发放优惠券； 2、边逛边试版，现在很多逛东大门边卖试版卖货； 3、搭配类，就是很多人家给她衣服，搭配在一起推荐； 4、旅行类，一边旅行一边直播自己的穿搭。 Annie-上海-企业主/高管俱乐部副部长: 这几种效果都很好吗？ 赵莉-上海-电商： 也不尽然，会受到很多因素影响。当然最主要就是流量，你自己有没有流量，淘宝给不给你流量。一般新手直播的话，要连续直播一段时间，淘宝后台才会给你“浮现权”，也就是说如果你只是偶尔播的话，自己又没什么流量的话，是没人看得到的。 Cherie-上海-企业主/高管俱乐部副部长: 淘宝直播应该是直接依托在店铺下的吧？ 赵莉-上海-电商： 也不是，有专门的“主播”。比如美妆类，最近就出了“李佳琦”这个人，相信大家都有听说过，他就不是开店铺的。 冷芸-上海-群主： 李佳琦是品牌公司扶持的。 Cherie-上海-企业主/高管俱乐部副部长: 背后团队肯定很强，这样突然一下爆红应该有推手。 Annie-上海-企业主/高管俱乐部副部长: 哪个入口的流量占比大？是集中的“主播”入口，还是店铺里的入口？ 赵莉-上海-电商： 这个没有数据表明哪个流量更大，所以没办法说。不过通过李佳琦这个现象，也想最后讲讲我的看法，今年他与马云做了一次直播卖口红的PK，大家知道吗？ Annie-上海-企业主/高管俱乐部副部长: 马云亲自卖口红吗？ 赵莉-上海-电商： （图片来自腾讯新闻） 对的，马云亲自卖口红。 Annie-上海-企业主/高管俱乐部副部长: 哈哈哈，结果怎么样？ 赵莉-上海-电商： 马云惨败，但这件事本身其实还是很有噱头的！ Annie-上海-企业主/高管俱乐部副部长: 这也是一个内容营销方向吧，男色经济。总结一下咱们这一部分，未来直播仍然是内容营销的重头戏，淘宝直播的转化率高。内容形式上也多种多样，但主播的综合能力才是最关键的！ 赵莉-上海-电商： 李的成功，除了背后的团队之外，他个人也有专业的技能。我有看过一些买家的评论，甚至是腾讯新闻里（留言水平都不咋地），很多人都觉得他推荐的东西真的好用。 Cherie-上海-企业主/高管俱乐部副部长: 产品是关键，这也是独立主播的好处，在品牌下的主播没有更多的选择权。 赵莉-上海-电商： 他原本是欧莱雅的柜哥，对口红真的是有研究，主要推的就只有口红，让人家一下子记住他了。而不是像过去的其他主播，什么都卖，吃的、喝的、洗脸的甚至洗头的都卖。 今年4月底我们去的淘宝卖家大会上，负责人也指出淘宝女装希望给客人留下心智，比如卖汉服类就想到“淘宝”。简单来讲，就是一想到这个人或品牌，你就会知道他是干什么、卖什么的。 结合以上，不难得出淘宝本身在主推直播以获取更多的流量，也不再像是过去的主播什么都卖，而是更专注于细分化、专业化。 Cherie-上海-企业主/高管俱乐部副部长: 人群也在细分，那么商家也是需要作出相应的改变。 赵莉-上海-电商： 是的，也可以这么理解。淘宝的系统在给人们打标签，流量红利结束了，流量的利用率自然要提高。用直播引流，并且用更专业、更细分的形式去吸引住大家。 Annie-上海-企业主/高管俱乐部副部长: 谢谢大家，接下来请群友们自由讨论或者提问吧，我们进入互动环节。 小结：未来一年，直播仍然是时尚行业内容营销的主要阵地，并且其运营方式会更加精细化、专业化。并且不管何种营销方式，“人+产品”都是关键，找对“主播”很重要，用对创意更有效。 Dragon-风谜科技服装-产品经理: 我们和公众号合作比较多，还有小红书KOL也有研究合作过。内容电商公众号这一块对于新品牌帮助还是挺大的，前提是产品要有卖点。 赵莉-上海-电商： 公众号我知道做得好的话效果的确是不错的。小红书真的有用吗？我做过几次效果都很平。 Dragon-风谜科技服装-产品经理: @赵莉-上海-电商： 小红书的要好好筛选。 Stephen-米兰东京-时尚协会: 喜欢看直播然后消费的还是以年轻人为主吧，直播卖的货单价都不会太高。 Cherie-上海-企业主/高管俱乐部副部长: 价格便宜不等于年轻人购买多。 赵莉-上海-电商： 并不是哦，直播带动成交最好的你们猜是什么？ Cherie-上海-企业主/高管俱乐部副部长: 目前基本所有的奢侈品牌都在走年轻化，就是因为消费主力在变年轻。 赵莉-上海-电商： “目前来说，直播带动成交最高的五个分类分别是：珠宝、女装、流行饰品、美容护肤及童装。排在最前面的珠宝行业，全淘宝有超过五成的成交是来自直播。”（摘自好奇心日报） 冷芸-上海-群主： 直播会逐步走高的。 赵莉-上海-电商： 珠宝这个类目，我真的也没想到。 Stephen-米兰东京-时尚协会: 珠宝这个我倒是发现了，因为我经常看到我朋友圈两个珠宝商都在说直播卖货。 Dragon-风谜科技服装-产品经理: 我觉得宝妈是大头，毕竟掌握全家的经济。 赵莉-上海-电商： 其实有点像以前电视里那种：不要1999 也不要999 台湾口音的那种。现在手机大妈大爷也都会用呀，我爸还天天刷抖音呢，还叫我也去抖音卖货。 冷芸-上海-群主： @Stephen-米兰东京-时尚协会 这种珠宝靠谱吗？ Stephen-米兰东京-时尚协会: 我觉得珠宝行业在直播行业有销路也是有一定的原因的。因为珠宝市场真真假假太多，很多消费者对购买珠宝是非常小心谨慎的，这需要销售者费更多的口舌让消费者信任自己。 我偶尔看到抖音和快手上都会发现有珠宝商在上面做宣传打广告强调自己卖的珠宝都是真货好货。可能像直播这种代入感强的销售模式更能拉近卖家和买家的距离消除不信任感。至于靠不靠谱，这个就不好说了，因为珠宝行业的水太深了。 上海—蝴蝶—服装公司主理人: 珠宝分很多种，我转行做过两年。金银翡翠是珠宝，钻石彩宝也算是珠宝，一定程度上文玩儿也有些东西被称作珠宝。 Stephen-米兰东京-时尚协会: 我在网上看到直播卖的珠宝一般是玉石翡翠、蜜蜡、珍珠这类。 上海—蝴蝶—服装公司主理人: 直播卖的珠宝应该不是精尖货品，既然能走量，必然是通货。第一客单价低、第二精品量没那么大，尤其珠宝都是独一无二天然品不可复制，越精尖货越量极少。所以我觉得那个直播的珠宝二字可以带个引号 ——“珠宝”。或者可以叫做饰品。 Stephen-米兰东京-时尚协会: 这个定义很精准！ 总结时尚类网红主要靠分享服装搭配和生活方式来吸引粉丝。这些网红们的宣传渠道主要是淘宝、公众号和直播平台。这些网红的粉丝量看上去多，实际上未必，面临很大的考验。 一、网红们发展到现阶段普遍到了增长乏力的瓶颈期，主要原因有以下三点：1、创新能力遇到了瓶颈（这个现象很好理解，一个人的创新能力毕竟有限）；2、同质化严重，网友大众也觉得审美疲劳；3、社交平台的限流现象（未必合理，但确实存在）。 二、时尚类内容营销的形式和侧重点，因平台的不同而不同，比如： 1、微博为主的内容，卖的是生活状态、人设，有点类似于经纪公司操作明星的办法； 2、视频，往往传达观点或者向往的生活方式； 3、公众号通过文字表达观点； 4、直播，主要传达对产品的个人理解+才艺，等等； 内容营销的质量最主要取决于主题策划、标题和呈现形式这几个方面。 三、未来一年，直播仍然是时尚行业内容营销的主要阵地，并且其运营方式会更加精细化、专业化。并且不管何种营销方式，“人+产品”都是关键，找对“主播”很重要，用对创意更有效。年轻一代逐渐成为消费主力，销售渠道也更加多元，未来可能在直播的基础上发展、衍生出更多的内容营销方式，我们要做的是紧跟时代，内容为王。 本文是#冷芸时尚圈#企业主与高管俱乐部的圆桌讨论会议总结。参与讨论者嘉宾主要由私营企业主（包括设计师）与中大型企业高管组成。 文章编辑：Cherika Chen]]></content>
      <categories>
        <category>商业之潮</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>商业</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《世界正在变软》微信读书笔记]]></title>
    <url>%2F2019%2F06%2F14%2F%E3%80%8A%E4%B8%96%E7%95%8C%E6%AD%A3%E5%9C%A8%E5%8F%98%E8%BD%AF%E3%80%8B%E5%BE%AE%E4%BF%A1%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[书名：世界在变软作者：水木然 看书起因6月13日晚7点，切切Candy（16年暑假认识，一个用聊天带给我温暖的网友）开始了她的第一次直播讲课，内容是ACCA练习。 作为一个高一之后就没有受过系统文科训练的门外汉，我听了她的直播以后也有所收获。其中之一，就是因为“经济危机万恶资本家倒牛奶事件”从供需角度分析让我有些疑惑，于是我抱着解决疑惑的想法查阅了得到APP，搜索关键词之后发现了这本书。刚好微信读书也有，我就用2小时19分钟快速看完了，并且做了如下笔记。 读完后的点评★★★★☆ 1.这本书的谋篇布局不太好，显然是零散的博眼球网文拼凑起来的，有很多重复提及的内容。不过单独挑出几节来，还是有质量的（比如我频繁划线的那几节）。 所以，我看得挺快的，一些对我没用的部分我当成废话一扫而过。也不是说这本书差，只是对于非虚构类的书，我基本都是快慢结合看的。 2.书中的观点并不新鲜，在小众范围（更接近未来的人们）当中，有些已经成为共识。还有一些观点，有点片面，或者带有玄学色彩，或者煽情而不可靠。 尽管如此，对于多数普罗大众来说，仍然是不错的科普读物，推荐不了解的人阅读以长见识。只是须要注意，要独立思考、批判性接收，别被一些观点带偏了。 62条笔记 人类文明正值一次全新的大升级，从“大工业时代”跨越到“数据时代”，我们也因此面临一场空前的社会秩序重组。每一次的社会升级都会有万物凋零，也必然有万物在悄然重生。 从本质上来说，世界正在“由硬变软”。 工业时代遵循的逻辑是“占有大于一切” 数字时代遵循的逻辑是“连接大于拥有” 数字时代的贸易核心是信息化调度，而非工业时代的物理输送体系。 每个人都只是一个信息节点。 所以，信息时代，人的注意力具有很高价值。如何吸引更多人的注意力？讲好故事。信息时代，讲故事的能力很重要。 第一章 商业 这是一个无边界的时代，每一个行业都在整合，都在交叉，都在相互渗透。如果原来你一直认为获利的产品或行业，在另外一些人的手里突然变成一种免费的增值服务，你又如何竞争、如何生存？ 中国正在形成新的商业形态，商业形态最大的变化是供应链的变化。 传统狭长的供应链变成逆向的、扁平的，这就是以“网红经济”为代表的新供应链。 “网红经济”的本质是一种聚合消费者的艺术，意味着商业正在由“物以类聚”向“人以群分”过渡。 终于知道前几年自媒体行业为什么那么赚钱了。 传统狭长的供应链变成逆向的、扁平的，这就是以“网红经济”为代表的新供应链。“网红经济”的本质是一种聚合消费者的艺术，意味着商业正在由“物以类聚”向“人以群分”过渡。 “精准匹配”是共享经济的本质。 在个性化的需求下，即使是一件单品，传统工厂一开工可能就是10万件。但是在“淘工厂”平台上，却可以将一件单品从100件起做，原先由几十人承担上万件服饰生产的大流水线，转变为现在2～3人裁制10～20件衣服的小流水线。这就是快速反应的柔性化生产。举个例子，很多网红喜欢做预售，他们做一场直播就可能订购上千件衣服，之后马上给工厂下订单，去掉物流的时间，工厂的生产时间也就3～4天，但是依然能够满足这种需求。从大订单模式走向小订单生产，就是未来工厂出奇制胜的关键。而且这种模式也让那些处于淡季的工厂可以开动机器，避免了资源闲置和浪费，这也是共享经济的价值所在。传统企业最大的特点是“计划性”，从面料供应商再到款式设计的公司，需要有计划性地去推进，强调系列性，需要不断宣传自己品牌的故事，靠这些去打动人。 海量的中小品牌正在崛起，这才是中国真正的商业变化的大势所趋。 这里面有创业机会。 商业变革的逻辑其实就是整个社会发展的投影。公开化、共享化、平台化、定制化就是社会发展的大势所趋。 “库存”和“折扣”是吞噬传统商业的两大黑洞。库存导致低效率，折扣导致低利润率。 以前，现金流不如利润率重要。未来，现金流远比利润率重要。未来流经你这里的现金流越多，意味着你获得的利润就越多 未来的社会主要有三种企业角色。●负责国计民生的资源型企业（如国企、央企）。●负责商品流通的平台型企业（如腾讯、阿里巴巴、百度等）。●在各种细分领域里具有独特产品或深度服务的小公司（价值主体）。除此之外，就是游离在各种平台上的个体，比如，网店店主、自媒体人、律师、设计师、会计师等（价值个体）。如果以上这些都没有你的一席之地，那么你就应该思索一下自己的未来定位了。在社会不断向“平台+个体”的结构转变的过程中，平台先淘汰掉了一部分人，如各级经销商、中介、经纪人、销售人员等“二道贩子”。与此同时平台又需要很多新人，如技术、美工、客服、采购、策划等运营人员。 我们首先迫切地需要重塑文化，其次是重建信用。 未来每个人都像U盘似地，即插即用，今天可以进入这个团队，明天可以进入那个团队，并形成网状组织，这种网状组织看似有组织、无纪律，但又具备完善的价值分享机制，可以自助式运转，可以随时产生聚变与裂变效应，发挥巨大效能。 罗辑思维14年的一期节目《u盘化生存》就讲过了。另外我还想到RpgMaker吧里面，数量特别多的一类帖子是游戏制作人发帖寻找画师或者程序员。 工业抢空间，互联网抢时间，这是完全不同层次的思维。 当资本得到它们预期的利润之后就会撤出，留下一个空虚的躯壳，所以很多公司成也风投，败也风投。当然，资本对所有的新兴产业都是这样，包括人工智能等。 华为就是，不上市，不IPO。 对于每一个人来说，必须明白两点： 一个是空间：你所处的上下游环节是什么？ 另一个是时间：你“收割”或“被收割”的时间到了吗？ “农业-工业-互联网-资本-权力-民众”这个产业轮回的食物链回路很有意思。每一位置都有机会“收割”，也都会“被收割”。 ●线上的“信息流”和“货币流”是相辅相成的，它们构成了虚拟经济；●线下的“产品流”和“人群流”是互相映衬的，它们组成了实体经济；●线上的“虚拟经济”和线下的“实体经济”是交相辉映的，它们形成了经济主体。 一阴一阳谓之道。线上的虚拟经济和线下的实体经济的关系与和谐程度，决定了经济的健康程度和发展态势。 书的这部分（从讲E=mc^2开始到这里），突然变得玄学（神棍附体）。 科技和金融分别是实体经济和虚拟经济的核心支撑点。科技的本质是生产力，金融的本质是生产关系。生产力决定生产关系，生产关系一定要适应生产力的发展，不然就会对生产力产生阻碍 等着未来的脱虚向实、以虚促实。 实际上，掌握节点比掌握趋势要重要得多，比如房价，都说长期来看是上涨的，关键问题是房价的局部会有回落，那就要看你对节点的拿捏是否精准。 我认为：不关注节点，奉行长期主义，也不错。 第二章 社会 唯一不变的就是变化。中国，没有永远的“北上广”。 上学、放学、周末、寒假、暑假这种时间界限将变得越来越模糊了，最先学会自律的人将最先走向成功。先是自我认知，再是自律，最后是自信，这是教育过程中的人格形成路线。 在人工智能时代，计算机的知识能让你随时取用，你要做的只是融会贯通，由一滴水看见大海，由一粒沙而感知世界。 第三章 人 普通人成群化，精英个体化，王者孤独普通人喜欢成群结队。他们之间的结盟并不是因为利益和价值观，目的性不强，常常聚得快散得也快。精英们则越来越个体化，他们总是小心翼翼地保持和每一个人的距离，随时可以和一个人走得很近，也经常和别人疏远，他们不会随便沾亲带故，谨慎处理和每一个人的关系，因为这样进可攻、退可守。王者永远都是孤独的，尽管高处不胜寒，但他们自身已经比较圆满，所以并不需要被理解、被认同。他们的动力来自于希望和理想，然后按照自己的设定处事，心中无缺所以富有，被人所需所以贵气。 普通人做事，精英做式，王者做局 刘润那句名言是：普通人改变结果，高手改变原因，顶级高手改变模型。不过看来刘润说的顶级高手也不过是“精英”，只会改变模式。而真正的王者则是游戏规则的制定者。 社会的基本组成从“企业+员工”迈向“平台+个人”。时代不一样了，兴趣也能当饭吃了。热爱，才是互联网时代的第一生产力。 部分正确。至少现在还不能拿兴趣当饭吃。 人和人需要联合起来才能战胜自然，所以人和人的距离走得越来越近。而现在随着社会物质的极大丰富，人与人之间的距离正在疏远。 老子曰：“大曰逝，逝曰远，远曰返”，意思是万物都是由小到大、由大到小循环往复、变化发展的，揭示了一种对立转化的规律。老子还有句话：“鸡犬之声相闻，民至老死不相往来。”其实这句话可以理解为人和人相处的最高境界：即便近在咫尺，却也不会互相影响和干涉，彼此独立，和而不同。君子之交淡如水。人与人之间最好的关系是欣赏彼此的长处，懂得对方的不容易，互相欣赏和关注，虽然不天天在一起，但是当你需要帮忙的时候，他能伸手；当他有需求的时候，你懂他想要什么，这是一种默契，也是人与人之间最好的关系方式。 第四章 价值 同梵高相比，毕加索显得更识时务。 同特斯拉相比，爱迪生显得更识时务，一手缔造了通用电气公司。 富人总是想着借鸡生蛋，用银行的钱来为自己积累财富，最终让自己走上致富之路。 其实负债也是一种能力。 吴军讲，哈佛商学院主要教学生具备的能力之一是“骗钱”。也即说服他人，借鸡生蛋。 这个世界上越牛的人，负债（欠的钱）越多。 夸张，但有趣的观点。美国国债。 财富的本质无非是两个字：“诚信”。 为什么人们可以约定一张纸就是一般等价物？货币的本质：国家信用。 未来的财富形式一定是估值或市值，趋于虚拟和抽象。究其本质，是整个社会越来越共享化、公开化、公共化。 要专注、专注、再专注。要充分认识自己，发掘自己，坚持做某个细分领域的第一名，哪怕是一个非常细小的领域，能做到了这一步，你就不再平凡。 我们直接从“中国制造”一下子跃升为“中国模式”。以前我们一直在跟德国、日本、美国比拼产品，现在不用了，我们不比产品而改为比拼平台了。海纳百川，有容乃大，有能力的都来吧。我们提供一切基础设施，这是非常高超的一步棋，直接“弯道超车”。 中国向海外输出的已经不再只是物美价廉的商品，而是各种应用模式，比如我们津津乐道的中国“新四大发明”——高铁、网购、共享单车和移动支付。 “人单合一”的基本含义是：每个价值的创造者不再直面组织或岗位，而是应直接面对用户，创造用户价值，让人因用户而存在 我们总是在强调“连接大于拥有”，更进一步来说是“触点大于连接”，建立连接的机会已经越来越多，但是只有“触点”才能引发价值交换。 第五章 大象无形——软实力输出 我们已经生产出了大量的产品，只是由于经济制度原因，这些产品无法送到最需要它的人手里而已。所以说，当前世界最需要解决的不是“生产效率”问题，而是“分配效率”问题。 要在把牛奶分配到最需要它的人手里去的同时，充分调动劳动者的劳动积极性，让劳动者和资本家双方形成良性互动。 这个就是我搜索“经济危机 倒牛奶”时找到的。得到的“内容检索”很强。 中国文化一定会将世界“切换”到一个全新的“操作系统”，而设计和开发这个全新操作系统所用的语言，就是中国的传统文化，它将帮助世界建立起全新的规则和制度。 我说…中国的传统文化不是早就出现断层了吗？现在的很多国学只是传统文化皮囊下的的现代思想（得益于文言文的模糊表意）。我偶尔听思想隐士熊逸的讲书，抽丝剥茧之后，国学就是历代士人不停对古之圣人之言做出新的解释而已。 第六章 关于未来 为语言的出现，让人类彼此有了协调和信任工具，所以人类的经验、智慧得到分享和传承，而且可以高效地协作。 其实现代人类的祖先智人更重要的能力是“想象”和“虚构”。智人可以通过讲故事，团结更大规模的人数。而尼安德特人，虽然个体更强壮、智商也差不多（可能还要高一些），却只能组织几十人的组织，所以被智人干掉了。 会讲故事，变得越来越重要。孙中山长于演讲，梁启超精于写作。最后孙中山赢得了更多支持。 区块链技术的出现，将以数据为载体，将社会的信任成本降到最低。 数据不能脱离服务器，而服务器的私有属性本质上决定了数据的最终控制权将属于服务器的控制者，也决定了数据很难被自由地流动和迁移。服务器是私有的，所以互联网的现状就极像资本主义的本质，不可避免地将走向寡头垄断。 区块链作为历史上第一个真正的公有计算平台，有望实现数据、计算和存储的“共产主义”。]]></content>
      <categories>
        <category>书中所得</category>
        <category>商业之潮</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[6月写作素材本]]></title>
    <url>%2F2019%2F06%2F12%2F6%E6%9C%88%E5%86%99%E4%BD%9C%E7%B4%A0%E6%9D%90%E6%9C%AC%2F</url>
    <content type="text"><![CDATA[小学低年级时，班主任是个上了年纪的语文老师。印象里有很长一段时间，她每周末都会布置一个“素材积累”的作业，让我们在一个专门的“素材本”上面摘抄平时读到的好词、好句、好段。 距离上次写一个这样的“素材本”，真的很久了呢。 6月13日素材积累今天看到Caoz发了一篇“年薪100万”有关的文章，里面提到另外两位公号作者前两天都发了这个话题的文章，我顺藤摸瓜，发现了新大陆。 微信 | 高少星新解“一命二运三风水，四积阴德五读书” 基因&gt;时势/时运&gt;空间/环境&gt;社会关系&gt;学习 以上五点，概括了个人发展的主要影响因素，也是形成人与人差异的根本，并决定了其人生的上限与下限。 命影响最大但无法改变，可以做的是客观认知自己，而不是非理性的“人比人”，比上不足时自卑，比下有余时自负；运无法创造但可以顺势而为，借势而起，不要误把势的结果等同于个人实力而高估或贬低自己；人很难改变环境但可以选择环境，不断调整自己所处的环境让它更加有利于自己的成长和发挥，惯性的去妥协适应不适合自己的环境只会每况愈下；广交朋友并积累好的口碑能调动利用更丰富的资源，避免出现“一人有难，无人相助。”的窘迫情况；贯穿人生始终并对个人成长持续产生影响的是学习，在信息时代里更为明显。 理解了这些因素的影响后，人可以在思考和行动中作出选择，过的越来越好，或是越来越差。 读书是最划算的自我投资人和人的根本区别是什么？相信大部分人前两项的影响要素都差不多，从后几项开始，才产生根本的差距，而其中最核心的是认知。 认知包括两方面，一是观念，二是信息。 认知从何而来？找人聊、游天下、看电视、刷手机……这些都行，而其中最方便和最划算的，就是读书。有这么几点原因： 可以快速获取他人长期的、专业的知识经验，以及拓宽信息。我早年曾用了一周时间研究Windows注册表，然后我家隔壁小孩只听了我两小时的讲解就和我的收获一样，这样的学习多么经济高效。 门槛低。 非常便宜。 当然，读书也是有方法的： 筛书。要读好书和适合自己的书才有价值。看着书名差不多直接买都行，核心是一旦觉得不怎么合适，直接扔。（《暗时间》很强调） 速读和重读。就飞快粗糙的看，一本书差不多一两个小时就可以扫完。首先这种狗熊掰棒子的方式总比你不下手去掰要强，其次是如果这本书真的好，你可以再重新速读几次，以及局部去细读，做笔记什么的。 少就是多。读的多是为了筛出那少数好的的几本，然后把好的书重复看，往深看。你会发现其实100本书里，真的影响你的可能连10本都不到，每本里边可能就那么几句话最有价值。 独立思考。很有意思的是，不同的书和书之间的观点大多是矛盾的，或者书里所描述的东西和现实是有冲突的，如果不去思考，或者自己懵圈，或者人云亦云，那么就没法真正吸收，为己所用。（罗胖、熊逸也提到过） 努力真的比选择重要么？有条件的时候主动选择，没条件的时候先做好选择再去努力。没条件的时候努力，更像咸鱼只是反复翻身是没用的，你得朝水那边去翻。 我的所思所想可以归结成两个字：选择。 有些人问我为什么懂的东西那么多，好像花了很多时间看书啊。其实不然。（在《大学前3年的简短回忆》中就能看出，我习惯于处在舒适区，表现为：用玩游戏、看动漫对抗“无聊”感，附带产生了“焦虑”感，然后又用健身带来的“自律”感对抗焦虑。） 其实我是“挑选”的方法比较好。我挑的信息源（关注的自媒体、订阅的得到专栏）质量比较高，它们能够帮助我筛选好书。我的搜索能力也很强（相对普通人而言）。 所谓的阅读速度快，首先是指能快速识别出那些不值得阅读的书。其次，对大多数书都不强求看完，可以挑感兴趣章节看，甚至可以随机翻看。 雷军说：“专注，少就是多”。之所以速读、粗读，是为了把注意力（信息爆炸时代极为稀缺的资产）集中起来，专注到最有价值的地方。 人可以为一件事而忙碌，但不能让自己陷入一堆事情中忙乱。 日本在上世纪，由于出口低端商品经济腾飞，继而被美国打压了近40年。但是不论被怎么扰乱，日本始终锚定住自己的目标：实现产业升级。最后日本做到了。 产业升级，是日本认为最有价值的，是唯一目标。那么，我们怎么找到自己的目标，继而做到专注呢？ 我想，就跟读书一样，先有广度才能选择，选择后再去努力谋求深度。 普通的努力只能做到线性成长。因为思路没打开，只是机械地重复原有的“努力”，甚至不能称之为努力。而方向正确的努力，则可以做到指数级成长。 刘润介绍了用“系统动力学”的方法来打造自己的“系统”，其核心在于：找到影响结果的核心存量、关键因果链，最终认准自己的“增强飞轮”，坚持不懈地推动它（模型对了，才有战略定力）。（当然，我总结得不太好，系统动力学是一复杂的学科。） 6月12日素材积累简书 | 木李先生根植于内心，那无需提醒的自觉和高度的自律。 有竞争力的人，大多数都是靠内在驱动做事的。千百年来能成大事者，莫不如是。 或许我们每个人都会这样：每天因为别人的成就而抱怨，抱怨自己的出身，抱怨自己的愚钝但更应该抱怨的是自己的不努力。这个世界没有我们想象的那么好，但也没有那么坏。环境可能会对你产生影响，但那并不是你不努力的理由；即刻满足可能是人类的本性，但那并不是你不奋斗的借口。任何一个成功的人一定都是高度自律的人、一定是保持学习力的人、一定是注重健康的人。 其实大多数人只是看起来很努力，以大多数人的努力程度之低，根本轮不到拼天赋。（这句话，13年我在知乎上常常见到。） 捷径，才是最大的弯路。凡事都有方法，但一定没有捷径。成功的背后，一定是数不尽的汗水和泪水，而非几十天的“捷径”。 作家采铜在《精进》一书中提到：一个年轻人，进入一所不那么优秀的高校，对自己的标准会不自觉地降低以适应这个环境，减少自己与环境的冲突，这是非常致命的。 作家十二在《不畏将来，不念过去》一书中提到：一个人老去的标志，绝不是老成稳重、沉默寡言，而是不肯再尝试，不肯再容许自己置身不熟悉的境地。 B站 | 文明启示录#01人类天生对模因传播的狂热。 给岁月以文明，而不是给文明以岁月。敌人来了，而你，学会思考了吗？ 火器的出现对战争最大的推动其实是减少了人对于杀戮的排斥。当只有近距离才能感受到的杀人氛围被距离与精度取代，剩下的也只是一串冰冷的数字。 在这个诋毁造谣成本几乎为0的网络社会，隔着屏幕用言论去“杀死”一个人，甚至都没有心理负担。 我的所思所想 信息爆炸时代，搜索能力、独立思考、深度与专注思考的重要性。 专注下来，多读书、读好书——面试感想。 6月7日手机便签得到 | 刘润什么是资产？就是你所拥有的、可以帮助你自动获得回报、提高速度和效率的东西。 这就是所谓的「复利」，它可以帮助我们，从线性增长，转变为指数增长。 从「出卖时间」的思维方式，转变为「积累资产」的思维方式，是一个人职业生涯中极其重要的思维转变。 普通的人改变结果，优秀的人改变原因，顶级高手改变模型（系统）。 获得“麦克阿瑟天才奖”的系统动力学家德内拉·梅多斯，在她的成名作《增长的极限》里说：“真正深刻且不同寻常的洞察力，来自观察‘系统’如何决定自己的行为。” 到底什么是洞察力？所谓洞察力，就是透过表象，看清“系统”这个黑盒子里，要素以及它们之间连接关系的能力。 试着把时间投入长期、困难、不变的事情上，去关注「积累」和「趋势」，这些才是真正重要，有价值的事物。 我的联想 “代码复用”——本质也是创造资产 不写白菜代码——改变模型（系统） 微信 | L先生说遇到任何一个问题，我都不会急着去着手处理，而是会思考： 这个问题还会不会再次出现？ 我可以如何设计一套流程，或者优化环节、步骤，来避免它再次出现？ 比起着手去「救火」，这就是一种更长期的视角，也更加行之有效。 这一点，对于日常工作也是适用的。具体来说： 自动化：如果需要大量机械化步骤，能否搭建一个工作流（VBA、Python、宏等），实现自动化处理？ 模板化：如果需要频繁沟通、传递信息，能否制作一套模板，将信息结构化，最大限度避免遗漏和误解？ 流程化：如果一项工作的步骤非常繁琐，能否设计一套流程，降低注意力和认知资源的消耗？ 模块化：如果一项工作需要多种技能，能否创建一套模块，可以灵活搭配、自由组合？ 这些，都属于「系统」。一旦成功搭建，它就能自己运转起来，井井有条地将「输入」转换成有效的「输出」，为你节省时间、精力和注意力。 我的所思所想 创造，而不是解决问题。 大学时做过的、自认为最有意义的两件事，都是创造。健身不算，健身只是为了对抗焦虑。 得到 | 陈海贤可以把人生看成一个创造的过程，而不是解决问题的过程。这样的话，事实/现实就成了只是创造的“条件限制”，而不是自己的目标“是否成立”的前提，就更容易迈出那一步。创造才能带来持续的张力，而不是“问题”和“挫折”，因为创造会带来想要完成的冲动、 得到 | 吴军Google的每个员工每个季度都需要给自己定一个或者几个目标（Objectives），以及衡量目标是否达成的关键结果（Key Results），这几个词合在一起被称为“OKR”。 每个人的OKR会放到自己的网页上，大约半页纸长，大家都可以看到。如果谁没有制定OKR，一目了然，即使没有人催你，大家看到你的网页上面是一片空白，你自己都不好意思。到了季度结束时，每一个人会给自己的目标完成情况打分。完成了，得分是1。部分完成，得分是0到1之间一个数字。 5月5日手机便签得到 | 吴军如果把我们的时代放到历史的长河中，也不过是一瞬间而已。我们那一点点成就难道还值得沾沾自喜么？很多人讲自己多么忙、做的事情多么重要，以至于没有时间享受生活。但是如果静下心来仔细想想，果真如此么？ 大家平时可能都要用到微软的Office软件，这款软件使得我们的工作效率有了很大的提升。但是，在过去的十多年里，其实它没有什么变化。在微软内部，每年都有上千名工程师在改进它，每一个人讲起自己的事情都很重要，少了它似乎整个软件就不能用了。但是放在十几年的时间段里，那些工作便显得可有可无了。想通了这个道理，十多年后再回过头来看，我们就不会觉得自己是在原地打转了。成语“高瞻远瞩”其实就是要我们把目光放远点。 但是，并非什么东西都是越大越好。过分追求大，追求长远，可能一事无成。从细小的角度看大的东西是不可能全面的，但是，从大的角度看细小的东西也不可能真切。大和小虽有不同，却各有各的合宜之处。如何把握度，让它们相辅相成，则是艺术了。 得到 | 罗辑思维我们是要在承认自己认知有局限的前提下，更有效地行动。怎么行动呢？这个时候，意义就出场了。 意义不是别的，就是一个约定。因为有了这个约定，我们就可以开始行动。这就是意义的价值。]]></content>
      <categories>
        <category>跬步之积</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[写写2019年浙江高考作文]]></title>
    <url>%2F2019%2F06%2F07%2F%E5%86%99%E5%86%992019%E5%B9%B4%E6%B5%99%E6%B1%9F%E9%AB%98%E8%80%83%E4%BD%9C%E6%96%87%2F</url>
    <content type="text"><![CDATA[早年间有两位语文老师对我的影响很大，他们对我的文字那近乎崇拜的欣赏，让我对写作一直保持喜爱的态度。其中一位经常在我写完随堂作文之后，连看都不先看一遍，就当众朗读；另一位在我自己都觉得自己写得很烂的文字中，总能找出打高分的理由（还力排其他老师的非议），并在我的作文本上留下了数不清的“A+”。 被点燃的星星之火，不曾被往后的平庸和孤独所浇灭，一直延续至今。两年前开始，每到6月7日我都会写一篇当年的高考作文。 今年浙江作文题： 有一种观点认为：作家写作时心里要装着读者，多倾听读者的呼声。另一种看法是：作家写作时应该坚持自己的想法，不为读者所左右。 假如你是创造生活的“作家”，你的生活就成了一部“作品”，那么你将如何对待你的“读者”？根据材料写一篇文章，谈谈你的看法。 我在离金字塔三四百米的地方弯下腰，抓起一把沙子，默默地松手，让它撒落在稍远处，低声说： 我正在改变撒哈拉沙漠。 这件事微不足道，但是那些并不巧妙的话十分确切，我想我积一生的经验才能说出那句话。那一刻是我在埃及逗留期间最有意义的回忆之一。 我正在改变撒哈拉沙漠。 把人生看成一个“创造”的过程。这里的创造，不一定是具体的，可以视作“将自己心中的理念变为现实”的过程。 创造能带来持续的张力，因为它给人的是一种想要完成的冲动——不论是为了自己，还是为了观众。 自己的作品会不会有观众？有什么样的观众？很多时候，我们在创作时是无法预知的。只有一点是确定的，那就是自己。其实自己就是最不离不弃的观众。 马尔克斯在《百年孤独》中说：“作家行业是最孤独的行业。”作家想要成就伟大的作品，势必要独自一人走完漫长而又艰辛的旅程。 但是作为一个创作者，只要秉着“对自己负责”的态度，以追求完美的要求去进行创作，那么他的作品一定可以触及到人性最底层的什么东西。那样的作品足以打动其他人。 读村上春树的小说，可以感受到无处不在的孤独感。村上说：“人们总是进入自己一个人的世界，进得很深很深。而在进得最深的地方就会产生‘连带感’。就是说，在人人都是孤独的这一层面产生人人相连的‘连带感’。” 所以，对于优秀的作家，看似是“心里装着读者，多倾听读者的呼声”，其实莫如说是“深入挖掘自己的想法，越深越好”。 对于个人发展来说也是。 有时我们不必太在乎外界、不必急于推销自己。要专注于提升自己，相信：酒香不怕巷子深，时间自会做出评判。 但是也有一种情况，创作者会发觉自己与大众审美格格不入。 千年以来，著书立说向来是“文人”的事。在识字率低的农耕时代，写作是极少数精英与少数权贵的对话，写作者的姿态是自我陶醉式的，居庙堂之高而拒江湖之远。 而现如今，95%以上的识字率，让士大夫们的浅吟低唱变成了大众文学的“下里巴人”。是曲高和寡，做个偏居一隅的世外高人？还是曲意逢迎，成为哗众取宠的10万+作者？ 其实在我看来，两者都有存在的理由，兼而有之是为最佳选择。 一方面，站在历史这样的宏观层面审视文化，会发现大浪淘沙，所剩的必定是能代表人类智慧最高水平的作品；另一方面，大众文化虽然不登大雅之堂，却也是孕育新生事物的沃土——在士大夫们看来俗不可耐的东西，却能滋润无数弱小的幼苗，唤醒早已麻木的灵魂。 一个文化蓬勃发展的社会，就应该是雅俗共赏的。崇高的事要有人做，“文人们”看不起的事也要有人去做。 人生更是如此。 坚持自我是重要的，但更多时候，我们无法改变世界。我们只能顺应世界，做我们能做的事情，坚信它存在意义。 博尔赫斯说：“我写作，不是为了名声，也不是为了特定的读者，我写作是为了光阴流逝使我心安。” 越是通透的人，越明白个人对世界的意义微乎其微。但就是这个微弱的意义，能让某些人坚信“我正在改变XX”，并且长期为这个信念付诸行动，最终做出惊人的成就。 晚年的博尔赫斯来到撒哈拉沙漠，这时他已经双眼失明，他抓起一把沙子，把手移到不远处松开，说：我正在改变撒哈拉沙漠。]]></content>
      <categories>
        <category>扯淡杂文</category>
      </categories>
      <tags>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[创造：驱动人生的引擎]]></title>
    <url>%2F2019%2F05%2F25%2F%E5%88%9B%E9%80%A0%EF%BC%9A%E9%A9%B1%E5%8A%A8%E4%BA%BA%E7%94%9F%E7%9A%84%E5%BC%95%E6%93%8E%2F</url>
    <content type="text"><![CDATA[先聊几句写作写作是一个创作的过程，不过我的许多文章“创”的成分不高（所以不打“原创”标签）——文中思想多来自于平时听“得到”、看书时的零零碎碎的输入，我只是通过二次思考，加以整理，再按照自己理解系统地输出。这既可以向他人传递好的思想，对自己也有好处。 “一道传三友”[1]的故事说明：同一思想或道理，不同的人听到后的感悟是有些区别的。思想经过人与人之间的传递，会产生新的思想。 对于我来说，还是那句“学而不思则罔”——学得太多令人迷茫。接收输入过多，会失去意义，因为知识还来不及经过自己思考。我通过写作这种方式，倒逼自己思考。我发现，想把自己头脑中的东西写清楚确实很难，有时写一次还真像做头脑风暴，有如下图的场面： 丧：意义感缺失我的公众号文章《由自杀说起》中提到：人生本就是无意义的，现代哲学和科学都把人存在的意义解构了，但是人可以自己给自己的行为赋予意义，借之与荒诞的人生对抗。我还说有许多虚无主义者，他们在意义缺失的情况下，放弃了寻找意义，体现出浮躁和不安全感。 丧文化、废柴、毒鸡汤的流行，可以印证我的观点。包括我在内，应该有很多人陷入过这样一种循环： 颓废了一段时间，突然有一天十分焦虑，自我谴责之后，定下了满满的计划。 像打了鸡血，踌躇满志，一鼓作气地完成所有当天任务。 觉得有点累，没有完成当天的任务，感到了沮丧和挫折感。 开始拖延，被其他事情吸引，这天的任务几乎没有完成。 开始思考人生，思考这些无趣的任务有什么意义。 颓废，混吃等死。 怎样才能打破这种循环呢？ 陈海贤指出：不能把“问题”和“挫折”当成动力。这么做是不可持续的，因为在强化动力的同时，也强化了问题本身——人为了保留这种动力，不会让问题好转。这样只能变得越来越悲观。 创造：一种无限游戏陈海贤把生活的乐趣分为两种：消费型快乐和创造型快乐[2]。他认为，只有创造才能给人生带来持续的张力，而不是问题”和“挫折”。因为创造的本质是爱，对某种事物具有爱，才会有想要完成它的冲动。 这样说来，兴趣对人的推动作用[3]，一开始也是通过激发人的创造欲实现的。小学我和我弟喜欢看鸟山明的《龙珠》，于是开始编类似的漫画（把生活中的老师同学当成角色，可惜初一后画漫画被老师禁止）；看《灌篮高手》、《围棋少年》、《棋魂》，会抑制不住地想要打篮球和下棋；看《李小龙传奇》，健身会像打了鸡血……甚至我对编程的兴趣，一开始也是从魔兽争霸3的游戏地图制作中来的。 高自由度的游戏（像我曾提过的魔兽争霸3、模拟人生、我的世界）之所以能经久不衰，就是因为它们能激发人的创造欲。一旦创造这种行为被广泛激发，游戏社群便会诞生长久的活力，因为这时原来的有限游戏就变成了无限游戏[4]，它可以不断延续自己。 去年暑假我在找IT实习，投十多份简历而不中，便立了个目标：以后要树立创作意识，注意以丰富简历为目的的产出。这不是为了完成什么任务，只是为了把自己这方面的技能当成一个系统，不断去完善它——这不是有限游戏，而是无限游戏，是没有明确的边界的。 虽然生命是有尽头的，但我们应该把人生也当成无限游戏，当成无数个有限游戏的和。无限性，有助于我们培养成长型的思维；而游戏人生是指，即使看穿了生活的虚伪面目，也要把它当做游戏一样认真对待，认可游戏的规则，发现游戏的有趣之处[5]。 人生这条河河水想要流动，必须满足三个条件（人生的驱动与之类似）： 高低落差——带来势能和张力——人生目标 河道——让张力变成行动力的方法 源头活水——与现实的接触 以创造为目标陈海贤认为，我们要把人生看做一个创造的过程，一个把我们心中的理念变为现实的过程，而不是解决问题的过程。因为只有创造（怀有爱）才能带来持续的张力，而不是带来“问题”和“挫折”。 从张力到行动力想要实现自己的创造，就要正视现实。我之前介绍过《WOOP思维心理学》，介绍过心理比对、执行意图。这种方法可以帮助我们理性看待愿望（wish），反思目标（Outcome），找出障碍（Obstacle），合理计划（Plan）。 我们的愿望不能不切实际，有一条原则：控制你能控制的事情，不要妄图控制无法控制的事情。把事情中可控的部分找出来，做成计划，保持“有事可做”，不怨天尤人，但又要顺其自然。 接触现实，专注当下某种意义上，僵固思维、应该思维、绝对化思维，都是“远”的思维方式。它们帮助我们节省认知成本，让我们面对不确定的世界时，有了更多的确定性。但是同时，也让我们丢失了很多真实、细节的东西。 与之相反，“近”的思维方式强调关注真实的、当下的事情。走近现实，与现实（源头活水）接触，虽然可能被细节淹没，但有利于我们不断改变自己的思维，让思维富有弹性。近的思维有3条原则： 用描述性语言，而非评价性； 问具体问题，而非抽象问题； 关注现在能做的事，而非事情的结果“有用没用”。 近的思维可以帮助人避免焦虑、立刻行动。当因为忧虑而犹豫不决时，可以问自己两个问题：我现在能做什么？我愿不愿意去做？ 补充/说明/加餐：[1]至少有有三个版本的“一道传三友”： 封神演义中，鸿钧道人传道术给三个徒弟，道德天尊（老子）、元始天尊、灵宝天尊（通天教主）； 金庸武侠中，觉远大师临死前口述九阳真经，张三丰、郭襄、无色禅师听后，各自得到不同武学体悟； 《六神磊磊读唐诗》讲：唐诗宗师杜甫的绝学，韩愈得“骨”、白居易得“真”、李商隐得“情”。 [2]消费型快乐里，你消费的是别人创造的产品，满足的是表面上的感官刺激；创造型快乐里，你在创造自己的产品，你在发挥自己的才能，辛苦地工作，体会到一种深刻的成就感、一种自己正在变得更好的感觉。 明明我们知道创造型快乐更好，却为什么不能从事创造型快乐呢？原因是：创造型快乐是骑象人所热衷的、理智的快乐；而消费型快乐是大象所热衷的、感官的快乐。 [3]“晴妈说”《动漫游戏互联网，如何让孩子面对》中，郝景芳写了自己小时候是如何受兴趣影响的。 [4]无限游戏：以延续为目的的游戏。它突破了有限游戏的3种边界——消除了时空边界、人员边界，并通过不停更改规则，扩充了规则边界。聊天就是无限游戏，它应该让话题不断延续下去；而辩论是有限游戏。概念来源于《有限与无限的游戏》。 [5]何帆谈读《江湖外史》的感悟链接]]></content>
      <categories>
        <category>扯淡杂文</category>
      </categories>
      <tags>
        <tag>写作</tag>
        <tag>学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[跟着何帆读王怜花《江湖外史》之笔记]]></title>
    <url>%2F2019%2F05%2F25%2F%E8%B7%9F%E7%9D%80%E4%BD%95%E5%B8%86%E8%AF%BB%E7%8E%8B%E6%80%9C%E8%8A%B1%E3%80%8A%E6%B1%9F%E6%B9%96%E5%A4%96%E5%8F%B2%E3%80%8B%E4%B9%8B%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[从江湖中品味真正的人生我是比较喜欢读小说的，尤其是金庸的武侠——既能被它生动的情节所吸引，又能在掩卷之后思考，回味无穷。 在微信大V中，六神磊磊就是靠读金庸出名的，我评价他的风格是诙谐机智接地气，当然格调也够高；另外一本书《江湖外史》也是借评论金庸（还有古龙）小说中的人物说人情世故的，虽然也处处透射出生活智慧，但语言的质感很不同，整体保持洒脱之感。 何帆在教思考人生道路问题的几节课中，讲了许多自己读《江湖外史》的感悟。为什么思考人生会涉及到武侠呢？因为人生道路是一个复杂命题，人生感悟是一种“当地”知识（在特定时间、特定地点和特定的一群人共同分享的人生经验）。 而在金古的江湖中，有无数的人，贡献着无数种活着的方式。 何帆自己的高浓度总结五节课分别讲了五位江湖人物，每个人物都代表了一个人生道理，教我们如何面对生活。 第一位是扫地僧。扫地僧可能是人生的最高境界，这是一种无为的求道、无名的存在。想要达到这样的境界，需要智慧，更需要胆量。无论何时，你的心中都应该有个扫地僧，虽不能至，心向往之。扫地僧教我们更多地关注自己的内心世界。如果你肯回过头，省察自己的内心，就能看到一个更为广阔的、只属于你的世界。 第二位是韦小宝，人生的次优选择。韦小宝虽然不够高尚，但他是真实的。靠着本能求得生存、直面人生真相的韦小宝，是知识分子的解毒剂——太多的知识分子过于虚伪、过于矫情；韦小宝又是一个有趣、有灵性、有禅悟的人——他知道底线是不可碰触的，当面临人生的两难选择时，还有第三条道路：“大不了，老子不干了”。 第三位是虚竹。虚竹的故事告诉我们：悲欣交集的人生才是真实的人生——既然生活是不可抗拒的，你的出身、你的天赋、你所处的时代，很多很多因素都不是你自己能够决定的，那么，我们就只能顺应生活。有一种境界叫才高于志、土木形骸，说白了，你要学会做减法。如果你知道自己真正想要什么，又知道其实自己想要的不多，那就能得到幸福。不妨换一种心态，像孩子们玩游戏一样，既投入又超脱地对待生活。 第四位是令狐冲。令狐冲告诉我们：想要过一种特立独行的生活，就必须内心里有一个强大的自我。从表面上看，令狐冲过得自由、随意，但自由是要付出代价的——自由、随意的令狐冲虽然与世无争，但主流社会一定会视其为异端。如果你想过一种像令狐冲一样的生活，一定要清楚你的内心是否足够强大。为了适应可能出现的风险，你应该从现在就锻炼自己的“旷野”生存能力。 第五位是赵敏。赵敏告诉我们，成熟的爱情是要用自己的“强”去爱，而不是用“弱”去爱。不要让爱情蒙蔽了眼睛，在爱情中失去自我，要学会在爱情中成长、发现自我。成熟的爱情不在于融为一体，而在于保持距离。爱情其实是我们自己的事情，跟我们所爱的人无关。伟大的爱情并不是因为仅仅有爱情，相反，是因为人们在爱情之中能够学会包容、学会理解、学会忍耐，学会成长。 《江湖外史》原文摘抄（更新中） 这个无名老僧的智慧，胸襟，见识，修为，无为的求道，无名的存在，是金庸所要表现的最高境界。求道修远，不是仅仅为了生存，也不仅仅是为了荣耀，而是寻求一种的更高更远的精神。 就像那无名老僧，即便出任少林方丈甚或武林盟主（他完全有这能力），他也不会和扫地时有本质的区别。我必须说，人和人是不同的。如何让道路遇合自己的天性和心灵的要求，是一种大智慧。十丈红尘，功名利禄，经常使我们像萧远山和慕容博那样，买椟还珠。 古龙和金庸，给我们留下了许多难忘的人物形像。但若论人性的真实，韦小宝当是古金第一人。他的贪婪，狡诈，自私，无耻，是我们生而为人所固有的；他所做的那些奴颜婢膝，曲意逢迎，见风使舵，欺软怕硬的事，是我们常常要做的；而他的强颜欢笑和身不由己，更是我们几十年如一日的真实境遇。我猜想，金庸以韦小宝来金盆洗手，是经过深思熟虑的。他想说的是，虽然他知道理想人格应该是什么样的，但因为已洞悉人性和历史的奥秘，因此决定向这奥秘低头——但这不是失败的低头，而是那种如流水般随物赋形的低头。所以，在《鹿鼎记》中，气宇轩昂出类拔萃如陈近南，雄才大略文治武功如康熙，都不如萎琐又无知的韦小宝那样左右逢源如鱼得水。这不是金庸写郭靖和石破天时那种简单的反智倾向，而是读通历史和人生后的庖丁解牛。最后，当韦小宝身处不可调和的两难境地时，他想通了一个惟一的破解之道：“老子不干了。” 当此时，谁能料到他将有怎样的命运呢，谁能料到他竟是一代高僧玄慈和四大恶人叶二娘的私生子呢。当他们终于相认时，全书的高潮出现，那是摄人心魄的悲剧，有着原罪和挣扎，大欢喜和大灭寂。每次重读，都令我悲从中来，又觉人之勇敢。这是金庸宏伟构思的经典时刻，是金庸最大胆的想象，最缜密的思虑和最深情的书写。佛说生老病死四谛皆苦，然而金庸的虚竹说，虽然如此，生活本身依然是不可抗拒的；命运是可以有奇迹的。否则我们存在的理由本身将不复存在。虚竹的生，当然是苦，但生命的过程是真实的，而生命自有欢愉，有时甚或浪漫，谁又能料到梦姑“酒罢问君三语”所要问的“梦郎”就是那虚竹呢。身世虽然悲惨，但却真实；虽有苦痛，但是，在学习怎样死亡之前必须先学习怎样生活。一个人的一生自有命定的历程。如弘一法师，倘若没有先前的李叔同，何来后来的高僧弘一呢。悲欣交集，不错，悲欣交集才是完整的人生。在《天龙八部》的所有人物中，金庸给虚竹安排的是最好的结局。这是耐人寻味的。顺从命运的安排，在不由自主的破戒中坚守；接受命运的馈赠，在无可奈何的现实中承担——这是虚竹活着的方式。 刘伶最高妙的地方是他虽然才高八斗，却“未尝措意文章，终其世，凡著《酒德颂》一篇而已。”这是他胜过“竹林七贤”中另外几位的地方。他所处的那个时代已经窥见“唯有文章才能不朽”这一奥秘，以他之才，却“未尝措意文章”，一辈子只写了一篇《酒德颂》，呵呵，那是不求不朽的智慧和境界了。 在真实的刘伶或者虚构的莫大这样的人物身上，我印证了我对生活的一个朴素的见解——幸福就是做一个不求进取的天才，胡乱快活一世。这和巴博士（巴曙松）所说的“才高于志，土木形骸”应该是一个意思。如果你知道自己真正想要什么，又知道自己想要的不多，那就能得到幸福。 备忘（记录一些有用的话）才高于志、土木形骸，这都是做减法的人生。当然了，更高的境界是既能做加法，又能做减法，该做加法的时候做加法，该做减法的时候做减法，那么，我们又怎样才能做到这一点呢？ 有一个方法，就是用做游戏的态度去度过你的一生。当我们平常讲游戏人生的时候，我们其实误读了游戏，也误读了人生。 请你不妨想象一下在玩过家家游戏的孩子。孩子在做游戏的时候是非常认真，非常投入的。他们是用自己的全心去感受，去融入。可是，他们知道自己是在做游戏。当他们给布娃娃打针的时候，难道不知道布娃娃根本感觉不到疼？当他们拿玩具枪玩射击游戏的时候，难道他们不知道玩具枪里装的根本就不是弹药？ 孩子们都知道，去关心游戏的真假是没有意义的，真正有意义的是游戏好玩不好玩。所谓的游戏人生，在我的理解，就是像孩子们玩游戏一样去体验人生，很多时候，成年人干的事情也跟孩子一样，就是个游戏，看穿了都是虚假的，但这不重要，重要的是你认可不认可游戏的规则，你是不是觉得这种游戏有意思，你真正追求的东西并不在游戏里面，而在游戏之外，你要想清楚，那个在游戏之外的东西究竟是什么。]]></content>
      <categories>
        <category>书中所得</category>
      </categories>
      <tags>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[大学前三年的简短回忆]]></title>
    <url>%2F2019%2F05%2F22%2F%E5%A4%A7%E5%AD%A6%E5%89%8D%E4%B8%89%E5%B9%B4%E7%9A%84%E7%AE%80%E7%9F%AD%E5%9B%9E%E5%BF%86%2F</url>
    <content type="text"><![CDATA[（2016年8月31日，本文首发于百度贴吧江南大学吧） 1看到好多新生来到了学校，不由想起了三年前我初入校园时的那种兴奋的心情。 当时我还是一个非常有梦想有激情的热血青年，对于以后的生活寄予着美好的希望。 然而不知不觉中，时间飞逝，随之飞逝的还有我的梦想和智商。 比如，以前高中45分钟可以写一篇作文，现在想写点东西，可就是憋不出几个字来。最近写的读后感才几千字，硬是花了我两天时间来写，还零零碎碎的。 为了不让今天那些和以前的我一样兴奋着的学弟学妹们步我的后尘，我决定挖一个坑来回忆自己的大学生活，持续更新，留作前车之鉴。 2我的故事也要从贴吧讲起。 关注江大吧是得知自己录取之后的事情。 那个暑假我一直在酒店打工，晚上10点下班，回家就累成狗，也没怎么水贴和水群。 不过贴吧里面内容丰富，只要检索能力强、时间多，可以发掘很多有用的内容。 比如还没到学校，我就知道了学校各方面的情况。 后来报道那天，我独自一人背了一箱子东西就去了。5小时后，到达无锡站。随着人流，被热情的学长们引领送到了学校。 箱子的密度和体积都很大，还好我的力气也还可以，往头上一举就冲到了5楼。 打扫自己的位置时，来了个学姐帮我办理充值移动话费的活动。 期间还夸我一个人来学校报到，自理能力不错… 室友在一旁看我打扫得很认真，问我是不是有洁癖。 后来他们才发现正好相反… 3开学那阵子，我tm非常想改变自己内向的性格。 可惜有些东西太难改了，结果给同班同学留下很逗比的形象。 副班说我擅长肢体语言和冷笑话…其实都是被逼的呀～和好多人在一起的情况太难应付了orz 大一也一直努力想变得外向，so各种社团面试，无一例外都被刷。 后来加入了一个缺人干事情的社团，部长见我画画不错，让我做美编，给报纸排版。于是自学InDesign，于是熬夜赶进度，结果做的都是无用功…印刷问题导致出的第一期报纸惨不忍睹… 到后来社团解散了。我成为了一个无组织人士。 结果证明我还是适合一个人呆着，做自己喜欢的事情。 以至于后来形象变得特别高冷… 大一上，是被各种事务推着走的。 参加迎新晚会的排练占据了大一上的大部分课余时间。后来想想，意义不大，并没有太强的荣誉感幸福感… 最开心的事情是新生运动会拿了两个个人奖，还有什么体能明星大赛也得了第二。另外计算机二级证上得了优秀。还有就是综测第三拿了一小笔奖学金… 不过后来就堕落了。 4迎新晚会之后，各种事情都少了。 于是刷知乎，看电子书，看电影，看各种微信文章，看了施瓦辛格健身全书，混健美吧。 其实看动漫更有趣，大一大二狂补各种从后宫动漫吧、黑暗动漫吧看来的“经典”。 后来发现打游戏也很有趣。 dota天梯排位，联机打war3，玩300英雄，玩英魂之刃，LOL…没说全，反正就是把MOBA游戏玩了个遍。 其实高中一直玩真三，也是MOBA，只不过大学没人玩了，我就跟风玩其他的。 健身也断断续续，经常因为打游戏而忘了练。 为了排解无所事事带来的焦虑感，我大学时建立了一项持续的爱好——健身。 大一我在寝室玩哑铃，卧推、飞鸟、弯举、上举…晚自习结束，就到操场练单双杠。最后体育课双杠42个，期末97分。 大二练习长跑，参加了24公里越野，路上风景都没心情看，快到终点时迷了路，后来人简直废了。特么一个同学都没跟我来看比赛，早上都在睡懒觉，白天也不愿出门。 大二的体育选了健美课，水的很。在同学们力量普遍很弱的情况下，突出了我的强，于是期末得了100。 期间周末做兼职持续了很长一段时间。大一下和大二上基本就这么过去了。 基本遵循疗养院的生活模式，状态极安逸，简直消磨意志。 5大二下的时候我决心改变一下状态。 当时我的想法是毕业后直接工作，熟悉了行业状况再考虑下一步。但是觉得自己这闷骚性格直接去工作肯定混不开，所以想要去社会上历练历练。 其实之前就做了几个月时间双休日的兼职，就是类似迎宾站岗。不过到大二下，五一节前夕，老板突然不让干了。 五一，我信了赶集网，骑车去市中心，一个小写字楼那里应聘，果断被坑了几百块钱。去派出所好像也没用，我又怕麻烦，心想不就半个月生活费？赚回来就是了。 后来的5、6、7月，简直辛苦。 我在星光广场那边的小饭店洗碗，碗根本洗不完，以至于一天工作6到7小时。 同时我还趁没课的时候去南门外4公里的仙河苑健身，来回骑车半小时，就因为那里便宜。 那阵子是期末，有小组大作业，我们小组就我肯干点事情。那个星期，天天兼职回来搞到凌晨三点，终于把论文翻译、人工神经网络、模糊逻辑都弄懂了大概。后来课上展示，我整整讲了两节课，板书打了两个黑板。 可是心力交瘁，洗碗的时候头痛得不行。 我提出辞职，老板竭力挽留。我猜他没见过这么肯卖力干活的大学生。可能因为我洗碗的效率确实不高，厨师还常使唤我洗东西，确实很累。 老板娘给了我头痛药，老板和我说好，会找一个轮班的，以后我只要两天干一次。 又脏又累的工作，很难找到肯干的人。 找了一个多星期，换了两三个人，终于出现一个对面职院的哥们帮我分担任务。 6月份就轻松多了。 暑假，我大二升大三，想提前实习，看看情况，以决定以后那个暑假是否考研。 7月，跟随纺织的学长学姐，我在工厂包装部门干了一个月苦力。我也没要工资，毕竟提供实习的岗位给我已经不易。至少我了解了生产部门的各种管理体制，还再度体验了一把劳动人民是如何被剥削的。 8月，我前往深圳的一个小服装工作室，实习设计师助理。这次由于是托关系安排的，十分轻松。不过让我认识到了书本上的知识实在太局限太无用（主要是我这个专业），跟我一个职位的都是高中毕业生。我对本专业彻底失望。 6是痛苦，而不是欢乐，塑造了人。感受到自身没有价值的痛苦，让我觉得不能让我的大学白读了。 我反思了大学的意义。 给我们机会试错，其实这是最重要的意义。 大三，一方面我再也不去想兼职的事情，另一方面我开始对自我的剖析——到底什么适合我？ 上半学期我还是一度玩游戏玩到断网为止，不过每次都会自责。 健身，仍然是我绵延不断的习惯。 后来，图书馆成了我最常去的地方。我发现那里的书，让贪婪的我恨不得全部收入脑海。 科学——社会科学，自然科学，科学之科学（哲学），各方面，各分支都应当有所涉猎。 当时我主要找我感兴趣的计算机方面的书来看。 后来，政经史哲心理学，它们的乐趣也吸引了我。 我通过心理测试认识自己。我透过INTJ的模型、霍兰德职业测试等，帮助自己分析未来规划。 我平时关注时事、政治、经济，分析趋势，确定目标。 （↑当时一个和我与枫胸一起开黑的妹子的吐槽） 现在想起来，大三上好像花了很多时间玩手机…只不过换到了在图书馆玩手机。 那个寒假本来计划好好复习英语和微积分，还要看看课外书。为防荒废，没带电脑回家。 结果回家之后，去网上买了台新电脑…然后又捣鼓起刀塔2地图作坊，鬼泣等等… 寒假过去了。 4月之后，我才偶尔想起自己很早定下来的宏伟计划，开始有一搭没一搭地复习英语和高数。 很多时候我都一个人默默呆在教室或图书馆，即使没有看书，也比呆在寝室好一些。 英语荒废了2年半，六级一直没过。阅读做起来极其吃力，还犯困。 好歹在大三下把六级过了，此时距离我上次考证（计算机三级，也是优秀，大一升大二的暑假我除了学车就是在自学计算机网络这方面）已经一年半有余。 基本一直保持最早到教室看会书或者玩会手机的习惯… 然后大三很快过去了。 这个暑假，没有回家，为的是不在琐事上花费精力。其实希望自己能机械地复习、锻炼，直到开学的，可事实上还是浪费了大约一半时间。 然后就到了现在… 插： 我是大三之后才知道，我们学校的理学院会专门培训数学建模的课程。可以参加比赛。 可惜大三下才选了数学建模公选课。然后去看这方面的书。总的来说我很喜欢，这是结合实际问题、计算机算法、数学模型的东西，非常有实际应用价值。我听说了暑假培训，遗憾没时间参加了。 要是大二早点关注些现实生活中的问题就好了。 大二上我选的课是单片机原理，也看了网上有关的教程自学，不过后来都没坚持下去… 其实坚持，最好有一个明显的目的，再加上外界驱动力（比如老师，比如同侪压力），然后激发情感，才得以持之以恒。 7（2016年9月5日） 大四狗的第一天。 6点15起床，6点45到了纺院的教室。 还是坐最角落，和周围的人保持疏离感。 教室很闷，很乱。我开了窗，移了移桌子凳子。 第二个人7点05到了，是我室友，昨天一夜未归。 “好早啊～”他一边说着一边在我前两个位置坐下。 而我依旧看着书。 他站了起来，去前面开了空调，却不关窗。 有种想去把空调关了的冲动。不过还是默默地看书。 此身有限，吾生有涯，以有形有限之生投入天下，面对无限的时空、知识、意义、价值，这一“无限”令我不安。 现实生活中人受到是非之辨、贵贱升降、生死祸福等因素的困扰，受到各种物质条件的限制，有所依赖，有所期待，有所追求，这才造成了人们的痛苦、不自由。 （原帖只写到这一天，后文是过了将近3年，我偶尔翻到以前的这篇文章，所做的补充。） 8后来的大四发生了很多事。 我参加17年的考研，初试401分，然而我的志愿不过是区区北京服装学院的服工计算机方向，270分就足够了。“这大概就是才高于志、淡泊名利吧”，我想。 毕业答辩上，我用电脑合成语音代替自己讲话，并且演示了使用ruby编写脚本、RPGMaker作为框架的 流水线生产模拟系统，还说自己只用了1个月……在座老师无不震惊，甚至没等我把ppt放完就发出一连串问题，而以我的口舌根本解释不清。他们一定在想“这孩子真怪”。 听闻人的记忆只有7秒，犯过的错会一犯再犯。 真的有道理。 因为现在看来，16年的我早已看穿了一切，但后来的我依然在犹豫、仿徨和不安中消磨自己宝贵的时间。 补充资料：17年4月份，毕业前2个月我发的一个日常记录贴]]></content>
      <categories>
        <category>岁月如歌</category>
      </categories>
      <tags>
        <tag>生活</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用GitHub和Hexo免费搭建个人博客]]></title>
    <url>%2F2019%2F05%2F16%2F%E5%88%A9%E7%94%A8GitHub%E5%92%8CHexo%E5%85%8D%E8%B4%B9%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[1. 使用GitHubGitHub可以简单看成是一个存放文件（主要是源代码文件）的云端仓库，它的核心功能是基于Git进行开发项目的版本管理，它允许你和你的团队随时随地 从仓库拉取、或者向仓库上传 代码文件。 1.1. 注册GitHub账号登录GitHub网址进行在线注册。（注册时，图片验证码可能要翻墙才能获取） 1.2. 创建GitHub PagesGithub Pages是GitHub的公共静态页面搭建托管服务。有了它，静态网站可以被免费托管在Github上。 你可以选择使用Github Pages默认提供的域名github.io或者自定义域名来发布站点。比如我的就是wushuangabao.github.io。 如何创建？参考 GitHub Pages也是基于一个GitHub文件仓库，这个仓库里的文件可以随意新建、修改和删除。仓库中名为index.html的文件会作为自己站点的首页，也就是说只要懂得HTML语法，就能编写属于自己的页面了。 1.3. GitHub Desktop习惯于使用Windows操作系统的用户，像我，一般是不习惯使用命令行来操作Git的，那就推荐下载GitHub Desktop工具。用它点点鼠标就可以完成代码的上传（push）和拉取（pull）。 2. 使用Hexo其实有了GitHub Pages，再手写网页文件，自己的网页就能够被人们访问了，那为什么还要用Hexo呢？ 因为Hexo可以提供博客（blog）的模板，以后发表一篇博客只须创建一个Markdown文本文件，就可以用Hexo构建整个网站（博客型的）。 2.1. 安装Hexo装Hexo前提是要有node.js和Git环境，没有的话自行安装。（Git貌似也是使用GitHub应该具备的环境。） 然后根据Hexo官方文档进行安装即可。 2.2. 部署博客根据文档提供的指令，我们可以通过Windows命令行（cmd）操作Hexo。反正有文档，如何写作、生成、部署、换主题，我就不写了。 2.3. Hexo-Client不过还是觉得用命令行太麻烦，我搜了一下GitHub，果然找到了一款用Electron写的Windows桌面工具，叫Hexo-Client。下载exe文件，安装。 依照Hexo-Client作者写的帮助文档（这文档本身就属于一个GitHub Pages + Hexo构建的博客）配置完毕，以后发布博客就用它了。 3. 使用七牛云由于MarkDown文件里插入图片用的是图片的URL链接，所以我们创建的这个博客需要有配套的云图片库。 而七牛云为个人用户提供免费的10G云空间，当然也可以作为图片库，参考这里。（之前我是把GitHub Pages作为云图片库，然而现在改成Hexo构建博客，原来的图片不能继续放着了。） 4. 更换成NexT主题Hexo生成的博客，默认的主题风格不好看怎么办？ 我们可以换，也可以自己写自定义风格。据说用得最多的主题是NexT，可以尝试换一下。 Hexo及其主题介绍，别人写的个人博客之旅 简述上的，NexT主题的常用配置参考]]></content>
      <categories>
        <category>奇技淫巧</category>
      </categories>
      <tags>
        <tag>技巧</tag>
      </tags>
  </entry>
</search>

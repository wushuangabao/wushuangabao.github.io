# 【学习】许世伟的架构课（极客时间）（二）
```
tags:
  - 学习
  - 软件
categories:
  - 软件工程

date: 2020-09-23 15:47:09
```

以前的同系列文章：[许世伟的架构课（一）](https://wushuangabao.github.io/hexo/2019/06/17/%E3%80%90%E5%AD%A6%E4%B9%A0%E3%80%91%E8%AE%B8%E4%B8%96%E4%BC%9F%E7%9A%84%E6%9E%B6%E6%9E%84%E8%AF%BE%EF%BC%88%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4%EF%BC%89/)


## 11多任务：进程、线程、协程

### 实现多任务

物理层面的多任务，有两个方法：一个是多颗 CPU，一个是单颗 CPU 多个核心。

在桌面端，大多数情况用的是后者，因为桌面端的产品（个人计算机、手机、手表等）还是很在意产品的体积如何尽可能做得更小；
而服务器领域，通常同时使用两者，它更多关注的是如何尽可能提升单台计算机的计算力密度。

如果我们实际就只有**一个单核的 CPU** 呢？

把 CPU 的时间切成一段段**时间片**，每个时间片只运行某一个软件。这个时间片给软件 A，下一个时间片给软件 B。因为时间片很小，我们会感觉这些软件同时都在运行。这种分时间片实现的多任务系统，我们把它叫**分时系统**。

原理：把当前任务状态先保存起来，把另一个任务的状态恢复，并把执行权交给它。

这里面涉及的问题有：
- 任务是什么，怎么抽象任务这样一个概念；
- 任务的状态都有什么？怎么保存与恢复；
- 什么时机会发生任务切换？

### 执行体

**任务的抽象（“执行体”）**并不是唯一的。大部分操作系统提供了两套：进程和线程。有的操作系统还会提供第三套叫协程（也叫纤程）。

执行体，是指**可被 CPU 赋予执行权的对象**，它至少包含下一个**执行位置**（获得执行权后会从这里开始执行）以及其他的**运行状态**。

任务的状态（执行体的上下文）包括：
- 寄存器，通过名字来存取；
- 内存（RAM），实模式下多个执行体之间无干扰，保护模式下通过**切换地址映射表**来切换状态，而切换地址映射表也通过寄存器。

总结：执行体的上下文，就是一堆寄存器的值。要切换执行体，只需要保存和恢复一堆寄存器的值即可。

### 进程与线程

|执行体|地址空间|调度方|时间片调度|主动调度|
|-|-|-|-|-|
|进程|不同执行体有不同地址空间|操作系统内核|基于时钟中断|系统调用（syscall）|
|线程|不同执行体共享地址空间|操作系统内核|基于时钟中断|系统调用（syscall）|
|协程|不同执行体共享地址空间|用户态|一般不支持|包装系统调用|

进程是操作系统从安全角度来说的隔离单位，不同进程之间基于最低授权的原则。

线程的出现，则是因为操作系统发现同一个软件内还是会有多任务的需求，这些任务处在相同的地址空间，彼此之间相互可以信任。

### 协程与goroutine

#### 解决的需求

协程是在用户态下实现的，它的出现是**实现高性能的网络服务器**的需要。

- 对网络服务器来说，大量的来自客户端的请求包和服务器的返回包，都是网络 IO；
- 在响应请求的过程中，往往需要访问存储来保存和读取自身的状态，这也涉及本地或网络 IO。

为了改进网络服务器的吞吐能力，主流的做法是用 epoll（Linux）或 IOCP（Windows）机制。这两个机制颇为类似，都是在需要 IO 时登记一个 IO 请求，然后统一在某个线程查询谁的 IO 先完成了，谁先完成了就让谁处理（[epoll机制参考](https://blog.csdn.net/weixin_34015336/article/details/85124052?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param)）。从系统调用次数的角度，epoll 或 IOCP 都是产生了更多次数的系统调用。从内存拷贝来说也没有减少。所以使用它们真正有意义的事情是：减少了线程的数量。

这样网络服务器就只能用异步 IO 来写程序。它让程序逻辑碎片化，很反人类。

> 知名的异步 IO 网络库 libevent 就是对 epoll 和 IOCP 这些机制包装了一套跨平台的异步 IO 编程模型。
> Node.js 一炮而红，也是因为把 JavaScript 的低门槛和 libevent 的高性能结合起来，给了前端程序员一个“我也能搞高性能服务器”的梦想。

为什么希望减少线程数量？
- 空间成本是第一根稻草。默认情况下 Linux 线程在数 MB 左右，其中最大的成本是堆栈；
- 执行体的调度开销，以及执行体之间的同步与互斥成本，也是不可忽略的（时间）成本。

综上，协程的目的是：
- 回归到同步 IO 的编程模式；
- 降低执行体的空间的空间成本和时间成本。

#### 如何解决？

大部分协程库，连协程的基础功能也是半吊子的。这里面最难搞的是堆栈。

协程的堆栈如果太小则可能不够用；如果太大则空间成本过高，影响能够处理的网络请求的并发数。理想情况下，堆栈大小需要能够自动适应需要。

一个完备的协程库可以理解为用户态的操作系统。

完备的协程库：Erlang 和 Go 语言。

Go 语言里的 goroutine 有这样一些重要设计：
- 堆栈开始很小（只有 4K），但可按需自动增长；
- 坚决干掉了 “线程局部存储（TLS）” 特性的支持，让执行体更加精简；
- 提供了同步、互斥和其他常规执行体间的通讯手段，提供了几乎所有重要的系统调用（尤其是 IO 请求）的包装。

### 架构师的批判性思维

执行体的设计，有非常多值得反思的地方。

操作系统内核之中，不乏无数精妙的设计思想。但是，前辈们也并非圣贤，也可能会出现一些决策上失误，留下了诸多后遗症。

作为后辈的我们，在体会这些精妙的设计思想的同时，也要批判性去吸收。

## 12进程内协同：同步、互斥与通信

进程内的执行体有两类：用户态的协程（以 Go 语言的 goroutine 为代表）、操作系统的线程。这两类执行体的协同机制概要：

|类别|goroutine|线程|语义|
|-|-|-|-|
|原子操作|atomic.AddInt32/AddInt64|atomic.AddInt32/AddInt64|val += delta; return val|
|原子操作|atomic.SwapInt32/SwapInt64|atomic.SwapInt32/SwapInt64|oldval, val = val, newval; return oldval|
|原子操作|atomic.CompareAndSwapInt32|atomic.CompareAndSwapInt64|if val == oldval {val = newval}|
|互斥体|sync.Mutex|pthread_mutex_t|锁：用于多个执行体互斥访问，避免多个执行体同时操作一组数据产生竞争。|
|互斥体|sync.RWMutex|pthread_rwlock_t|读写锁：锁在读多写少情况下的优化。把操作分为读操作和写操作。|
|等待组|sync.WaitGroup| |同步：等待一组在做不同任务的执行体的任务全部结束。|
|条件变量|sync.Cond|pthread_cond_t|同步：在锁保护下，如果资源不足则等待，否则对该资源执行某种操作。|
|管道|io.Pipe|pipe|执行体之间收发无类型的二进制消息。|
|消息传递|channel|缺失|执行体之间收发类型安全的消息。|

### 原子操作

原子操作是CPU提供的能力，和操作系统无关。这里列上只是为了让你看到进程内通讯的全貌。

原子操作的每一个操作都不会被人中途打断，这个原子性是CPU保证的。

从语义上来说，原子操作可以用互斥体实现，只不过原子操作要快得多。例如：
```
var val int32
...
newval = atomic.AddInt32(&val, delta)
```
等价于：
```
var val int32
var mutex sync.Mutex
...
mutex.Lock()
val += delta
newval = val
mutex.Unlock()
```

### 执行体的互斥

互斥体也叫锁，用于多个执行体之间的互斥访问。

锁的使用范式比较简单：在操作需要互斥的数据前，先调用 Lock，操作完成后就调用 Unlock。

> 锁会导致代码串行执行，所以在某段代码并发度非常高的情况下，串行执行会导致性能显著降低。但相比其他的进程内通讯的原语来说，锁并不慢。从进程内通讯来说，比锁快的东西，只有原子操作。

#### 为什么锁“不容易控制”

锁的最大问题在于**不容易控制**。锁 Lock 了但是忘记 Unlock 后是灾难性的，因为相当于服务器挂了，所有和该锁相关的代码都不能被执行。例如：
```
mutex.Lock()
doSth()
mutex.Unlock()
```
在考虑异常的情况下，这段代码是不安全的，如果 doSth 抛出了异常，那么服务器就会出现问题。

> 因为锁的配对问题，所以 Go 创造了 defer 语法；因为内存的配对问题，所以 C++ 创造了 RAII。（当然，RAII 也能解决锁的问题。）

锁不容易控制的另一个表现是锁**粒度**的问题。例如上面 doSth 函数里面如果调用了网络 IO 请求，而网络 IO 请求在少数特殊情况下可能会出现慢请求，要好几秒才返回。那么这几秒对服务器来说就好像挂了，无法处理请求。

> 不要在锁里面（指在mutex.Lock和mutex.Unlock之间）执行费时操作。

#### 读写锁

从需求上来说，如果当前我们正在执行某个读操作，那么再来一个新的读操作，是不应该挡在外面的，大家都不修改数据，可以安全地并发执行。但如果来的是写操作，就应该挡在外面，等待读操作执行完。

整体来说，读写锁的特性就是：**读操作**不阻止读操作，**阻止写操作**；**写操作阻止一切**，不管读操作还是写操作。

### 执行体的同步

条件变量是最复杂的同步原语，功能强大。虽然平常我们直接使用条件变量的机会不是太多，大部分常见的场景往往有更高阶的原语（例如 channel）可以取代。但是它的设计精巧而高效，值得细细体会。

### 执行体的通讯

管道是大家都很熟知的执行体间的通讯机制。

其实 Go 语言中引入的 channel 也是管道，只不过它是类型安全的管道。

## 13进程间的同步互斥、资源共享与通讯

早期，操作系统还只有进程这个唯一的执行体。从需求角度来讲，进程内协同与进程间协同有何不同？

### 启动进程

在进程中启动另一个进程，通常有两种方法：
- 创建子进程；
- 让 Shell 配合执行某个动作。

UNIX系的操作系统都用了 fork API 来创建子进程（糟糕的架构设计）。Windows 中使用 CreateProcess，这个函数有很多的参数。

iOS 并不支持创建子进程，它做了两个很重要的变化：
- 软件不再创建多个进程实例，永远是单例的；
- 一个进程要调用另一个进程的能力，不是去创建它，而是基于 URL Scheme 去打开它。

什么是 URL Scheme？URL地址中的 https 和 ftp 就是 URL Scheme，它代表了某种协议规范。在 iOS 下，一个软件可以声明自己实现了某种 URL Scheme，比如微信可能注册了“weixin”这个 URL Scheme，那么调用
```
 UIApplication.openURL("weixin://...") 
```
都会跳转到微信。通过这个机制，我们实现了支付宝和微信支付能力的对接。

URL Scheme 机制并不是 iOS 的发明，Windows 和 Linux 的桌面也支持类似的能力，在 Windows 下调用的是 ShellExcute 函数。

### 同步与互斥





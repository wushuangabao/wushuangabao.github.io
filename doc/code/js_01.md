# 【学习】领域驱动设计实践（GitChat课程）
```
tags:
  - 学习
  - 软件
categories:
  - 软件工程

date: 2019-06-17 13:01:20
```

## “战略”开篇

微服务架构大行其道的当今，我们面临的一个棘手问题是：如何识别和设计微服务？领域驱动的战略设计恰好可以在一定程度上解决此问题。


## 第一部分：软件复杂度

### 领域驱动设计概览

领域驱动设计（Domain Driven Design，DDD）是由 Eric Evans 最早提出的综合软件系统分析和设计的面向对象建模方法，如今已经发展成为了一种针对大型复杂系统的领域建模与分析方法。它完全改变了传统软件开发工程师针对数据库进行的建模方法，从而**将要解决的业务概念和业务规则转换为软件系统中的类型以及类型的属性与行为，通过合理运用面向对象的封装、继承和多态等设计要素**，降低或隐藏整个系统的业务复杂性，并使得系统具有更好的扩展性，应对纷繁多变的现实业务问题。

#### 领域驱动设计的开放性

DDD是一种方法论，是设计观念的转变，蕴含了全新的设计思想、设计原则与设计过程。

#### 演进的领域驱动设计过程

战略设计会控制和分解战术设计的边界与粒度，战术设计则以实证角度验证领域模型的有效性、完整性与一致性，进而以演进的方式对之前的战略设计阶段进行迭代，从而形成一种螺旋式上升的迭代设计过程。如图：

![战略与战术的迭代演进](http://m.qpic.cn/psb?/V11Tp57c2B9kPO/ZCz00e36KFhPRxdL4HsrDA9rAq7XD.k7lYeF4loSxyc!/b/dLgAAAAAAAAA&bo=CQU4BAAAAAARFxA!&rf=viewer_4)

### 深入分析领域的复杂度

#### 什么是复杂？

Jurgen Appelo 从理解力与预测能力两个维度分析了复杂系统理论，这两个维度又各自分为不同的复杂层次，其中，理解力维度分为 Simple 与 Comlicated 两个层次，预测能力维度则分为Ordered、Complex 与 Chaotic 三个层次。

#### 理解力

影响理解力的第一要素是**规模**。

无论是优雅的设计，还是拙劣的设计，都可能因为某种设计权衡而导致系统**结构**变得复杂。唯一的区别在于前者是主动地控制结构的复杂度，而后者带来的复杂度是偶发的，是错误的滋生，是一种技术债，它可能会随着系统规模的增大而导致一种无序设计。

#### 预测能力

未来总会出现不可预测的**变化**。

### 控制软件复杂度的原则

针对影响复杂度的3要素（规模、结构、变化），有：
- 分而治之，控制规模
- 保持结构的清晰与一致
- 拥抱变化

除了在开发过程中，我们应尽可能做到敏捷与快速迭代，以此来抵消变化带来的影响；在架构设计层面，我们还可以分析哪些架构质量属性与变化有关，这些质量属性包括：

- 可进化性（Evolvability）
- 可扩展性（Extensibility）
- 可定制性（Customizability）

### 领域驱动设计对软件复杂度的应对

#### 需求引起的软件复杂度

需求分为业务需求和质量属性需求，引起的复杂度也分为两方面：业务复杂度和技术复杂度，两者并非完全独立。

当我们面对一个相对复杂的软件系统时，通常面临的问题在于：

- 问题域过于庞大而复杂，使得从问题域中寻求解决方案的挑战增加，该问题与软件系统的规模有关。
- 开发人员将业务逻辑的复杂度与技术实现的复杂度混淆在一起，该问题与软件系统的结构有关。
- 随着需求的增长和变化，无法控制业务复杂度和技术复杂度，该问题与软件系统的变化有关。

针对这三个问题，领域驱动设计都给出了自己的应对措施。

#### 隔离业务复杂度与技术复杂度

要避免业务逻辑的复杂度与技术实现的复杂度混淆在一起，首要任务就是确定业务逻辑与技术实现的边界，从而隔离各自的复杂度。毕竟技术与业务的关注点完全不同。

业务逻辑并不关心技术是如何实现的，无论采用何种技术，只要业务需求不变，业务规则就不会发生变化。换言之，在理想状态下，我们应该保证业务规则与技术实现是正交的。

**分层架构的关注点分离**

分层架构遵循了“关注点分离”原则，将属于业务逻辑的关注点放到领域层（Domain Layer）中，而将支撑业务逻辑的技术实现放到基础设施层（Infrastructure Layer）中。同时，领域驱动设计又颇具创见的引入了应用层（Application Layer），应用层扮演了双重角色。一方面它作为业务逻辑的外观（Facade），暴露了能够体现业务用例的应用服务接口；另一方面它又是业务逻辑与技术实现的粘合剂，实现二者之间的协作。

**六边形架构的内外分离**

体现业务逻辑的应用层与领域层处于六边形架构的内核，并通过内部的六边形边界与基础设施的模块隔离开。

**案例：隔离数据库与缓存的访问**

#### 限界上下文

针对前述案例，我们可以将缓存视为一个**独立的子系统，它同样拥有自己的业务逻辑和技术实现**，因而也可以为其建立属于缓存领域的分层架构。在架构的宏观视角，这个缓存子系统与订单子系统处于同一个抽象层次。这一概念在领域驱动设计中，被称之为限界上下文（Bounded Context）。

针对庞大而复杂的问题域，限界上下文采用了“分而治之”的思想对问题域进行了分解，有效地控制了问题域的规模，进而控制了整个系统的规模。一旦规模减小，无论业务复杂度还是技术复杂度，都会得到显著的降低，在对领域进行分析以及建模时，也能变得更加容易。

限界上下文对整个系统进行了划分，在将一个大系统拆分为一个个小系统后，我们再利用分层架构与六边形架构思想对其进行逻辑分层，以确保业务逻辑与技术实现的隔离，其设计会变得更易于把控，系统的架构也会变得更加清晰。

案例略

#### 领域模型

领域模型是对业务需求的一种**抽象**，其表达了领域概念、领域规则以及领域概念之间的关系。

一个好的领域模型是对**统一语言**的可视化表示，通过它可以减少需求沟通可能出现的歧义；通过提炼**领域知识**，并运用抽象的领域模型去表达，就可以达到对领域逻辑的化繁为简。

模型是封装，实现了对业务细节的隐藏；模型是抽象，提取了领域知识的共同特征，保留了面对变化时能够良好扩展的可能性。

案例略

## 第二部分：领域知识

组建好团队后做的第一件事：**识别问题域**，进而提炼达成共识的**领域知识**。在先启阶段、迭代开发阶段，都有相应的沟通和协作。

### 领域场景分析

领域专家或业务分析师从领域中提炼出“场景”。组成场景的要素常常被称为 6W 模型，如图：

![6W模型](http://m.qpic.cn/psb?/V11Tp57c2B9kPO/kBkohW4BkyGO65rG76bsexlnHPvlhZTa.Q6e31*4qsM!/b/dL8AAAAAAAAA&bo=hgIPAgAAAAADB6s!&rf=viewer_4)

其中，**业务价值**、**业务功能**和**业务实现**，是领域功能的三个“职责”层次。

在电商系统中，买家要购买商品，因而“下订单”这一职责具有业务价值。通过领域分析，得到如下的分层结构：
- 下订单
	- 验证订单是否有效
		- 验证订单是否为空
		- 验证订单信息是否完整
		- 验证订单当前状态是否处于“待提交”状态
		- 验证订单提交者是否为合法用户
		- 验证商品库存量是否大于等于订单中的数量
	- 基于业务规则计算订单总价、优惠与配送费
		- 获取用户信息
		- 获取当前促销规则
		- 计算订单总价
		- 计算订单优惠
		- 计算商品配送费
	- 提交订单
		- 将订单项插入到数据表中
		- 将订单插入到数据表中
		- 更新订单状态为“待付款”
	- 更新购物车
		- 删除购物车中对应的商品
	- 发送通知
		- 给买家发送电子邮件，通知订单提交成功，等待付款

利用场景进行建模时，还要充分考虑场景的边界，即 Where。例如，“下订单”案例中，验证商品库存量的业务实现须要调用库存提供的接口，该功能处于下单场景的边界之外。

按照场景分析的 6W 模型去分析领域逻辑，提炼领域知识，可以在一定程度上保证领域模型的完整性。

**领域场景分析的方法**，包括但不限于：
- 用例（Use Case）
- 用户故事（Use Story）
- 测试驱动开发（TDD）

这三个方法都是领域场景分析的具体实现，但在运用层次上各有优势。

- 用例尤其是用例图的抽象能力更强，更擅长于对**系统整体需求**进行场景分析；
- 用户故事提供了场景分析的固定模式，善于表达具体场景的**业务细节**；
- 测试驱动开发则强调对**业务的分解**，利用编写测试用例的形式驱动领域建模，让开发者从调用者角度去思考领域对象及行为。

**提炼领域知识需要贯穿整个领域驱动设计全过程**，无论何时，都必须重视领域知识，并时刻维护统一语言。在进行领域场景分析时，这是一个双向指导与更新的过程。

### 建立统一语言

统一语言是提炼领域知识的产出物，获得统一语言就是需求分析的过程，也是团队中各个角色就系统目标、范围与具体功能达成一致的过程。

统一语言体现在两个方面：
- 统一的领域术语
- 领域行为描述

在领域建模过程中，往往需要在文档中建立一个大家一致认可的术语表。包括术语概念，以及对该术语的清晰明白的解释。要给出对应的英文术语，否则可能直接影响到代码实现。

领域行为体现了更加完整的业务需求以及复杂的业务规则。描述领域行为的要求：
- 从领域角度，而非实现角度，描述领域行为
- 若涉及到领域术语，必须遵循术语表的规范
- 强调动词的精准性
- 突出与领域行为有关的领域概念

领域行为是一种契约，明确表达了业务关系，即前置条件、执行主语和宾语、执行结果。直接影响了API的设计。

## 第三部分：限界上下文

### 理解限界上下文

![限界上下文的划分](http://m.qpic.cn/psb?/V11Tp57c2B9kPO/jzEmsgWJkzSShrbjUviaLxnT6TtZ7UwCUBkIsunh7lM!/b/dMUAAAAAAAAA&bo=pwP9AQAAAAADB3o!&rf=viewer_4)

上下文（Context）表现了业务流程的场景片段。它其实是动态的业务流程被边界（Bound）静态切分的产物。

Bounded Context 用一个清晰可见的边界将上下文勾勒出来，以便维持领域模型的一致性与完整性，避免业务目标的不单一而带来的混乱与概念的不一致。

理解限界上下文的关键点：
- 知识：不同限界上下文需要的领域知识是不相同的。这体现了业务相关性。
- 角色：参与这个上下文的对象扮演了什么角色，角色之间是如何协作的。
- 边界：限界上下文按照不同的关注点进行分离，各自的边界根据耦合关系的强弱来确定。

观察角度不同，边界也会有所不同，大体分为三个方面：
- **领域逻辑层面**：确定领域模型的业务边界，降低系统的业务复杂度。
- **团队合作层面**：确定开发团队的工作边界，降低系统的管理复杂度。
- **技术实现层面**：确定系统架构的应用边界，降低系统的技术复杂度。

三种边界体现了限界上下文对不同边界的控制力。引入限界上下文的**目的**，其实**不在于如何划分边界，而在于如何控制边界**。

限界上下文并不是像大多数程序员理解的那样，是模块、服务、组件或者子系统，而是你对领域模型、团队合作以及技术风险的**控制**。

单元“自治”4要素：**最小完备、自我履行、稳定空间、独立进化**。

稳定空间要求符合开放封闭原则（OCP），体现为一个单元的封闭空间（封装隐藏）与开放空间（抽象统一）；独立进化则相反，意思要减少单元的变化对外界的影响，保证对外公开接口的稳定性。

对于统一语言，限界上下文是语言的边界；对于领域模型，限界上下文是模型的边界。二者可以帮助我们界定**问题域**（Problem Space）。
限界上下文是**连接问题域与解决方案域**的重要桥梁。

限界上下文
- 分离了业务边界
- 明确了工作边界
- 封装了应用边界
	- 应对高并发
	- 功能重用
	- 保证实时性
	- 第三方服务集成
	- 遗留系统

以上三条各有案例，略。

### 识别限界上下文

限界上下文的识别并不是一蹴而就的，需要演化和迭代，结合着我对限界上下文的理解，我认为通过**从业务边界到工作边界再到应用边界这三个层次抽丝剥茧，分别以不同的视角、不同的角色协作来运用对应的设计原则**，会是一个可行的识别限界上下文的过程方法。

![识别限界上下文的过程方法](http://m.qpic.cn/psb?/V11Tp57c2B9kPO/hMbi7bcZtquimYI.TsOFi72EWJuvNdPX9v1VIq*7OkI!/b/dMAAAAAAAAAA&bo=.gPtAgAAAAADBzQ!&rf=viewer_4)

用统一语言描述出业务活动，然后参考如下两个方面**识别业务边界**：
- **语义相关性**：将相同的语义作为归类的特征。
- **功能相关性**：分析业务活动之间的关联和依赖，以此作为归类的特征。

我们需要对划定的业务边界进行**命名**，命名过程中可以识别业务活动的共同特征，用准确的名词表达该特征。

如果说为限界上下文划分**业务边界**，更多的是从业务相关性（内聚）判断业务的归属，那么基于团队合作划分**工作边界**可以帮助我们确定限界上下文合理的**工作粒度**。

从**工作边界**识别限界上下文，要考虑的几点：
- 保证质量属性
- 重用和变化
	- 运用重用原则分离出的限界上下文往往对应子领域（Sub Domain）
	- 封装变化，是“单一职责”原则的体现，即一个限界上下文不应该存在两个引起它变化的原因
- 遗留系统（一个还在运行和使用，但已步入软件生命衰老期的缺乏足够知识的软件系统）应该被视为一个限界上下文

### 理解上下文映射

通过以上过程去识别限界上下文，仅仅是一种对领域**问题域的静态划分**，我们还缺少另外一个重要的关注点，即：限界上下文之间是如何协作的？
倘若限界上下文识别不合理，协作就会变得更加困难，尤其当一个限界上下文对应一个微服务时，协作成本更会显著增加。反过来，当我们发现彼此协作存在问题时，说明限界上下文的划分出现了问题，这算是对识别限界上下文的一种验证方法。Eric Evans 将**体现限界上下文协作方式的要素**称之为“**上下文映射**（Context Map）”。

一个软件系统通常被分为多个限界上下文，这是运用“分而治之”思想来降低业务复杂度的有效手段，设计的难题往往会停留在“**如何分**”。然而限界上下文之间的“**怎么合**”问题同样值得关注，分与合遵循的还是软件设计的最高原则——高内聚、松耦合。

分是合的基础，基于内聚相关度进行合理的分配，可以在一定程度减少限界上下文之间不必要的关联。假设分配是合理的，则接下来的“合”就是要尽可能地降低彼此之间的耦合。

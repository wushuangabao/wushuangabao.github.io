# 【编程范式】面向对象编程

```
tags:
  - 编程范式
categories:
  - 编程艺术
toc: false
date: 2019-07-28 22:46:03
```

函数式编程把一些功能或逻辑代码通过函数拼装起来。
代码中处理的数据，就是所谓的“状态”。函数式编程要求我们写出无状态的代码。但是天下并不存在没有状态、没有数据的代码。

我们很熟悉的面向对象编程（Object-oriented programming, OOP）有三大特性：封装、继承和多态。


## 介绍

一些常识我就不摘录了，但不得不提的是[《设计模式：可复用面向对象软件的基础》](https://book.douban.com/subject/1052241/)一书，在此书中共收录了 23 种设计模式。

这本书的 23 个经典的设计模式，基本上就是说了两个面向对象的核心理念：

**"Program to an 'interface', not an 'implementation'."**
面向“接口”编程，而不是“实现”。
- 使用者不需要知道数据类型、结构、算法的细节。
- 使用者不需要知道实现细节，只需要知道提供的接口。
- 利于抽象、封装、动态绑定、多态。
- 符合面向对象的特质和理念。

**"Favor ‘object composition’ over ‘class inheritance’."**
“对象组合”优于“类继承”。
- 继承需要给子类暴露一些父类的设计和实现细节。
- 父类实现的改变会造成子类也需要改变。
- 我们以为继承主要是为了代码重用，但实际上在子类中需要重新实现很多父类的方法。
- 继承更多的应该是为了多态。

## 示例一：拼装对象

有如下描述：
- **四个物体**：木头桌子、木头椅子、塑料桌子、塑料椅子
- **四个属性**：燃点、密度、价格、重量

怎么用面向对象的方式来设计我们的类呢？
- **材质类 Material**。属性：燃点，密度。被 Wood 和 Plastic 类继承。
- **家具类 Furniture**。属性：价格，体积。被 Table 和 Chair 类继承
- **在家具类中耦合了材质类**。而具体材质是 Wood 还是 Plastic，这在构造对象的时候注入到 Furniture 里就好了。
- 在家具类中，通过材质的密度属性和家具的体积属性就可以计算出重量属性。

它和现实世界相对应，而且材质是可重用的。这个模式（**桥接模式**）还表现了面向对象拼装数据的另一个精髓——喜欢**组合**，而不是继承。

## 示例二：拼装功能

**需求**：处理电商系统中的订单。一个关键的动作是计算订单的价格。有的订单需要打折，有的则不打折。

假设我们用 Java 语言，我们需要先写一个**接口**（使用 interface 关键字）——`BillingStrategy`，其中一个方法就是`GetActPrice(double rawPrice)`，输入一个原始价格，输出一个根据相应策略计算出来的价格。

这个接口只是对接口的抽象，与实现无关。我们用 class NormalStrategy implements BillingStrategy 和 class HappyHourStrategy implements BillingStrategy 对这个接口进行两个策略的**实现**。

我们封装订单项 `OrderItem`，它包含每个商品的原始价格和数量，以及价格计算的策略。然后，在订单类 `Order` 中封装 `OrderItem` 的列表，即商品列表。并在操作订单添加购买商品时，加入一个计算价格的 `BillingStrategy`。

定价策略和订单处理的流程分开了。这么做的好处是，我们可以随时给不同的商品注入不同的价格计算策略，有很高的灵活度。剩下的就是交给**运营人员来配置**不同的商品使用什么样的价格计算策略。

这个设计模式叫**策略模式**。这是设计模式中最为经典的模式，充分体现了面向对象编程的方式。

**注意**：现实社会中，订单价格计算会比这个事复杂得多，比如：有会员价，有打折卡，还有商品的打包价等，而且还可以叠加不同的策略（叠加策略用前面说的函数式的 pipeline 或 decorator 就可以实现）。我们这里只是为了说明面向对象编程范式，所以故意简单化了。

## 示例三：资源管理

```
mutex m;
void foo() {
    m.lock();
    Func();
    if ( ! everythingOk() ) return; 
    ...
    ...
    m.unlock();
}
```

上面的代码有问题：if 语句返回时没有把锁给 unlock 掉。但是，在所有函数退出的地方都要加上 `m.unlock();` 语句，会让我们很难维护代码。
于是，我们先设置一个代理类：

```
class lock_guard {
private: 
    mutex &_m;
public:
    lock_guard(mutex &m):_m(m) { _m.lock(); }
    ~lock_guard() { _m.unlock(); }
};
```

然后就可以这样写了：

```
mutex m;
void foo() {
    lock_guard guard(m);
    Func();
    if ( ! everythingOk() ) {
        return;
    } 
    ...
    ...
}
```

这是 C++ 中的一个利用了面向对象的技术，叫 RAII（直译：资源获取就是初始化）。这个模式叫做**代理模式**，我们可以把一些控制资源分配和释放的逻辑交给这些代理类，然后只需要关注业务逻辑代码了。在业务逻辑代码中，减少了与业务逻辑不相关的程序控制代码。


## IoC 控制反转

在上面的示例中：
- 我们使用接口抽象了具体的实现类。
- 然后**其它类耦合的是接口**而不是实现类。这就是多态，其增加了程序的可扩展性。
- 因为这就是接口编程，所谓接口也就是一种“协议”，就像 HTTP 协议一样。浏览器和后端的程序都依赖于这一种协议，而不是具体实现（如果是依赖具体实现，那么浏览器就要依赖后端的编程语言或中间件了，这就太恶心了）。于是，浏览器和后端的程序就完全解除依赖关系，而去依赖于一个标准的协议。
- 这就是面向对象的编程范式的精髓！同样也是 **IoC/DIP**（控制反转 / 依赖倒置）的本质。

IoC 技术描述（百度百科、维基百科）：
>Class A中用到了Class B的对象b，一般情况下，需要在A的代码中显式的new一个B的对象。
>采用依赖注入技术之后，A的代码只需要定义一个私有的B对象，不需要直接new来获得这个对象，而是通过相关的容器控制程序来将B对象在外部new出来并注入到A类里的引用中。

举例略。所谓控制反转的意思是，开关从以前设备的专用开关，转变到了控制电源的开关，而以前的设备要反过来依赖于开关厂声明的电源连接接口。只要符合开关厂定义的电源连接的接口，这个开关可以控制所有符合这个电源连接接口的设备。也就是说，**开关从依赖设备这种情况，变成了设备反过来依赖于开关所定义的接口**。

这样的例子在生活中太多见了，比如说钱就是一个很好的例子。**所谓“钱”其实就是一种交易协议**，所有的商品都依赖这个协议，而不用再互相依赖了。于是整个世界的运作就简单了很多。
在交易的过程中，卖家向买家卖东西，一手交钱一手交货，所以，基本上来说卖家和买家必需强耦合（必需见面）。这个时候，银行出来做担保，买家把钱先垫到银行，银行让卖家发货，买家验货后，银行再把钱打给卖家。**这就是反转控制**。买卖双方把对对方的直接依赖和控制，反转到了让对方来依赖一个标准的交易模型的接口。股票交易也是一样的，证交所就是买卖双方的标准交易模型接口。

这个思维方式其实还深远地影响了很多东西，比如我们的系统架构。
让各个业务方来依赖于标准插件和工作流接口，反转控制，让它们来控制系统，依赖倒置，让它们来依赖标准。

- 我们每天都在标准化和定制化中纠结。我们痛苦于哪些应该是平台要做的，哪些应该要甩出去的。
- 这里面会出现大量的与业务无关的软件或中间件，包括协议、数据、接口……
- 通过面向对象的这些方式，我们可以通过抽象来解耦，通过中间件来解耦，这样可以降低软件的复杂度。
总而言之，我们就是想通过一种标准来让业务更为规范。

## 总结面向对象优缺点

**优点**：
- 能和真实的世界交相辉映，符合人的直觉。
- 面向对象和数据库模型设计类型，更多地关注对象间的模型设计。
- 强调于“名词”而不是“动词”，更多地关注对象和对象间的接口。
- 根据业务的特征形成一个个高内聚的对象，有效地分离了抽象和具体实现，增强了可重用性和可扩展性。
- 拥有大量非常优秀的设计原则和设计模式。
- S.O.L.I.D（单一功能、开闭原则、里氏替换、接口隔离以及依赖反转，是面向对象设计的五个基本原则）、IoC/DIP……

**缺点**：
- 代码都需要附着在一个类上，从一侧面上说，其鼓励了类型。
- 代码需要通过对象来达到抽象的效果，导致了相当厚重的“代码粘合层”。
- 因为太多的封装以及对状态的鼓励，导致了大量不透明并在并发下出现很多问题。
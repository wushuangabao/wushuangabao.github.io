# 虚幻4渲染架构
```
tags:
  - 学习
  - UE4
categories:
  - 游戏引擎

date: 2021-03-31 11:30:05
```

本文乃阅读《大象无形：虚幻引擎》第11.2节《渲染架构》的记录。


## 延迟渲染

> 虚幻引擎对于场景中所有不透明的物体的渲染方式，是**延迟渲染**（Deferred Rendering）；对于透明物体的渲染方式，是**前向渲染**（Forward Rendering）。

延迟渲染是将“光照渲染”延迟进行。每次渲染，会把所有物体的BaseColor、粗糙度、表面法线、像素深度等分别渲染成图片，然后根据这些图片计算光照。

好处：无论场景中有多少物体，经过光照准备阶段之后，都只是变成了几张贴图，等到计算光照的时候，只需要对每个光源进行一次渲染计算即可。（n×m的计算量被降低为n+m。）

代价：半透明的物体无法被渲染。

因此UE是先延迟光照计算不透明物体，再借助深度排序计算半透明物体。我们可以看到，假如玻璃材质背后是半透明物体，就容易由于深度排序出现各种问题。

## 渲染过程

> 屏幕上的画面究竟是如何呈现的？导入的fbx文件、创建的材质以及定义的Static Mesh Component静态网格体组件，是怎么转换为屏幕上花花绿绿的像素的呢？

UE的渲染过程是一个异步的、多线程（Game，Render，RHI）配合的过程。这里不考虑RHI线程的RHICommandList这一部分的异步性，也就是假定当一个渲染指令被填充到RHICommandList后，该指令直接被完成。

### 延迟渲染到最终结果

这部分主要分析的内容是`FDeferedSceneRenderer::Render`函数。

![延迟渲染流程](http://m.qpic.cn/psc?/V11Tp57c2B9kPO/TmEUgtj9EK6.7V8ajmQrEMSF7nrUiGZZ9s7Q09cYUpKlARshwbQIoATuqj*uqf1OeDb4VoMorhZLTE2apAKSY.UdQXWGbcM4ciXYl9jGrsU!/b&bo=ZwOsAwAAAAADJ8k!&rf=viewer_4)

#### 准备

假设我们已经知晓了摄像机的角度，完成了场景中对象的收集（这些对象已经进行了归并和转化，成为某种很容易获得顶点缓冲区、索引缓冲区和着色点信息的某种中间格式）。现在我们手中的对象是由顶点和索引规定的三角形面片组合，以及对应的着色器信息。

#### 初始化视口

InitViews函数，一口气渲染多个视图，而不是逐视图渲染。

初始化时，剔除在这些视图中都不可见的对象，分为三步：预设可见性，可见性计算，完成可见性计算。

##### 预设置可见性

对应函数为`PreVisibilityFrameSetup`，主要执行以下内容：
1. 根据当前画质设置，设置`TemporalAA`的采样方式，同时确定采样位置（这个位置用于微调后面的矩阵）。
2. 设置视口矩阵，包括视口投影矩阵和转换矩阵。

##### 可见性计算

对应函数`ComputViewVisibilty`，主要执行以下内容：
1. 初始化视口的一系列用于可视化检测的缓冲区（实际上是一系列的位数组，用0或1代表是否可见）。
2. 使用模板函数`FrustumCull`进行并行化的异步“平截头体剔除”（剔除摄像机视口的远近平面构成的梯台外的对象）。
3. 对于编辑器来说，直接剔除掉过小的线框；如果是线框模式，所有的非线框也会被剔除。
4. 在线框模式下，剔除被别的对象遮挡的对象（这个计算过程用的是上一帧的数据）。
5. 根据所有的可见性位图，设置每个需要渲染的对象的可见性状况，即Hidden flags。
6. 然后每个对象都有一个机会重新设置为可见，这是给开发者自行干涉的部分。
7. 最后获得所有动态对象的渲染信息，对应每个`RenderProxy`的`GetDynamicMeshElements`函数。

##### 完成可见性计算

对应函数为`PostVisibilityFrameSetup`：
1. 对半透明的对象进行排序。只有从后往前渲染半透明对象才能保证渲染结果的正确性。
2. 对于每个光照，确定当前光照可见的对象列表，这里也使用平截头体剔除。
3. 初始化雾与大气的常量值。

这个阶段也完成对阴影的计算。

#### PrePass预处理阶段

PrePass过程是可选的，主要目的是为了降低Base Pass的渲染工作量。这一过程不需要计算颜色，只计算不透明物体的像素的深度。

总体来说，预处理阶段的工作过程如下：
1. 设置渲染状态。对应函数`SetupPrePassView`，关闭颜色写入，打开深度测试与深度写入。
2. 渲染三个绘制列表，渲染顺序依次为：PostionOnlyDepthDrawList，DepthDrawList，MaskedDepthDrawList。
3. 绘制动态的预处理阶段对象。会通过`ShouldUseAsOccluder`函数询问Render Proxy是否被当做一个遮挡物体，同时也会配合是否可移动等情况决定是否在这个阶段绘制。

#### DrawVisible绘制可见对象

##### 绘制步骤

传统的图形API绘制的基本步骤：设置渲染状态——载入着色器——设置渲染参数——提交渲染请求——写入渲染目标缓冲区。

UE中对于“写入渲染目标”，在步骤之前就通过RHI的`SetRenderTarget`设置好了。GPU会默认地将渲染结果写入到当前设置的渲染目标中，不需要人为进行干涉。

多个Pass中的绘制过程是类似的，典型案例是`TStaticMeshDrawList::DrawVisible`函数，下面基于这个函数重点分析前三个步骤。

##### 设置渲染状态

在绘制之前，每个`TStaticMeshDrawList`已经进行了排序。绘制时尽量公用同样的绘制状态，包括以下着色器状态：
- 顶点描述 Vertex Declaration
- 顶点着色器 Vertex Shader
- 壳着色器 Hull Shader
- 域着色器 Domain Shader
- 像素着色器 Pixel Shader
- 几何着色器 Geometry Shader

可以把一个着色状态看做是顶点描述和整个渲染管线用到的着色器对象的集合。而在同一个列表中，这些东西都是一致的，区别只是在于渲染过程具体参数不同，如顶点缓冲区不同、索引缓冲区不同。

##### 载入公共着色器信息

这是逐列表完成的，对应函数`SetBoundShaderState`和`SetSharedState`。

##### 逐元素渲染

这里的元素是经过组合的BatchElement。渲染主要包含两个子步骤：
1. 对每个`DrawingPolicy`调用`SetMeshRenderState`函数，设置渲染状态。
2. 调用当前 Batch Element 的`DrawMesh`函数，实际完成绘制。其中顶点缓冲区和索引缓冲区是一开始就已经上传到显存准备好了的。

#### BasePass

这个阶段通过逐对象的绘制，将每个对象和光照相关的信息都写入到缓冲区中。其中逐对象渲染的过程和前文对`DrawVisible`的分析过程一致。

……

#### RenderOcclusion渲染遮挡

#### 光照渲染


### 渲染着色器数据提供

#### ShaderMap

#### 着色器数据选择


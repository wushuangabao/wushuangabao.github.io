# 【编程范式】泛型编程（以C/C++为例）

```
tags:
  - 编程范式
  - C/C++
categories:
  - 编程艺术
toc: false
date: 2019-07-23 17:14:42
```

通过对**编程范式**的了解，不但可以知道整个编程语言的发展史，而且还能提高自己的编程技能。

C++ 中的 STL 是泛型编程（Generic Programming）的代表。


## 从 C 语言开始

C 语言历史悠久，现在看到的几乎所有编程语言都是以 C 语言为基础来扩展的。

大多数 C Like 编程语言其实都是在改善 C 语言带来的问题。

### 设计目标和理念

总体来说，C 语言设计目标是提供一种**能以简易的方式编译、处理低层内存、产生少量的机器码以及不需要任何运行环境支持便能运行**的编程语言。C 语言也很适合搭配汇编语言来使用。

C 语言的理念是：

- 相信程序员；
- 不会阻止程序员做任何底层的事；
- 保持语言最小和最简的特性；
- 保证 C 语言最快的运行速度，哪怕牺牲移植性。

像 C 语言这样的过程式编程语言的优点是底层灵活而且高效，特别适合开发运行较快且对系统资源利用效率较高的程序。

### C 语言特性的简单总结

1. 静态弱类型，使用变量时需要声明变量类型，但是类型建有隐式转换；
2. 不同的变量类型可以用结构体组合在一起，以此声明新的数据类型；
3. 可以用 typedef 关键字来定义类型的别名，以此达到变量类型的抽象；
4. 是有结构化程序设计、具有变量作用域以及递归功能的过程式语言；
5. 传递参数一般以值传递，也可以传递指针；
6. 通过指针可以容易地对内存进行低级控制，然而这加大了编程的复杂度；
7. 编译预处理让 C 语言的编译更具有弹性，比如跨平台。

这些特性让程序员在微观层面的操作非常精准，可以在底层和系统细节上非常自由、灵活、精确地控制代码。

然而在代码组织和功能编程上，上述特性就不那么美妙了。

### 静态语言最糟糕的问题

数据类型就好像螺帽，有多种：平口的、十字的、六角的。而螺丝刀就像函数，或是操作这些螺丝的算法或代码。
而且螺丝还有不同的尺寸（比如整型的 int, long, ...）。与之匹配的工具的复杂度很高。

这就是类型为编程带来的问题。

通过一种更为通用的方式，即**抽象和隔离**，可以让复杂的世界变得简单一些。

要做到抽象，对于 C 语言这样的类型语言来说，首先要抽象类型——就是泛型。

### C 语言的泛型

C 语言的类型泛型基本上就是使用 `void*` 关键字或是使用宏定义。

#### void*

一个使用 `void*` 泛型的 swap 函数：
```
void swap(void* x, void* y, size_t size)
{
    char tmp[size];
    memcpy(tmp, y, size);
    memcpy(y,   x, size);
    memcpy(x, tmp, size);
}
```

这个是实现方式有三个重点：

- 加上类型长度的标识参数 size。因为类型被抽象掉，编译器不能通过类型得到类型的尺寸。增加了接口复杂度。
- 函数实现中使用了 memcpy 函数。因为类型被抽象掉，不能用赋值表达式，只能用内存复制的方法。
- 函数实现中使用了 temp[size] 数组。

C 语言的类型抽象，使编程复杂度提升。

同时，还有问题。比如，交换两个 `char*` 类型，x 和 y 参数就要用 `void**` 了。

#### 宏定义

```
#define swap(x, y, size) {\
    char temp[size]; \
    memcpy(temp, &y, size); \
    memcpy(&y,   &x, size); \
    memcpy(&x, temp, size); \
}
```

带来问题：编译器做字符串替换，导致代码膨胀，进而导致编译出的执行文件比较大。

最大的一个问题：可能会有重复执行。如以下代码：
```
#define min(x, y)  （(x)>(y) ? (y) : (x)）

min(i++, j++)  // i++ j++会被调用两次
min(foo(), bar()) // foo() bar() 被调用两次
```

而且，这种泛型太宽松，完全不检查类型，直接拷贝内存，比较危险。

#### 更为复杂的数据结构泛型

数据类型的自适应已经够复杂的了，数据结构的自适应会把这个事的复杂度搞高上几个数量级。

### 语言问题小结

1. 一个通用的算法，需要对所处理的数据的数据类型进行适配。但在适配数据类型的过程中，C 语言只能使用 void* 或 宏替换的方式，这两种方式导致了类型过于宽松，并带来其它的很多问题。
2. 适配数据类型，需要 C 语言在泛型中加入一个类型的 size，这是因为我们识别不了被泛型后的数据类型，而 C 语言没有运行时的类型识别，所以，只能将这个工作抛给调用泛型算法的程序员来做了。
3. 算法其实是在操作数据结构，而数据则是放到数据结构中的，所以，真正的泛型除了适配数据类型外，还要适配数据结构。最后这个事情导致泛型算法的复杂急剧上升，比如，容器内存的分配和释放，不同的数据体可能有非常不一样的内存分配和释放模型；再比如，对象之间的复制，要把它存进来我需要有一个复制，这其中又涉及到是深拷贝，还是浅拷贝。
4. 最后，在实现泛型算法的时候，你会发现自己在纠结哪些东西应该抛给调用者处理，哪些又是可以封装起来的。而如何平衡和选择，并没有定论，也不好解决。

## C++ 语言

随着认知的升级，面向过程的 C 语言无法满足更高层次编程的需要，于是 C++ 出现了。

1980 年，AT&T 贝尔实验室。推荐《C++语言的设计和演化》，作者是语言创建者本人。

C++ 解决了很多C 的问题和不方便，参考[《C++的坑真的多吗？》](https://coolshell.cn/articles/7992.html)。

### C++ 泛型编程

C++ 是支持编程范式最多的一门语言。它最大的意义是解决了 C 语言的泛型编程问题。

理想情况下，算法应该是与数据结构及类型无关的，只关心一个标准的实现。

一个良好的泛型编程要解决如下问题：
1. 算法的泛型；
2. 类型的泛型；
3. 数据结构（数据容器）的泛型。

C++ 如何有效解决泛型问题？

#### 类

- 构造函数、析构函数，表示类的分配和释放。
- 拷贝构造函数，表示对内存的复制。
- 重载操作符。

这样，通过类就能让**用户自定义的数据类型**和**内建的数据类型**很一致了。

#### 模板

- 模板有点像 DSL，的特化会根据使用者的类型在编译时期生成那个模板的代码。
- 模板可以通过一个虚拟类型来做类型绑定，这样不会导致类型转换时带来的问题。

通过模板，取代了 C 时代的宏定义。

#### 虚函数和运行时类型识别

- 虚函数带来的多态在语义上可以支持“同一类”的类型泛型。
- 运行时类型识别技术可以做到在泛型时对具体类型的特殊处理。

通过这些，可以写出基于抽象类型的借接口。

### C++ 泛型编程示例

实现一个**遍历算法**的泛型。

1. 使用**模板**技术来抽象类型，这样可以写出与类型无关的数据结构（数据容器）。
2. 使用一个**迭代器**来遍历或是操作数据结构内的元素。

C 语言的代码：
```
int search(void* a, size_t size, void* target, 
size_t elem_size, int(*cmpFn)(void*, void*) )
{
    for(int i=0; i<size; i++) {
        if ( cmpFn (a + elem_size * i, target) == 0 ) 
            return i;
    }
    return -1;
}
```

C++泛型版的代码：
```
template<typename T, typename Iter>
Iter search(Iter pStart, Iter pEnd, T target) 
{
    for(Iter p = pStart; p != pEnd; p++) {
        if ( *p == target ) 
            return p;
    }
    return NULL;
}
```

在 C++ 的泛型版本中，我们可以看到：
- 使用`typename T`抽象了数据结构中存储**数据的类型**。
- 使用`typename Iter`，这是不同的数据结构需要自己实现的“迭代器”，这样也就抽象掉了**不同类型的数据结构**。
- 然后，我们对数据容器的遍历使用了Iter中的`++`方法，这是数据容器需要重载的操作符，这样通过操作符重载也就**泛型掉了遍历**。
- 在函数的入参上使用了`pStart`和`pEnd`来表示遍历的起止。
- 使用`*Iter`来取得这个“指针”的内容。这也是通过重载 `*` 操作符来达到**取值的泛型**。

当然，你可能会问，为什么我们不用标准接口`Iter.Next()`取代++， 用`Iter.GetValue()`来取代`*`，而是通过重载操作符？其实这样做是为了兼容原有 C 语言的编程习惯。

### 重要技术 - 迭代器

如何解决泛型函数中`T result = 0` 前面这个类型 T 的问题？

在调用者使用`vector<int>::iterator`这样的声明时，数据类型`int`已经被传入`Iter`中了。

我们要精心地设计一个迭代器，下面是一个精简版（C++ STL 代码里的迭代器代码很多很复杂）：

```
template <class T>
class container {
public:
    class iterator {
    public:
        typedef iterator self_type;
        typedef T   value_type;
        typedef T*  pointer;
        typedef T&  reference;
        reference operator*();
        pointer operator->();
        bool operator==(const self_type& rhs)；
        bool operator!=(const self_type& rhs)；
        self_type operator++() { self_type i = *this; ptr_++; return i; }
        self_type operator++(int junk) { ptr_++; return *this; }
        ...
        ...
    private:
        pointer _ptr;
    };
    iterator begin();
    iterator end();
    ...
    ...
};
```

几个关键点：
- 首先，一个迭代器需要和一个容器在一起，因为里面是对这个容器的具体的代码实现。
- 它需要重载一些操作符，比如：取值操作`*`、成员操作`->`、比较操作`==`和`!=`，还有遍历操作`++`，等等。
- 然后，还要`typedef`一些类型，比如`value_type`，告诉我们容器内的数据的实际类型是什么样子。
- 还有一些，如`begin()`和`end()`的基本操作。
- 我们还可以看到其中有一个`pointer _ptr`的内部指针来指向当前的数据（注意，`pointer`就是 `T*`）。

如何解决泛型函数中`T result = 0` 后面这个0（初始化）的问题？算法没办法搞定，只能让用户传入。

求和的泛型函数如下：
```
template <class Iter>
typename Iter::value_type
sum(Iter start, Iter end, T init) {
    typename Iter::value_type result = init;  // 这是关键，解决了 T result = 0 的所有问题
    while (start != end) {
        result = result + *start;
        start++;
    }
    return result;
}
```

### 更高维度的抽象


上面的求和函数，让它的业务逻辑不局限于求和（与业务逻辑分离），抽象度更高：

```
template<class Iter, class T, class Op>
T reduce (Iter start, Iter end, T init, Op op) {
    T result = init;
    while ( start != end ) {
        result = op( result, *start );  // 把迭代器的值交给 op 函数来操作。
        start++;
    }
    return result;
}
```

可以使用这个`reduce`函数和其他函数以期实现更为复杂的功能。

比如，定义一个函数对象`counter`。这个函数需要一个`Cond`函数对象，用来做条件判断。

```
template<class T, class Cond>
struct counter {
    size_t operator()(size_t c, T t) const {
        return c + (Cond(t) ? 1 : 0);
    }
};
```

然后，用`reduce`和`counter`共同打造`counter_if`算法（当条件满足的时候，就记个数）：

```
template<class Iter, class Cond>
size_t count_if(Iter begin, Iter end, Cond c){
    return reduce(begin, end, 0, counter<Iter::value_type, Cond>(c));
}
```

至于是什么样的条件（`Cond`），这个属于业务逻辑，应该交给使用方。

函数式编程里，可以用很多像 reduce 这样的函数来完成更多的像 STL 里的`count_if`这样有具体意义的函数。

## 类型系统和泛型的本质

我们通过 C++ 了解了底层静态类型语言的泛型编程原理。

在动态类型语言或是某些有语法糖支持的语言中，那个 `swap()` 或 `search()` 函数的泛型可以很简单地实现。

编程世界中，我们需要处理好两类事：
- 语言中的类型问题；
- 对真实世界中业务代码的抽象、重用和拼装。

### 类型系统

一般，编程语言中会有两种类型：内建类型、抽象类型。

不同语言之间类型系统主要的差异，在于编译时期的语法，以及运行时期的操作方式。

程序语言的类型系统提供以下**主要功能**：
- 程序语言的安全性。使用类型可以让编译器侦测一些代码的错误。
- 利于编译器的优化。编译器可以利用类型声明的信息做很多优化工作，例如 int 类型会以 4 个字节的整数倍进行对齐。
- 代码的可读性。有类型，语义更清晰，代码更易读和更易维护。
- 抽象化。类型是对底层内存布局的一个抽象。类型允许程序员对程序以高层次的方式思考，而不是烦人的低层次实现。

**类型带来的问题**：
我们作用于不同类型的代码，虽然长得非常相似，但是由于类型的问题需要根据不同版本写出不同的算法，如果要做到泛型，就需要涉及比较底层的玩法。

对此，世界上出现了两类语言，一类是静态类型语言，如 C、C++、Java，一类是动态类型语言，如 Python、PHP、JavaScript 等。

动态类型语言中，会以类型标记维持程序所有数值的“标记”，并在运算任何数值之前检查标记。所以，一个变量的类型是由运行时的解释器来动态标记的，这样就可以动态地和底层的计算机指令或内存布局对应起来。

**无论哪种语言，都避免不了一个特定的类型系统**。哪怕是动态类型语言，我们在读代码时，也要脑补某个变量在运行时的类型。所以，每个语言都需要一个类型检查系统。动态类型语言的代码中可以看到大量类似 `typeof` 这样的类型检查代码。

### 泛型的本质

类型的本质：
- 对内存的一种抽象。不同类型，有不同的内存分布和内存分配的策略。
- 对不同的类型的操作是不同的。有些类型还有特有的操作。

所以，要做到泛型，需要做以下事情：
- 标准化掉类型的内存分配、释放和访问。
- 标准化掉类型的操作。比如：比较操作，I/O 操作，复制操作……
- 标准化掉数据容器的操作。比如：查找算法、过滤算法、聚合算法……
- 标准化掉类型上特有的操作。需要有标准化的接口来回调不同类型的具体操作……

所以，C++ 动用了非常繁多和复杂的技术来达到泛型编程的目标：
- 通过类中的构造、析构、拷贝构造，重载赋值操作符，标准化（隐藏）了类型的内存分配、释放和复制的操作。
- 通过重载操作符，可以标准化类型的比较等操作。
- 通过 iostream，标准化了类型的输入、输出控制。
- 通过模板技术（包括模板的特化），来为不同的类型生成类型专属的代码。
- 通过迭代器来标准化数据容器的遍历操作。
- 通过面向对象的接口依赖（虚函数技术），来标准化了特定类型在特定算法上的操作。
- 通过函数式（函数对象），来标准化对于不同类型的特定操作。

**泛型的本质**就是——屏蔽掉数据和操作数据的细节，让算法更为通用，让编程者更多地关注算法的结构，而不是在算法中处理不同的数据类型。

### 小结

在编程语言中，类型系统的出现主要是对容许混乱的操作加上了严格的限制，以避免代码以无效的数据使用方式编译或运行。

但是，类型的产生和限制，虽然对底层代码来说是安全的，但是对于更高层次的抽象产生了些负面因素。比如在 C++ 语言里，为了同时满足静态类型和抽象，就导致了模板技术的出现，带来了语言的复杂性。

我们需要清楚地明白，编程语言本质上帮助程序员屏蔽底层机器代码的实现，而让我们可以更为关注于业务逻辑代码。编程语言作为机器代码和业务逻辑的粘合层，是在让程序员可以控制更多底层的灵活性，还是屏蔽底层细节，让程序员可以更多地关注于业务逻辑，这是很难两全需要 trade-off 的事。

所以，不同的语言在设计上都会做相应的取舍，比如 C 语言偏向于让程序员可以控制更多的底层细节，而 Java 和 Python 则让程序员更多地关注业务功能的实现。C++ 则是两者都想要，导致语言在设计上非常复杂。
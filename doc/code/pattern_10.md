# 【设计模式】门面模式，组合模式，享元模式

```
tags:
  - 学习
  - 设计模式
categories:
  - 编程艺术

date: 2020-06-24 12:00:39
```

摘要：主要介绍了门面模式的使用场景（与接口设计有关），组合模式的设计思路，以及享元模式与多例、缓存、池化技术的异同。


## 门面模式

### 定义与原理

门面模式，也叫外观模式，英文全称是 Facade Design Pattern。

在 GoF 的《设计模式》一书中，门面模式是这样定义的：
> Provide a unified interface to a set of interfaces in a subsystem. Facade Pattern defines a higher-level interface that makes the subsystem easier to use.

翻译成中文就是：门面模式为子系统提供一组统一的接口，定义一组高层接口让子系统更易用。

假设有一个系统 A，提供了 a、b、c、d 四个接口。系统 B 完成某个业务功能，需要调用 A 系统的 a、b、d 接口。利用门面模式，我们提供一个**包裹** a、b、d 接口调用的**门面接口 x**，给系统 B 直接使用。

> 如果接口的粒度过小，在接口的使用者开发一个业务功能时，就会导致需要调用 n 多细粒度的接口才能完成。调用者肯定会抱怨接口不好用。

> 如果接口粒度设计得太大，一个接口返回 n 多数据，要做 n 多事情，就会导致接口不够通用、可复用性不好。接口不可复用，那针对不同的调用者的业务需求，我们就需要开发不同的接口来满足，这就会导致系统的接口无限膨胀。

### 应用场景举例

在 GoF 给出的定义中提到，“门面模式让子系统更加易用”。实际上，它除了解决易用性问题之外，还能解决其他很多方面的问题。

这里的“子系统（subsystem）”可以有多种理解方式。它既可以是一个完整的系统，也可以是更细粒度的类或者模块。

#### 解决易用性问题

门面模式可以用来封装系统的底层实现，隐藏系统的复杂性，提供一组更加简单易用、更高层的接口。

比如，Linux 系统调用函数就可以看作一种“门面”。

实际上，从隐藏实现复杂性，提供更易用接口这个意图来看，门面模式有点类似之前讲到的迪米特法则（最少知识原则）和接口隔离原则：两个有交互的系统，只暴露有限的必要的接口。除此之外，门面模式还有点类似之前提到封装、抽象的设计思想，提供更抽象的接口，封装底层实现细节。

#### 解决性能问题

通过将多个接口调用替换为一个门面接口调用，可以减少网络通信成本，提高 App 客户端的响应速度。

> 如果门面接口不多，我们完全可以将它跟非门面接口放到一块，也不需要特殊标记，当作普通接口来用即可。如果门面接口很多，我们可以在已有的接口之上，再重新抽象出一层，专门放置门面接口，从类、包的命名上跟原来的接口层做区分。如果门面接口特别多，并且很多都是跨多个子系统的，我们可以将门面接口放到一个新的子系统中。

#### 解决分布式事务问题

> 在一个金融系统中，有两个业务领域模型，用户和钱包。这两个业务领域模型都对外暴露了一系列接口，比如用户的增删改查接口、钱包的增删改查接口。假设有这样一个业务场景：在用户注册的时候，我们不仅会创建用户（在数据库 User 表中），还会给用户创建一个钱包（在数据库的 Wallet 表中）。也就是说，用户注册需要支持事务——创建用户和钱包的两个操作，要么都成功，要么都失败，不能一个成功、一个失败。

要支持两个接口调用在一个事务中执行，是比较难实现的，这涉及分布式事务问题。虽然我们可以通过引入分布式事务框架或者事后补偿的机制来解决，但代码实现都比较复杂。
而最简单的解决方案是，利用数据库事务，在一个事务中，执行创建用户和创建钱包这两个 SQL 操作。这就要求两个 SQL 操作要在一个接口中完成，所以，我们可以借鉴门面模式的思想，设计一个包裹这两个操作的新接口，让新接口在一个事务中执行两个 SQL 操作。

### 与适配器模式的区别

- 适配器是做接口转换，解决的是原接口和目标接口不匹配的问题。
- 门面模式做接口整合，解决的是多接口调用带来的问题。

## 组合模式

组合模式（Composite Design Pattern）跟我们之前讲的面向对象设计中的“组合关系（通过组合来组装两个类）”，完全是两码事。这里讲的“组合模式”，主要是用来处理**树形结构**数据。

在 GoF 的《设计模式》一书中，组合模式是这样定义的：
> Compose objects into tree structure to represent part-whole hierarchies.Composite lets client treat individual objects and compositions of objects uniformly.

翻译成中文就是：将一组对象组织（Compose）成树形结构，以表示一种“部分 - 整体”的层次结构。组合让客户端（指代码的使用者）可以**统一**单个对象和组合对象的**处理**逻辑。

组合模式的设计思路，与其说是一种设计模式，倒不如说是对业务场景的一种数据结构和算法的抽象。其中，数据可以表示成树，业务需求可以通过在树上的递归遍历算法来实现。

例如，OA 系统（办公自动化系统）开发中，可以“将一组对象（员工和部门）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（部门与子部门的嵌套结构）。组合模式让客户端可以统一单个对象（员工）和组合对象（部门）的处理逻辑（递归遍历）。”

再如，“将一组对象（文件和目录）组织成树形结构，以表示一种‘部分 - 整体’的层次结构（目录与子目录的嵌套结构）。组合模式让客户端可以统一单个对象（文件）和组合对象（目录）的处理逻辑（递归遍历）。”

## 享元模式

“享元”就是被共享的单元。享元模式（Flyweight Design Pattern）的意图是**复用对象，节省内存**——前提是享元对象是**不可变**对象。

具体来讲，当一个系统中存在大量重复对象的时候，如果这些重复的对象是不可变对象，我们就可以利用享元模式将对象设计成享元，在内存中只保留一份实例，供多处代码引用。这样可以减少内存中对象的数量，起到节省内存的目的。实际上，不仅仅相同对象可以设计成享元，对于相似对象，我们也可以将这些对象中相同的部分（字段）提取出来，设计成享元，让这些大量相似对象引用这些享元。

> “不可变对象”指的是，一旦通过构造函数初始化完成之后，它的状态（对象的成员变量或者属性）就不会再被修改了。所以，不可变对象不能暴露任何修改内部状态的方法。之所以要求享元是不可变对象，那是因为它会被多处代码共享使用，避免一处代码对享元进行了修改，影响到其他使用它的代码。

### 与单例、缓存、对象池的区别

#### 享元模式与单例（多例）

在单例模式中，一个类只能创建一个对象，而在享元模式中，一个类可以创建多个对象，每个对象被多处代码引用共享。实际上，享元模式有点类似于之前讲到的单例的变体：多例。

区别两种设计模式，不能光看代码实现，而是要看设计意图，也就是要解决的问题。尽管从代码实现上来看，享元模式和多例有很多相似之处，但从设计意图上来看，它们是完全不同的：
- 应用享元模式是为了对象复用，节省内存；
- 应用多例模式是为了限制对象的个数。

#### 享元模式与缓存

在享元模式的实现中，我们通过工厂类来“缓存”已经创建好的对象。这里的“缓存”实际上是“存储”的意思，跟我们平时所说的“数据库缓存”“CPU 缓存”“MemCache 缓存”是两回事。

我们平时所讲的缓存，主要是为了提高访问效率，而非复用。

#### 享元模式与对象池

> C++ 中，为了避免频繁地进行对象创建和释放，我们可以预先申请一片连续的内存空间，也就是这里说的对象池。每次创建对象时，我们从对象池中直接取出一个空闲对象来使用，对象使用完成之后，再放回到对象池中以供后续复用，而非直接释放掉。

虽然对象池、连接池、线程池、享元模式都是为了复用，但是，如果我们再细致地抠一抠“复用”这个字眼的话，对象池、连接池、线程池等池化技术中的“复用”和享元模式中的“复用”实际上是不同的概念：
- 池化技术中的“复用”可以理解为“重复使用”，主要目的是**节省时间**（比如从数据库池中取一个连接，不需要重新创建）。在任意时刻，每一个对象、连接、线程，并不会被多处使用，而是被一个使用者**独占**，当使用完成之后，放回到池中，再由其他使用者重复利用。
- 享元模式中的“复用”可以理解为“共享使用”，在整个生命周期中，都是被所有使用者**共享**的，主要目的是**节省空间**。
# 【设计模式】积分系统设计实战

```
tags:
  - 学习
  - 设计模式
categories:
  - 软件工程

date: 2020-05-29 11:36:53
```

- 一个工程师如果要追求长远发展，就不能一直只把自己放在执行者的角色，不能只是一个代码实现者，还要有独立负责一个系统的能力，能端到端（end to end）开发一个完整的系统。这其中的工作就包括：前期的需求沟通分析、中期的代码设计实现、后期的系统上线维护等。
- 很多工程师都觉得，做业务开发没啥技术含量，没有成长，就是简单的 CRUD，翻译业务逻辑，根本用不上设计原则、思想、模式。

针对这两个普遍的现象，通过一个积分兑换系统的开发实战，一方面展示业务系统从需求分析到上线维护的整个开发套路，另一方面也展示在看似没有技术含量的业务开发中，实际上都蕴含了哪些设计原则、思想、模式。


## 需求分析

积分是一种常见的营销手段，很多产品都会通过它来促进消费、增加用户粘性，比如淘宝积分、信用卡积分、商场消费积分等等。

笼统地来讲，积分系统无外乎就两个大的功能点，一个是**赚取积分**，另一个是**消费积分**。

> Google 工程师的大部分人都具备产品思维，并不是完全的“技术控”。所以，Google 很多产品的初期设计都是工程师来完成的，在产品发展壮大到一定程度的时候，才会引入产品经理的角色。

通过产品的线框图、用户用例（user case）或者叫用户故事（user story）来细化业务流程，挖掘一些比较细节的、不容易想到的功能点。
比如，有关**积分有效期**的用户用例，我们可以进行如下的设计：
- 用户在获取积分的时候，会告知积分的有效期；
- 用户在使用积分的时候，会优先使用快过期的积分；
- 用户在查询积分明细的时候，会显示积分的有效期和状态（是否过期）；
- 用户在查询总可用积分的时候，会排除掉过期的积分。

积分系统的需求其实并不复杂，总结罗列如下：

### 积分赚取和兑换规则

积分赚取渠道包括：下订单、每日签到、评论等。

积分兑换规则可以是比较通用的。比如，签到送 10 积分。再比如，按照订单总金额的 10% 兑换成积分，也就是 100 块钱的订单可以积累 10 积分。
除此之外，积分兑换规则也可以是比较细化的。比如，不同的店铺、不同的商品，可以设置不同的积分兑换比例。

对于积分的有效期，我们可以根据不同渠道，设置不同的有效期。积分到期之后会作废；在消费积分的时候，优先使用快到期的积分。

### 积分消费和兑换规则

积分的消费渠道包括：抵扣订单金额、兑换优惠券、积分换购、参与活动扣积分等。

我们可以根据不同的消费渠道，设置不同的积分兑换规则。比如，积分换算成消费抵扣金额的比例是 10%，也就是 10 积分可以抵扣 1 块钱；100 积分可以兑换 15 块钱的优惠券等。

### 积分及其明细查询

查询用户的总积分，以及赚取积分和消费积分的历史记录。

## 系统设计

面向对象设计聚焦在代码层面（主要是针对类），那系统设计就是聚焦在架构层面（主要是针对模块）。
很多设计原则和思想不仅可以应用到代码设计中，还能用到架构设计中。还记得面向对象设计的四个步骤吗？实际上，我们也可以借鉴那个过程来做系统设计。

### 合理地将功能划分到不同模块

面向对象设计的本质就是把合适的代码放到合适的类中。合理地划分代码可以实现代码的高内聚、低耦合，类与类之间的交互简单清晰，代码整体结构一目了然。
类比面向对象设计，系统设计实际上就是将合适的功能放到合适的模块中。合理地划分模块也可以做到模块层面的高内聚、低耦合，架构整洁清晰。

针对前面所列的所有功能点，有三种模块划分方法。
1. 积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护（增删改查），不划分到积分系统中，而是放到更上层的营销系统中。这样积分系统就只需要负责增加积分、减少积分、查询积分、查询积分明细等这几个工作。
2. 积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护，分散在各个相关业务系统中，比如订单系统、评论系统、签到系统、换购商城、优惠券系统等。
3. 所有的功能都划分到积分系统中，包括积分赚取渠道及兑换规则、消费渠道及兑换规则的管理和维护。

怎么判断哪种模块划分合理呢？我们可以反过来通过看它是否符合高内聚、低耦合特性来判断。

如果一个功能的修改或添加，经常要跨团队、跨项目、跨系统才能完成，那说明模块划分的不够合理，职责不够清晰，耦合过于严重。

除此之外，为了避免业务知识的耦合，让下层系统更加通用，一般我们不希望下层系统（也就是被调用的系统）包含太多上层系统（也就是调用系统）的业务信息。但是，可以接受上层系统包含下层系统的业务信息。
比如，订单系统、优惠券系统、换购商城等作为调用积分系统的上层系统，可以包含一些积分相关的业务信息。但是，积分系统中最好不要包含太多跟订单、优惠券、换购等相关的信息。

所以，综合考虑，我们更倾向于第一种和第二种模块划分方式。但不管选择这两种中的哪一种，积分系统负责的工作是一样的，只包含积分的增、减、查询，以及积分明细的记录和查询。

### 设计模块与模块之间的交互关系

在面向对象设计中，类设计好之后，我们需要设计类之间的交互关系。
类比到系统设计，系统职责划分好之后，接下来就是设计系统之间的交互，也就是确定有哪些系统跟积分系统之间有交互以及如何进行交互。

比较常见的系统之间的交互方式有两种，一种是同步接口调用，另一种是利用消息中间件异步调用。第一种方式简单直接，第二种方式的解耦效果更好。
**上下层系统之间的调用倾向于通过同步接口，同层之间的调用倾向于异步消息调用**。比如，营销系统和积分系统是上下层关系，它们之间就比较推荐使用同步接口调用。

### 设计模块的接口、数据库、业务模型

经过模块的功能划分，模块间交互的设计，我们再来看模块本身如何设计。

实际上，**业务系统本身的设计无外乎有三方面的工作：接口设计、数据库设计和业务模型设计。**
其中数据库和接口的设计非常重要，一旦设计好并投入使用之后，这两部分都不能轻易改动。因此，我们在设计接口和数据库的时候，一定要多花点心思和时间。
相反，业务逻辑代码侧重内部实现，不涉及被外部依赖的接口，也不包含持久化的数据，所以对改动的容忍性更大。

#### 设计数据库

只需要一张记录积分流水明细的表就可以了。表中记录积分的赚取和消费流水。用户积分的各种统计数据，比如总积分、总可用积分等，都可以通过这张表来计算得到。
![数据表](http://m.qpic.cn/psc?/V11Tp57c2B9kPO/j5BRZUlgKbUG5yYXn162*TEiLF1vK8gUNkrlx*dGUL*z2UnryqQ1P2DkKYwoTbpOViM.60.j2ChMItbtSaT0tg!!/b&bo=RAY4BAAAAAARB04!&rf=viewer_4)

#### 设计接口

接口设计要符合单一职责原则，粒度越小通用性就越好。但是，接口粒度太小也会带来一些问题，比如一个功能的实现要调用多个小接口，一方面如果接口调用走网络会影响性能；另一方面，本该在一个接口中完成的原子操作分拆成多个小接口来完成，可能会涉及分布式事务的数据一致性问题（一个接口执行成功了，但另一个接口执行失败了）。

为了兼顾易用性和性能，我们可以借鉴 facade（外观）设计模式，在职责单一的细粒度接口之上，再封装一层粗粒度的接口给外部使用。设计如下这样几个接口。
![接口设计](http://m.qpic.cn/psc?/V11Tp57c2B9kPO/S1G4*2hi*D5aPIJug2nMa1U1cuU6jxPsCLM034CxtfnRryC18cwUckaizjy.gXS9OUWX9qowY3oM1LbGajKZdlGctIvS5asX7P3rETvK.6k!/b&bo=IwgJBAAAAAARFwY!&rf=viewer_4)

#### 设计业务模型

从代码实现角度来说，大部分业务系统的开发都可以分为 Controller、Service、Repository 三层。Controller 层负责接口暴露，Repository 层负责数据读写，Service 层负责核心业务逻辑，也就是这里说的业务模型。

除此之外，还有两种开发模式，基于贫血模型的传统开发模式和基于充血模型的 DDD 开发模式。前者是一种面向过程的编程风格，后者是一种面向对象的编程风格。不管是 DDD 还是 OOP，高级开发模式的存在一般都是为了应对系统的复杂性。对于我们要开发的积分系统来说，选择简单的基于贫血模型的传统开发模式就足够了。

从开发的角度来说，我们可以把积分系统作为一个独立的项目来开发，也可以跟其他业务代码（比如营销系统）放到同一个项目中开发。从运维的角度来说，我们可以将它跟其他业务一块部署，也可以作为一个微服务独立部署。具体选择哪种开发和部署方式，我们可以参考公司当前的技术架构来决定。

实际上，积分系统业务比较简单，代码量也不多，我更倾向于将它跟营销系统放到一个项目中开发部署。只要我们做好代码的模块化和解耦，让积分相关的业务代码跟其他业务代码之间边界清晰，没有太多耦合，后期如果需要将它拆分成独立的项目来开发部署，也并不困难。具体的代码实现就不给出了。

## 为什么要分 MVC 三层开发？

很多业务都比较简单，一层代码搞定所有的数据读取、业务逻辑、接口暴露不好吗？

分层具有如下优点：
1. **代码复用**。比如，UserService 中的 getUserById() 接口封装了通过 ID 获取用户信息的逻辑，这部分逻辑可能会被 UserController 和 AdminController 等多个 Controller 使用。如果没有 Service 层，每个 Controller 都要重复实现这部分逻辑，显然会违反 DRY 原则。
2. **隔离变化**。比如，Repository 层封装了对数据库访问的操作，提供了抽象的数据访问接口。基于接口而非实现编程的设计思想，Service 层使用 Repository 层提供的接口，并不关心其底层依赖的是哪种具体的数据库。当我们需要替换数据库的时候，比如从 MySQL 到 Oracle，从 Oracle 到 Redis，只需要改动 Repository 层的代码，Service 层的代码完全不需要修改。
3. **隔离关注点**。Repository 层只关注数据的读写。Service 层只关注业务逻辑，不关注数据的来源。Controller 层只关注与外界打交道，数据校验、封装、格式转换，并不关心业务逻辑。三层的关注点不同，代码的内聚性更好。
4. **提高代码的可测试性**。单元测试不依赖不可控的外部组件，比如数据库。分层之后，Repsitory 层的代码通过依赖注入的方式供 Service 层使用，当要测试包含核心业务逻辑的 Service 层代码的时候，我们可以用 mock 的数据源替代真实的数据库，注入到 Service 层代码中。
5. **应对系统的复杂性**。当一个类或一个函数的代码过多之后，可读性、可维护性就会变差。那我们就要想办法拆分。拆分有垂直和水平两个方向。**水平方向基于业务来做拆分，就是模块化；垂直方向基于流程来做拆分，就是这里说的分层。**

### BO、VO、Entity

针对 Controller、Service、Repository 三层，每层都会定义相应的数据对象，分别是 VO（View Object）、BO（Business Object）、Entity，例如 UserVo、UserBo、UserEntity。
在实际的开发中，VO、BO、Entity 可能存在大量的重复字段，甚至三者包含的字段完全一样。在开发的过程中，我们经常需要重复定义三个几乎一样的类，显然是一种重复劳动。

每层都定义各自的数据对象，主要有以下 3 个方面的原因。
1. VO、BO、Entity 并非完全一样。比如，我们可以在 UserEntity、UserBo 中定义 Password 字段，但显然不能在 UserVo 中定义 Password 字段，否则就会将用户的密码暴露出去。
2. VO、BO、Entity 三个类虽然代码重复，但功能语义不重复，从职责上讲是不一样的。所以，也并不能算违背 DRY 原则。如果合并为同一个类，那也会存在后期因为需求的变化而需要再拆分的问题。
3. 为了尽量减少每层之间的耦合，把职责边界划分明确，每层都会维护自己的数据对象，层与层之间通过接口交互。数据从下一层传递到上一层的时候，将下一层的数据对象转化成上一层的数据对象，再继续处理。虽然这样的设计稍微有些繁琐，但是**对于非常大的项目来说，结构清晰是第一位的**！

#### 不同分层之间的数据对象如何转化？

整个开发的过程会涉及“Entity 到 BO”和“BO 到 VO”这两种转化。最简单的转化方式是手动复制，自己写代码在两个对象之间一个字段一个字段赋值。Java 中提供了多种数据对象转化工具，比如 BeanUtils、Dozer 等，可以大大简化繁琐的对象转化工作。其他编程语言也可以借鉴 Java 这些工具类的设计思路，自己在项目中实现对象转化工具类。

VO、BO、Entity 都是基于贫血模型的，而且为了兼容框架或开发库（比如 MyBatis、Dozer、BeanUtils），我们还需要定义每个字段的 set 方法。这些都违背 OOP 的封装特性，会导致数据被随意修改。

设计的问题本身就没有最优解，只有权衡。

## 用到的设计思想和原则

很多人做业务开发，总感觉就是 CRUD、翻译代码，根本用不到设计原则、思想和模式，实际上只是没有发现而已。

![总结设计思想和原则](http://m.qpic.cn/psc?/V11Tp57c2B9kPO/S1G4*2hi*D5aPIJug2nMa4wvJqjSy5wg7*.V7bBhJgOrUQffoOChC*pY9SvpuosmddlaHm3KhQIX4IHTr1iCGrt97T7VG1kOhmlM*xphEzk!/b&bo=vQQ4BAAAAAARJ5U!&rf=viewer_4)